<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <link rel="stylesheet" href="http://st.pimg.net/tucs/style.css" type="text/css" />
<style>
.styleswitch {
  text-align: right;
}
</style>


<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.cookie.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_main.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_perl.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.styleswitch.js"></script>

<link rel="stylesheet" href="http://st.pimg.net/tucs/print.css" type="text/css" media="print" />
  <link rel="alternate" type="application/rss+xml" title="RSS 1.0" href="http://search.cpan.org/uploads.rdf" />
  <link rel="search" href="http://st.pimg.net/tucs/opensearch.xml" type="application/opensearchdescription+xml" title="SearchCPAN" />
  <title>DBD::RAM - search.cpan.org</title>
 <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3528438-1']);
    _gaq.push(["_setCustomVar",2,"Distribution","DBD-RAM",3]);
    _gaq.push(["_setCustomVar",5,"Release","DBD-RAM-0.072",3]);
    _gaq.push(["_setCustomVar",3,"Module","DBD::RAM",3]);
    _gaq.push(["_setCustomVar",1,"Author","JZUCKER",3]);
    _gaq.push(['_trackPageview']);
  </script>
 </head>
 <body id="cpansearch">
<center><div class="logo"><a href="/"><img src="http://st.pimg.net/tucs/img/cpan_banner.png" alt="CPAN"></a></div></center>
<div class="menubar">
 <a href="/">Home</a>
&middot; <a href="/author/">Authors</a>
&middot; <a href="/recent">Recent</a>
&middot; <a href="http://log.perl.org/cpansearch/">News</a>
&middot; <a href="/mirror">Mirrors</a>
&middot; <a href="/faq.html">FAQ</a>
&middot; <a href="/feedback">Feedback</a>
</div>
<form method="get" action="/search" name="f" class="searchbox">
<input type="text" name="query" value="" size="35">
<br>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</form>


 <a name="_top"></a>
  <div class=path>
<div id=permalink class="noprint"><a href="/perldoc?DBD::RAM">permalink</a></div>
  <a href="/~jzucker/">Jeff Zucker</a> &gt;
  <a href="/~jzucker/DBD-RAM-0.072/">DBD-RAM-0.072</a> &gt;
  DBD::RAM
 </div>

<div class="noprint" style="float:right;align:left;width:19ex">
<a href="http://hexten.net/cpan-faces/"><img src="http://www.gravatar.com/avatar/953491d7c81bfddce91d592ab61eb121?r=g&s=80&d=http%3A%2F%2Fst.pimg.net%2Ftucs%2Fimg%2Fwho.png" width=80 height=80 
style="float:right"
/></a>
<br style="clear:both"/>
<p style="text-align:right">Download:<br/> <a href="/CPAN/authors/id/J/JZ/JZUCKER/DBD-RAM-0.072.tar.gz">DBD-RAM-0.072.tar.gz</a></p>
<p style="text-align:right"><a href="http://deps.cpantesters.org/?module=DBD%3A%3ARAM;perl=latest">Dependencies</a></p>
<p style="text-align:right"><a href="http://www.annocpan.org/~JZUCKER/DBD-RAM-0.072/RAM.pm">Annotate this POD
</a></p>
<div class=box style='width:150px; float: right'>
<h1 class=t5>Related Modules</h1>
<div style="margin:2px">
<a href="/perldoc?DBD%3A%3ACSV">DBD::CSV</a><br>
<a href="/perldoc?DBD%3A%3AAnyData">DBD::AnyData</a><br>
<a href="/perldoc?SQL%3A%3AStatement">SQL::Statement</a><br>
<a href="/perldoc?Data%3A%3ADumper">Data::Dumper</a><br>
<a href="/perldoc?DBD%3A%3ASprite">DBD::Sprite</a><br>
<a href="/perldoc?DBD%3A%3AFile">DBD::File</a><br>
<a href="/perldoc?IO%3A%3AFile">IO::File</a><br>
<a href="/perldoc?Text%3A%3ACSV">Text::CSV</a><br>
<a href="/perldoc?DBD%3A%3AExcel">DBD::Excel</a><br>
<a href="/perldoc?Module%3A%3ABuild">Module::Build</a><br>
<small>
<a href="http://perlmonks.org/?node=cpan+module+search&pivot=1&module=DBD%3A%3ARAM">more...</a><br>
By <a href="http://perlmonks.org/">perlmonks.org</a></small>
</div>
</div>

<div style="float:right">
<div class=box style='width:150px'>
<h1 class=t5>CPAN RT</h1>
<div style="margin:2px">
<table style="margin-left:auto;margin-right:auto">
<tr><td>New&nbsp;</td><td style="text-align:right"> 1</td></tr>
<tr><td>Open&nbsp;</td><td style="text-align:right"> 1</td></tr>
</table>
<a href="https://rt.cpan.org/Public/Dist/Display.html?Name=DBD-RAM">View/Report Bugs</a><br/>
</div>
</div>

</div>
</div>
  Module Version:  0.07 &nbsp;
<span class="noprint">
  <a href="/src/JZUCKER/DBD-RAM-0.072/RAM.pm">Source</a> &nbsp;
</span>
<a name="___top"></a>
<div class=pod>
<div class=toc>
<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#OVERVIEW'>OVERVIEW</a>
  <li class='indexItem indexItem1'><a href='#INSTALLATION_&#38;_PREREQUISITES'>INSTALLATION &#38; PREREQUISITES</a>
  <li class='indexItem indexItem1'><a href='#SQL_&#38;_DBI'>SQL &#38; DBI</a>
  <li class='indexItem indexItem1'><a href='#WORKING_WITH_FILES_&#38;_TABLES:'>WORKING WITH FILES &#38; TABLES:</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Creating_in-memory_tables_from_data_and_files:_import()'>Creating in-memory tables from data and files: import()</a>
    <li class='indexItem indexItem2'><a href='#Saving_in-memory_tables_to_disk:_export()'>Saving in-memory tables to disk: export()</a>
    <li class='indexItem indexItem2'><a href='#Continuous_file_access:_catalog()'>Continuous file access: catalog()</a>
    <li class='indexItem indexItem2'><a href='#Specifying_file_and_directory_names'>Specifying file and directory names</a>
    <li class='indexItem indexItem2'><a href='#Using_defaults_for_quick_testing_&#38;_prototyping'>Using defaults for quick testing &#38; prototyping</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DATA_FORMATS'>DATA FORMATS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#CSV_/_PIPE_/_TAB_/_INI_(Comma,Pipe,Tab,INI_&#38;_other_&#34;delimited&#34;_formats)'>CSV / PIPE / TAB / INI (Comma,Pipe,Tab,INI &#38; other &#34;delimited&#34; formats)</a>
    <li class='indexItem indexItem2'><a href='#ARRAYS_&#38;_HASHES'>ARRAYS &#38; HASHES</a>
    <li class='indexItem indexItem2'><a href='#FIXED-WIDTH_RECORDS'>FIXED-WIDTH RECORDS</a>
    <li class='indexItem indexItem2'><a href='#XML'>XML</a>
    <li class='indexItem indexItem2'><a href='#USER-DEFINED_DATA_STRUCTURES'>USER-DEFINED DATA STRUCTURES</a>
    <li class='indexItem indexItem2'><a href='#DBI_DATABASE_RECORDS'>DBI DATABASE RECORDS</a>
    <li class='indexItem indexItem2'><a href='#MP3_MUSIC_FILES'>MP3 MUSIC FILES</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#USING_MULTIPLE_TABLES'>USING MULTIPLE TABLES</a>
  <li class='indexItem indexItem1'><a href='#TO_DO'>TO DO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>DBD::RAM - a DBI driver for files and data structures</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl"> use DBI;
 my $dbh = DBI-&#62;connect(&#39;DBI:RAM:&#39;,&#39;usr&#39;,&#39;pwd&#39;,{RaiseError=&#62;1});
 $dbh-&#62;func({
    table_name  =&#62; &#39;my_phrases&#39;,
    col_names   =&#62; &#39;id,phrase&#39;,
    data_type   =&#62; &#39;PIPE&#39;,
    data_source =&#62; [&#60;DATA&#62;],
 }, &#39;import&#39; );
 print $dbh-&#62;selectcol_arrayref(qq[
   SELECT phrase FROM my_phrases WHERE id = 1
 ])-&#62;[0];
 __END__
 1 | Hello, New World
 2 | Some other Phrase</pre>

<p>This sample creates a database table from data, uses SQL to make a selection from the database and prints out the results. While this table is in-memory only and uses pipe &#34;delimited&#34; formating, many other options are available including local and remote file access and many different data formats.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>DBD::RAM allows you to import almost any type of Perl data structure into an in-memory table and then use DBI and SQL to access and modify it. It also allows direct access to almost any kind of file, supporting SQL manipulation of the file without converting the file out of its native format.</p>

<p>The module allows you to prototype a database without having an rdbms system or other database engine and can operate either with or without creating or reading disk files. If you do use disk files, they may, in most cases, either be local files or any remote file accessible via HTTP or FTP.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OVERVIEW"
>OVERVIEW <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>This modules allows you to work with a variety of data formats and to treat them like standard DBI/SQL accessible databases. Currently supported formats include:</p>

<pre class="sh_perl">  FORMATS:

    XML    Extended Markup Language (XML)
    FIXED  fixed-width records
    INI    name=value pairs
    PIPE   pipe &#34;delimited&#34; text
    TAB    tab &#34;delimited&#34; text
    CSV    Comma Separated Values or other &#34;delimited&#34; text
    MP3    MP3 music binary files
    ARRAY  Perl array
    HASH   Perl associative array
    DBI    DBI database connection
    USR    user defined formats</pre>

<p>The data you use may come form several kinds of sources:</p>

<pre class="sh_perl">  SOURCES

    DATA         Perl data structures: strings, arrays, hashes
    LOCAL FILE   a file stored on your local computer hard disk
    REMOTE FILE  a remote file accessible via HTTP or FTP</pre>

<p>If you modify the data in a table, the modifications may be stored in several ways. The storage can be temporary, i.e. in memory only with no disk storage. Or several modifications can be done in memory and then stored to disk once at the end of the processing. Or modifications can be stored to disk continuously, similarly to the way other DBDs operate.</p>

<pre class="sh_perl">  STORAGE

    RAM          in-memory processing only, no storage
    ONE-TIME     processed in memory, stored to disk on command
    CONTINUOUS   all modifications stored to disk as they occur</pre>

<p>Here is a summary of the SOURCES, FORMATS, and STORAGE capabilities of DBD::RAM. (x = currently supported, - = notsupported, * = support in progress)</p>

<pre class="sh_perl">                                        FORMAT
                    CSV PIPE TAB FIXED INI XML MP3 ARRAY HASH DBI USR
INPUT
  array/hash/string  x    x   x    x    x   x   -    x     x   -   x
  local file         x    x   x    x    x   x   x    -     -   x   x
  remote file        x    x   x    x    x   x   *    -     -   *   x
OUTPUT
  ram table          x    x   x    x    x   x   x    x     x   x   x
  file (1-time)      x    x   x    x    x   x   -    -     -   *   *
  file (continuous)  x    x   x    x    x   *   -    -     -   x   *</pre>

<p>Please note that any ram table, regardless of original source can be stored in any of the supported file output formats. So, for example, a table of MP3 information could be stored as a CSV file, the &#34;-&#34; in the MP3 column only indicates that the information from the MP3 table can not (for obvious reasons) be written back to an MP3 file.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INSTALLATION_&#38;_PREREQUISITES"
>INSTALLATION &#38; PREREQUISITES <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>This module should work on any any platform that DBI works on.</p>

<p>You don&#39;t need an external SQL engine or a running server, or a compiler. All you need are Perl itself and installed versions of DBI and SQL::Statement. If you do not also have DBD::CSV installed you will need to either install it, or simply copy File.pm into your DBD directory.</p>

<p>You can either use the standard makefile method, or just copy RAM.pm into your DBD directory.</p>

<p>Some features require installation of extra modules. If you wish to work with the XML format, you will need to install XML::Parser. If you wish to use the ability to work with remote files, you will need to install the LWP (libnet) modules. Other features of DBD::RAM work fine without these additional modules.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SQL_&#38;_DBI"
>SQL &#38; DBI <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>This module, like other DBD database drivers, works with the DBI methods listed in DBI.pm and its documentation. Please see the DBI documentation for details of methods such as connecting, preparing, executing, and fetching data. Currently only a limited subset of SQL commands are supported. Here is a brief synopsis, please see the documentation for SQL::Statement for a more comple description of these commands.</p>

<pre class="sh_perl">       CREATE  TABLE $table 
                     ( $col1 $type1, ..., $colN $typeN,
                     [ PRIMARY KEY ($col1, ... $colM) ] )

        DROP  TABLE  $table

        INSERT  INTO $table 
                     [ ( $col1, ..., $colN ) ]
                     VALUES ( $val1, ... $valN )

        DELETE  FROM $table 
                     [ WHERE $wclause ]

             UPDATE  $table 
                     SET $col1 = $val1, ... $colN = $valN
                     [ WHERE $wclause ]

  SELECT  [DISTINCT] $col1, ... $colN 
                     FROM $table
                     [ WHERE $wclause ] 
                     [ ORDER BY $ocol1 [ASC|DESC], ... $ocolM [ASC|DESC] ]

           $wclause  [NOT] $col $op $val|$col
                     [ AND|OR $wclause2 ... AND|OR $wclauseN ]

                $op  = |  &#60;&#62; |  &#60; | &#62; | &#60;= | &#62;= 
                     | IS NULL | IS NOT NULL | LIKE | CLIKE</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WORKING_WITH_FILES_&#38;_TABLES:"
>WORKING WITH FILES &#38; TABLES: <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>This module supports working with both in-memory and disk-based databases. In order to allow quick testing and prototyping, the default behavior is for tables to be created in-memory from in-memory data but it is easy to change this behavior so that tables can also be created, manipulated, and stored on disk or so that there is a combination of in-memory and disk-based manipulation.</p>

<p>There are three methods unique to the DBD::RAM module to allow you to specify which mode of operation you use for each table or operation:</p>

<pre class="sh_perl"> 1) import()  imports data either from memory or from a file into an 
              in-memory table

 2) export()  exports data from an in-memory table to a file regardless of
              the original source of the data

 3) catalog() sets up an association between a file name and a table name
               such that all operations on the table are done continuously
               on the file</pre>

<p>With the import() method, standard DBI/SQL commands like select, update, delete, etc. apply only to the data that is in-memory. If you want to save the modifications to a file, you must explcitly call export() after making the changes.</p>

<p>On the other hand, the catalog() method sets up an association between a file and a tablename such that all DBI/SQL commands operate on the file continuously without needing to explicitly call export(). This method of operation is similar to other DBD drivers.</p>

<p>Here is a rough diagram of how the three methods operate:</p>

<pre class="sh_perl">   disk -&#62; import() -&#62; RAM

                       select
                       update
                       delete
                       insert
                       (multiple times)

   disk &#60;- export() &#60;- RAM

   catlog()
   disk &#60;-&#62; select
   disk &#60;-&#62; update
   disk &#60;-&#62; delete
   disk &#60;-&#62; insert   </pre>

<p>Regardless of which method is chosen, the same set of DBI and SQL commands may be applied to all tables.</p>

<p>See below for details of import(), export() and catalog() and for specifics of naming files and directories.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Creating_in-memory_tables_from_data_and_files:_import()"
>Creating in-memory tables from data and files: import()</a></h2>

<p>In-memory tables may be created using standard CREATE/INSERT statements, or using the DBD::RAM specific import method:</p>

<pre class="sh_perl">    $dbh-&#62;func( $args, &#39;import&#39; );</pre>

<p>The $args parameter is a hashref which can contain several keys, most of which are optional and/or which contain common defaults.</p>

<p>These keys can either be specified or left to default behaviour:</p>

<pre class="sh_perl">  table_name   string: name of the table
   col_names   string: column names for the table
   data_type   string: format of the data (e.g. XML, CSV...)</pre>

<p>The table_name key to the import() method is either a string, or if it is omitted, a default table name will be automatically supplied, starting at table1, then table2, etc.</p>

<pre class="sh_perl">     table_name =&#62; &#39;my_test_db&#39;,

  OR simply omit the table_names key</pre>

<p>If the col_names key to the import() method is omitted, the column names will be automatically supplied, starting at col1, then col2, etc. If the col_names key is the string &#39;first_line&#39;, the column names will be taken from the first line of the data. If the col_names key is a comma separated list of column names, those will be taken (in order) as the names of the columns.</p>

<pre class="sh_perl">      col_names =&#62; &#39;first_line&#39;,

  OR  col_names =&#62; &#39;name,address,phone&#39;,

  OR  simply omit the col_names key</pre>

<p>If table_name or col_names are specified, they must comply with SQL naming rules for identifiers: start with an alphabetic character; contain nothing but alphabetic characters, numbers, and/or underscores; be less than 128 characters long; not be the same as a SQL reserved keyword. If the table refers to a file that has a period in its name (e.g. my_data.csv), this can be handled with the catalog() method, see below.</p>

<p>The table_name and col_names, if specified, *are* case sensititive, so that &#34;my_test_db&#34; is not the same as &#34;my_TEST_db&#34;.</p>

<p>The data_type key to the import() method specifies the format of the data as already described above in the general description. It must be one of:</p>

<pre class="sh_perl">    data_type =&#62; &#39;CSV&#39;,
    data_type =&#62; &#39;TAB&#39;,
    data_type =&#62; &#39;PIPE&#39;,
    data_type =&#62; &#39;INI&#39;,
    data_type =&#62; &#39;FIXED&#39;,
    data_type =&#62; &#39;XML&#39;,
    data_type =&#62; &#39;MP3&#39;,
    data_type =&#62; &#39;DBI&#39;,
    data_type =&#62; &#39;USR&#39;,
    data_type =&#62; &#39;ARRAY&#39;,
    data_type =&#62; &#39;HASH&#39;,

  OR simply omit the data_type key</pre>

<p>If no data_type key is supplied, the default format CSV will be used.</p>

<p>The import() keys must specify a source of the data for the table, which can be any of:</p>

<pre class="sh_perl">    file_source   string: name of local file to get data from
  remote_source   string: url of remote file to get data from
    data_source   string or arrayref: the actual data</pre>

<p>The file_source key is the name of local file. It&#39;s location will be taken to be relative to the f_dir specified in the database connection, see the connect() method above. Whether or not the file name is case sensitive depends on the operating system the script is running on e.g. on Windows case is ignored and on UNIX it is not ignored. For maximum portability, it is safest to assume that case matters.</p>

<pre class="sh_perl">    file_source =&#62; &#39;my_test_db.csv&#39;</pre>

<p>The remote_source key is a URL (Uniform Resource Locator) to a file located on some other computer. It may be any kind of URL that is supported by the LWP module includding http and FTP. If username and password are required, they can be included in the URL.</p>

<pre class="sh_perl">     remote_source =&#62; &#39;<a href="http://myhost.com/mypath/myfile.myext" class="podlinkurl"
>http://myhost.com/mypath/myfile.myext</a>&#39;

  OR remote_source =&#62; &#39;<a href="ftp://user:password@myhost.com/mypath/myfile.myext" class="podlinkurl"
>ftp://user:password@myhost.com/mypath/myfile.myext</a>&#39;</pre>

<p>The data_source key to the import() tag contains the actual data for the table. in cases where the data comes from the Perl script itself, rather than from a file. The method of specifying the data_source depends entirely on the format of the data_type. For example with data_type of XML or CSV, the data_source is a string in XML or CSV format but with data_type ARRAY, the data_source is a reference to an array of arrayrefs. See below under each data_type for details.</p>

<p>The following keys to the import() method apply only to specific data formats, see the sections on the specific formats (listed in parens) for details:</p>

<pre class="sh_perl">        pattern   (FIXED only)
       sep_char   (CSV only)
            eol   (CSV only)
       read_sub   (USR and XML only)
           attr   (XML only)
     record_tag   (XML only)
       fold_col   (XML only)
    col_mapping   (XML only)
           dirs   (MP3 only)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Saving_in-memory_tables_to_disk:_export()"
>Saving in-memory tables to disk: export()</a></h2>

<p>The export() method creates a file from an in-memory table. It takes a very similar set of keys as does the import() method. The data_type key specifies the format of the file to be created (CSV, PIPE, TAB, XML, FIXED-WIDTH, etc.). The same set of specifiers available for the import method for these various formats are also available (e.g. sep_char to set the field separator for CSV files, or pattern to set the fixed-width pattern).</p>

<p>The data_source key for the export() method is a SQL select statement in relation to whatever in-memory table is chosen to export. The data_target key specifies the name of the file to put the results in. Here is an example:</p>

<pre class="sh_perl">        $dbh-&#62;func( {
            data_source =&#62; &#39;SELECT * FROM table1&#39;,
            data_target =&#62; &#39;my_db.fix&#39;,
            data_type =&#62; &#39;FIXED&#39;,
            pattern   =&#62; &#39;A2 A19&#39;,
        },&#39;export&#39; );</pre>

<p>That statement creates a fixed-width record database file called &#34;my_db.fix&#34; and puts the entire contents of table1 into the file using the specified field widths and whatever column names alread exist in table1.</p>

<p>See specific data formats below for details related to the export() method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Continuous_file_access:_catalog()"
>Continuous file access: catalog()</a></h2>

<p>The catalog() method creates an association between a specific table name, a specific data type, and a specific file name. You can create those associations for several files at once. The parameter to the catalog() method is a reference to an array of arrayrefs. Each of the arrayrefs should contain a table name, a data type, and a file name and can optionally inlcude other paramtets specific to specific data types. Here is an example:</p>

<pre class="sh_perl">    $dbh-&#62;func([
        [ &#39;my_csv_table&#39;, &#39;CSV&#39;,   &#39;test_db.csv&#39;  ],
     ],&#39;catalog&#39;);</pre>

<p>This example creates an association to a CSV file. Once the catalog() statement has been issued, any DBI/SQL commands relating to &#34;my_csv_table&#34; will operate on the file &#34;test_db.csv&#34;. If the command is a SELECT statement, the file witll be opened and searched. If the command is an INSERT statement, the file will be opened and the new data row(s) inserted and saved into the file.</p>

<p>One can also pass additional information such as column names, fixed-width patterns, field and record separators to the export method(). See the import() information above for the meanings of these additional parameters. They should be passed as a hashref:</p>

<pre class="sh_perl">    $dbh-&#62;func([
        [ &#39;table1&#39;, &#39;FIXED&#39;, &#39;test_db.fix&#39;,{pattern =&#62; &#39;A2 A19&#39;} ],
        [ &#39;table2&#39;, &#39;INI&#39;,   &#39;test_db.ini&#39;,{col_names =&#62; &#39;id,phrase,name&#39; ],
     ],&#39;catalog&#39;);</pre>

<p>In future releases, users will be able to store catalogs in files for permanent associations between files and data types.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Specifying_file_and_directory_names"
>Specifying file and directory names</a></h2>

<p>All filenames are relative to a user-specified file directory: f_dir. The f_dir parameter may be set in the connect statement:</p>

<pre class="sh_perl">      my $dbh=DBI-&#62;connect(&#34;dbi:RAM:f_dir=/mypath/to-files/&#34; ...</pre>

<p>The f_dir parameter may also be set or reset anywhere in the program after the database connection:</p>

<pre class="sh_perl">     $dbh-&#62;{f_dir} = &#39;/mypath/to-files&#39;</pre>

<p>If the f_dir parameter is not set explicitly, it defaults to &#34;./&#34; which will be wherever your script thinks it is running from (which, depending on server setup may or may not be the physical location of your script so use this only if you know what you are doing).</p>

<p>All filenames are relative to the f_dir directory. It is not possible to use an absolute path to a file.</p>

<p>WARNING: no taint checking is performed on the filename or f_dir, this is the responsiblity of the programmer. Since the filename is relative to the f_dir directory, a filename starting with &#34;../&#34; will lead to files above or outside of the f_dir directory so you should exclude those from filenames if the filenames come from user input.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_defaults_for_quick_testing_&#38;_prototyping"
>Using defaults for quick testing &#38; prototyping</a></h2>

<p>If no table_name is specified, a numbered table name will be supplied (table1, or if that exists table2, etc.). The same also applies to column names (col1, col2, etc.). If no data_type is supplied, CSV will be assumed. If the entire hashref parameter to import is missing and an arrayref of data is supplied instead, then defaults for all values will be used, the source will be defaulted to data and the contents of the array will be treated as the data source. For CSV file, a field separator of comma and a record separator of newline are the default. Thus, assuming there are no already exiting in-memory tables, the two statements below have the same effect:</p>

<pre class="sh_perl">    $dbh-&#62;func( [&#60;DATA&#62;], &#39;import&#39; );

    $dbh-&#62;func({
        table_name  =&#62; &#39;table1&#39;,
        data_type   =&#62; &#39;CSV&#39;,
        col_names   =&#62; &#39;col1,col2&#39;,
        sep_char    =&#62; &#39;,&#39;,
        eol         =&#62; &#34;\n&#34;,
        data_source =&#62; [&#60;DATA&#62;],
    },&#39;import&#39; );</pre>

<p>It is also possible to rely on some of the defaults, but not all of them. For example:</p>

<pre class="sh_perl">    $dbh-&#62;func({
        data_type   =&#62; &#39;PIPE&#39;,
        file_source =&#62; &#39;my_db.pipe&#39;,
    },&#39;import&#39; );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DATA_FORMATS"
>DATA FORMATS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CSV_/_PIPE_/_TAB_/_INI_(Comma,Pipe,Tab,INI_&#38;_other_&#34;delimited&#34;_formats)"
>CSV / PIPE / TAB / INI (Comma,Pipe,Tab,INI &#38; other &#34;delimited&#34; formats)</a></h2>

<p>DBD::RAM can import CSV (Comma Separated Values) from strings, from local files, or from remote files into database tables and export tables from any source to CSV files. It can also store and update CSV files continuously similarly to the way other DBD drivers operate.</p>

<p>If you wish to use remote CSV files, you also need the LWP module installed. It is available from www.activestate.com for windows, and from www.cpan.org for other platforms.</p>

<p>CSV is the format of files commonly exported by such programs as Excel, Access, and FileMakerPro. Typically newlines separate records and commas separate fields. Commas may also be included inside fields if the field itself is surrounded by quotation marks. Quotation marks may be included in fields by doubling them. Although some types of CSV formats allow newlines inside fields, DBD::RAM does not currently support that. If you need that feature, you should use DBD::CSV.</p>

<p>Here are some typical CSV fields:</p>

<pre class="sh_perl">   hello,1,&#34;testing, &#34;&#34;george&#34;&#34;, 1,2,3&#34;,junk</pre>

<p>Note that numbers and strings that don&#39;t contain commas do not need quotation marks around them. That line would be parsed into four fields:</p>

<pre class="sh_perl">        hello
        1
        testing, &#34;george&#34;, 1,2,3
        junk</pre>

<p>To import that string of CSV into a DBD::RAM table:</p>

<pre class="sh_perl">  $dbh-&#62;func({ 
      data_source =&#62; qq[hello,1,&#34;testing, &#34;&#34;george&#34;&#34;, 1,2,3&#34;,junk]
  },&#39;import&#39;);</pre>

<p>Of if one wanted to continuously update a file similarly to the way DBD::CSV works:</p>

<pre class="sh_perl">  $dbh-&#62;func([ &#39;table1&#39;, &#39;CSV&#39;,  &#39;my_test.csv&#39; ],&#39;catalog&#39;);</pre>

<p>Or if that string and others like it were in a local file called &#39;my_test.csv&#39;:</p>

<pre class="sh_perl">  $dbh-&#62;func({ file_source =&#62; &#39;my_test.csv&#39; },&#39;import&#39;);</pre>

<p>Or if that string and others like it were in a remote file at a known URL:</p>

<pre class="sh_perl">  $dbh-&#62;func({ remote_source =&#62; &#39;<a href="http://www.foo.edu/my_test.csv" class="podlinkurl"
>http://www.foo.edu/my_test.csv</a>&#39; },&#39;import&#39;);</pre>

<p>Note that these forms all use default behaviour since CSV is the default data_type. These methods also use the default table_name (table1,table2,etc.) and default column_names (col1,col2, etc.). The same functions can specify a table_name and can either specify a list of column names or specify that the column names should be taken from the first line of data:</p>

<pre class="sh_perl">  $dbh-&#62;func({ 
      file_source =&#62; &#39;my_test.csv&#39;,
       table_name =&#62; &#39;my_table&#39;,
        col_names =&#62; &#39;name,phone,address&#39;,
   },&#39;import&#39;);</pre>

<p>It is also possible to define other field separators (e.g. a semicolon) with the &#34;sep_char&#34; key and define other record separators with the &#34;eol&#34; key. For example:</p>

<pre class="sh_perl">   sep_char =&#62; &#39;;&#39;,
   eol      =&#62; &#39;~&#39;,</pre>

<p>Adding those to the import() hash would define data that has a semicolon between every field and a tilde between every record.</p>

<p>For convenience shortcuts have been provided for PIPE and TAB separators. The data_type &#34;PIPE&#34; indicates a separator of the pipe character &#39;|&#39; which may optionally have blank spaces before or afer it. The TAB data_type indicates fields that are separated by tabs. In both cases newlines remain the default record separator unless specifically set to something else.</p>

<p>Another shortcut is the INI data_type. This expects to see data in name=value pairs like this:</p>

<pre class="sh_perl">        resolution = 640x480
        colors     = 256</pre>

<p>Currently the INI type does not support sections within the .ini file, but that will change in future releases of this module.</p>

<p>The PIPE, TAB, and INI formats all behave like the CSV format. Defaults may be used for assigning column names from the first line of data, in which case the column names should be separated by the appropriate symbol (e.g. col1|col2 for PIPE, and col1=col2 for INI, and column names separated by tabs for TAB).</p>

<p>In the examples above using data_source the data was a string with newlines separating the records. It is also possible to use an reference to an array of lines as the data_source. This makes it easy to use the DATA segment of a script or to import an array from some other part of a script:</p>

<pre class="sh_perl">    $dbh-&#62;func({ data_source =&#62; [&#60;DATA&#62;] },&#39;import&#39; );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ARRAYS_&#38;_HASHES"
>ARRAYS &#38; HASHES</a></h2>

<p>DBD::RAM can import data directly from references to arrays of arrayrefs and references to arrays of hashrefs. This allows you to easily import data from some other portion of a perl script into a database format and either save it to disk or simply manipulate it in memory.</p>

<pre class="sh_perl">    $dbh-&#62;func({
        data_type   =&#62; &#39;ARRAY&#39;,
        data_source =&#62;  [
           [&#39;1&#39;,&#39;CSV:Hello New World!&#39;],
           [&#39;2&#39;,&#39;CSV:Cool!&#39;]
        ],
    },&#39;import&#39;);

    $dbh-&#62;func({
        data_type   =&#62; &#39;HASH&#39;,
        data_source =&#62; [
            {id=&#62;1,phrase=&#62;&#39;Hello new world!&#39;},
            {id=&#62;2,phrase=&#62;&#39;Junkity Junkity Junk&#39;},
        ],
    },&#39;import&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FIXED-WIDTH_RECORDS"
>FIXED-WIDTH RECORDS</a></h2>

<p>Fixed-width records (also called fixed-length records) do not use character patterns to separate fields, rather they use a preset number of characters in each field to determine where one field begins and another ends. DBD::RAM can import fixed-width records from strings, arrayrefs, local files, and remote files and can export data from any source to fixed-width record fields. The module also allows continuous disk-based updating of fixed-width format files similarly to other DBDs.</p>

<p>The fixed-width format behaves exactly like the CSV formats mentioned above with the exception that the data_type is &#34;FIXED&#34; and that one must supply a pattern key to describe the width of the fields. The pattern should be in Perl unpack format e.g. &#34;A2 A7 A14&#34; would indicate a table with three columns with widths of 2,7,14 characters. When data is inserted or updated, it will be truncated or padded to fill exactly the amount of space alloted to each field.</p>

<pre class="sh_perl"> $dbh-&#62;func({ 
     table_name =&#62; &#39;phrases&#39;,
     col_names  =&#62; &#39;id,phrase&#39;,
     data_type  =&#62; &#39;FIXED&#39;,
     pattern    =&#62; &#39;A1 A20&#39;,
     data_source =&#62; [ &#39;1Hello new world!    &#39;,
                      &#39;2Junkity Junkity Junk&#39;,
                    ],
  },&#39;import&#39; );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="XML"
>XML</a></h2>

<p>DBD::RAM can import XML (Extended Markup Language) from strings, from local files, or from remote files into database tables and export tables from any source to XML files.</p>

<p>You must have XML::Parser installed in order to use the XML feature of DBD::RAM. If you wish to use remote XML files, you also need the LWP module installed. Both are available from www.activestate.com for windows, and from www.cpan.org for other platforms.</p>

<p>Support is provided for information in tag attributes and tag text and for multiple levels of nested tags. There are several options on how to treat tag names that occur multiple times in a single record including a variety of relationships between XML tags and database columns: one-to-one, one-to-many, and many-to-one. Tag attributes can be made to apply to multiple records nested within the tag. There is also support for alternate character encodings and other XML::Parser parameter attributes.</p>

<p>See below for details.</p>

<dl>
<dt><a name='XML'></a><a name="XML_Import"
>XML Import</a></dt>

<dd>
<pre class="sh_perl"> To start with a very simple example, consider this XML string:

  &#60;staff&#62;
      &#60;person name=&#39;Joe&#39; title=&#39;bottle washer&#39;/&#62;
      &#60;person name=&#39;Tom&#39; title=&#39;flunky&#39;/&#62;
      &#60;person name=&#39;Bev&#39; title=&#39;chief cook&#39;/&#62;
      &#60;person name=&#39;Sue&#39; title=&#39;head honcho&#39;/&#62;
  &#60;/staff&#62;</pre>

<p>Assuming you have that XML structure in a variable $str, you can import it into a DBD::RAM table like this:</p>

<pre class="sh_perl">  $dbh-&#62;func({
      data_source =&#62; $str
      data_type   =&#62; &#39;XML&#39;,
      record_tag  =&#62; &#39;staff person&#39;,
      col_names   =&#62; &#39;name,title&#39;
  },&#39;import&#39;);</pre>

<p>Which would produce this SQL/DBI accessible table:</p>

<pre class="sh_perl">  name | title
  -----+--------------
  Joe  | bottle washer
  Tom  | flunky
  Bev  | chief cook
  Sue  | head honcho</pre>

<p>If the XML data is in a local or remote file, rather than a string, simply change the &#34;data_source&#34; to &#34;file_source&#34; (for local files) or &#34;remote_source&#34; (for remote files) an everything else mentioned in this section works the same as if the data was imported from a string.</p>

<p>Notice that the &#34;record_tag&#34; is a space separated list of all of the tags that enclose the fields you want to capture starting at the highest level with the &#60;staff&#62; tag. In this example there is only one level of nesting, but there could be many levels of nesting in actual practice.</p>

<p>DBD::RAM can treat both text and tag attributes as fields. So the following three records could produce the same database row:</p>

<pre class="sh_perl">      &#60;person name=&#39;Tom&#39; title=&#39;flunky&#39;/&#62;

      &#60;person name=&#39;Tom&#39;&#62; 
         &#60;title&#62;flunky&#60;/title&#62;
      &#60;/person&#62;

      &#60;person&#62;
        &#60;name&#62;Tom&#60;/name&#62;
        &#60;title&#62;flunky&#60;/title&#62;
      &#60;/person&#62;</pre>

<p>The database column names should be specified as a comma-separated string, in the order you want them to appear in the database:</p>

<pre class="sh_perl">       col_names =&#62; &#39;name,state,year&#39;</pre>

<p>If you want the database column names to be the same as the XML tag names you do not need to do anything further.</p>

<p>NOTE: you *must* speficy the column names for XML data, you can not rely on automatic default column names (col1,col2,etc.) or on reading the column names from the &#34;first line&#34; of the data as you can with most other data types.</p>

<dt><a name='Alternate'></a><a name="Alternate_relationships_between_XML_tags_&#38;_database_columns"
>Alternate relationships between XML tags &#38; database columns</a></dt>

<dd>
<p>If you want the database column names to be different from the XML tag names, you need to add a col_mapping parameter which should be a hash with the XML tag as the key and the database column as the value:</p>

<pre class="sh_perl">       col_mapping =&#62; {
           name  =&#62; &#39;Member_Name&#39;,
           state =&#62; &#39;Location&#39;,
           year =&#62;  &#39;Year&#39;,
       }

       (&#39;name&#39; is the XML tag, &#39;Member_Name&#39; is the database column)</pre>

<p>If a given tag occurs more than once in an XML record, it can be mapped onto a single column name (in which case all of the values for it will be concatenated with spaces into the single column), or it can be mapped onto an array of column names (in which case each succeeding instance of the tag will be entered into the succeeding column in the array).</p>

<p>For example, given this XML snippet:</p>

<pre class="sh_perl">  &#60;person name=&#39;Joe&#39; state=&#39;OR&#39;&#62;
      &#60;year&#62;1998&#60;/year&#62;
      &#60;year&#62;1999&#60;/year&#62;
  &#60;/person&#62;
  &#60;person name=&#39;Sally&#39; state=&#39;WA&#39;&#62;
      &#60;year&#62;1998&#60;/year&#62;
      &#60;year&#62;1999&#60;/year&#62;
      &#60;year&#62;2000&#60;/year&#62;
  &#60;/person&#62;</pre>

<p>This column mapping:</p>

<pre class="sh_perl">  col_mapping =&#62; {
      name  =&#62; &#39;Member_Name&#39;,
      state =&#62; &#39;Location&#39;,
      year =&#62;  [&#39;Year1&#39;,&#39;Year2&#39;,&#39;Year3&#39;],
  }</pre>

<p>Would produce this table:</p>

<pre class="sh_perl">  Member_Name | Location | Year1 | Year2 | Year3
  ------------+----------+-------+-------+------
  Joe         | OR       | 1998  | 1999  |
  Sally       | WA       | 1998  | 1999  | 2000</pre>

<p>And this column mapping:</p>

<pre class="sh_perl">  col_mapping =&#62; {
      name  =&#62; &#39;Member_Name&#39;,
      state =&#62; &#39;Location&#39;,
      year =&#62;  &#39;Year&#39;,
  }</pre>

<p>Would produce this table:</p>

<pre class="sh_perl">  Member_Name | Location | Year
  ------------+----------+----------------
  Joe         | OR       | 1998 1999
  Sally       | WA       | 1998 1999 2000</pre>

<p>It is also possible to map several differnt tags into a single column, e.g:</p>

<pre class="sh_perl">  &#60;person name=&#39;Joe&#39; state=&#39;OR&#39;&#62;
    &#60;year1&#62;1998&#60;/year1&#62;
    &#60;year2&#62;1999&#60;/year2&#62;
  &#60;/person&#62;
  &#60;person name=&#39;Sally&#39; state=&#39;WA&#39;&#62;
     &#60;year1&#62;1998&#60;/year1&#62;
     &#60;year2&#62;1999&#60;/year2&#62;
     &#60;year3&#62;2000&#60;/year3&#62;
  &#60;/person&#62;

  col_mapping =&#62; {
      name  =&#62; &#39;Member_Name&#39;,
      state =&#62; &#39;Location&#39;,
      year1 =&#62; &#39;Year&#39;,
      year2 =&#62; &#39;Year&#39;,
      year3 =&#62; &#39;Year&#39;,
  }

  Member_Name | Location | Year
  ------------+----------+----------------
  Joe         | OR       | 1998 1999
  Sally       | WA       | 1998 1999 2000</pre>

<dt><a name='Nested'></a><a name="Nested_attributes_that_apply_to_multiple_records"
>Nested attributes that apply to multiple records</a></dt>

<dd>
<p>It is also possible to use nested record attributes to create column values that apply to multiple records. Consider the following XML:</p>

<pre class="sh_perl">  &#60;staff&#62;
    &#60;office location=&#39;Portland&#39;&#62;
      &#60;person name=&#39;Joe&#39;&#62;
      &#60;person name=&#39;Tom&#39;/&#62;
    &#60;/office&#62;
    &#60;office location=&#39;Seattle&#39;&#62;
      &#60;person name=&#39;Bev&#39;/&#62;
      &#60;person name=&#39;Sue&#39;/&#62;
    &#60;/office&#62;
  &#60;/staff&#62;</pre>

<p>One might like to associate the office location with all of the staff members in that office. This is how that would be done:</p>

<pre class="sh_perl">    record_tag  =&#62; &#39;staff office person&#39;,
    col_names   =&#62; &#39;location,name&#39;,
    fold_col    =&#62; { &#39;staff office&#39; =&#62; &#39;location&#39; },</pre>

<p>That fold-col specification in the import() method would &#34;fold in&#34; the attribute for location and apply it to all records nested within the office tag and produce the following table:</p>

<pre class="sh_perl">   location | name
   ---------+-----
   Portland | Joe
   Portland | Tom
   Seattle  | Bev
   Seattle  | Sue</pre>

<p>You may use several levels of folded columns, for example, to capture both the office location and title in this XML:</p>

<pre class="sh_perl">  &#60;staff&#62;
    &#60;office location=&#39;Portland&#39;&#62;
      &#60;title id=&#39;manager&#39;&#62;
        &#60;person name=&#39;Joe&#39;/&#62;
      &#60;/title&#62;
      &#60;title id=&#39;flunky&#39;&#62;
        &#60;person name=&#39;Tom&#39;/&#62;
      &#60;/title&#62;
    &#60;/office&#62;
    &#60;office location=&#39;Seattle&#39;&#62;
      &#60;title id=&#39;flunky&#39;&#62;
        &#60;person name=&#39;Bev&#39;/&#62;
        &#60;person name=&#39;Sue&#39;/&#62;
      &#60;/title&#62;
    &#60;/office&#62;
  &#60;/staff&#62;</pre>

<p>You would use this fold_col key:</p>

<pre class="sh_perl">    fold_col =&#62; { &#39;staff office&#39;       =&#62; &#39;location&#39;,
                  &#39;staff office title&#39; =&#62; &#39;id&#39;,
                },</pre>

<p>And obtain this table:</p>

<pre class="sh_perl">  location | title   | name
  ---------+---------+-----
  Portland | manager | Joe
  Portland | flunky  | Tom
  Seattle  | flunky  | Bev
  Seattle  | flunky  | Sue</pre>

<p>If you need to grab more than one attribute from a single tag, you need to put one or more carets (^) on the end of the fold_col key. For example:</p>

<pre class="sh_perl">   &#60;office type=&#39;branch&#39; location=&#39;Portland&#39; manager=&#39;Sue&#39;&#62; ...&#60;/office&#62;

   fold_col =&#62; { &#39;office&#39;   =&#62; &#39;branch&#39;,
                 &#39;office^&#39;  =&#62; &#39;location&#39;,
                 &#39;office^^&#39; =&#62; &#39;manager&#39;,</pre>

<dt><a name='Character'></a><a name="Character_Encoding_and_Unicode_issues"
>Character Encoding and Unicode issues</a></dt>

<dd>
<p>The attr key can be used to pass extra information to XML::Parser when it imports a database. For example, if the XML file contains latin-1 characters, one might like to pass the parser an encoding protocol like this:</p>

<pre class="sh_perl">   attr =&#62; {ProtocolEncoding =&#62; &#39;ISO-8859-1&#39;},</pre>

<p>Attributes passed in this manner are passed straight to the XML::Parser.</p>

<p>Since the results of XML::Parser are returned as UTF-8, one might also like to translate from UTF-8 to something else when the data is entered into the database. This can be done by passing a pointer to a subroutine in the read_sub key. For example:</p>

<pre class="sh_perl">    read_sub    =&#62; \&#38;utf8_to_latin1,</pre>

<p>For this to work, there would need to be a subroutine utf8_to_latin1 in the main module that takes a UTF8 string as input and returns a latin-1 string as output. Similar routines can be used to translate the UTF8 characters into any other character encoding.</p>

<p>Apologies for being Euro-centric, but I have included a short-cut for Latin-1. One can omit the attr key and instead of passing a pointer to a subroutine in the read_sub key, if one simply puts the string &#34;latin1&#34;, the module will automatically perform ISO-8859-1 protocol encoding on reading the XML file and automatically translate from UTF-8 to Latin-1 as the values are inserted in the database, that is to say, a shortcut for the two keys mentioned above.</p>

<dt><a name='Other'></a><a name="Other_features_of_XML_import"
>Other features of XML import</a></dt>

<dd>
<p>* Tags, attributes, and text that are not specifically referred to in the import() parameters are ignored when creating the database table.</p>

<p>* If a column name is listed that is not mapped onto a tag that occurs in the XML source, a column will be created in the database for that name and it will be given a default value of NULL for each record created.</p>

<dt><a name='XML'></a><a name="XML_Export"
>XML Export</a></dt>

<dd>
<p>Any DBD::RAM table, regardless of its original source or its original format, can be exported to an XML file.</p>

<p>The export() parameters are the same as for other types of export() -- see the above for details. Additionally there are some export parameters specific to XML files which are the same as the import() parameters for XML files mentioned above. The col_names parameter is required, as is the record_tag parameter. Additionally one may optionally pass a header and/or a footer parameter which will be material that goes above and below the records in the file. If no header is passed, a default header consisting of</p>

<pre class="sh_perl">   &#60;?xml version=&#34;1.0&#34; ?&#62;</pre>

<p>will be created at the top of the file.</p>

<p>Given a datbase like this:</p>

<pre class="sh_perl">   location | name
   ---------+-----
   Portland | Joe
   Seattle  | Sue</pre>

<p>And an export() call like this:</p>

<pre class="sh_perl">  $dbh-&#62;func({
      data_type   =&#62; &#39;XML&#39;,
      data_target =&#62; &#39;test_db.new.xml&#39;,
      data_source =&#62; &#39;SELECT * FROM table1&#39;,
      record_tag  =&#62; &#39;staff person&#39;,
      col_names   =&#62; &#39;name,location&#39;,
  },&#39;export&#39;);</pre>

<p>Would produce a file called &#39;test_db.xml&#39; containing text like this:</p>

<pre class="sh_perl">  &#60;?xml version=&#34;1.0&#34; ?&#62;
  &#60;staff&#62;
  &#60;office&#62;
  &#60;person&#62;
    &#60;name&#62;Joe&#60;/name&#62;
    &#60;location&#62;Portland&#60;/location&#62;
  &#60;/person&#62;
  &#60;person&#62;
    &#60;name&#62;Sue&#60;/name&#62;
    &#60;location&#62;Seattle&#60;/location&#62;
  &#60;/person&#62;
  &#60;/office&#62;
  &#60;/staff&#62;</pre>

<p>The module does not currently support exporting tag attributes or &#34;folding out&#34; nested column information, but those are planned for future releases.</p>

<p>back</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="USER-DEFINED_DATA_STRUCTURES"
>USER-DEFINED DATA STRUCTURES</a></h2>

<p>DBD::RAM can be extended to handle almost any type of structured information with the USR data type. With this data type, you define a subroutine that parses your data and pass that to the import() command and the module will use that routine to create a database from your data. The routine can be as simple or as complex as you like. It must accept a string and return an array with the fields of the array in the same order as the columns in your database. Here is a simple example that works with data separated by double tildes. In reality, you could just do this with the bulit-in CSV type, but here is how you could recreate it with the USR type:</p>

<pre class="sh_perl"> $dbh-&#62;func({
      data_type   =&#62; &#39;USR&#39;,
      data_source =&#62; &#34;1~~2~~3\n4~~5~~6\n&#34;,
      read_sub    =&#62; sub { split /~~/,shift },
 },&#39;import&#39; );</pre>

<p>That would build a table with two rows of three fields each. The first row would contain the values 1,2,3 and the second row would contain the values 4,5,6.</p>

<p>Here is a more complex example that handles a simplified address book. It assumes that your data is a series of addresses separated by blank lines and that the address has the name on the first line, the street on the second line and the town, state, and zipcode on the third line. (Apologies to those in countries that don&#39;t have states or zipcodes in this format). Here is an example of the kind of data it would handle:</p>

<pre class="sh_perl">    Fred Bloggs
    123 Somewhere Lane
    Sometown OR 97215

    Joe Blow
    567 Anywhere Street
    OtherTown WA 98006</pre>

<p>Note that the end-of-line separator (eol) has been changed to be a blank line rather than a simple newline and that the parsing routine is more than a simple line by line parser, it splits the third line into three fields for town, state, and zip.</p>

<pre class="sh_perl">  $dbh-&#62;func({
    data_type   =&#62; &#39;USR&#39;,
    data_source =&#62; join(&#39;&#39;,&#60;DATA&#62;),
    col_names   =&#62; &#39;name,street,town,state,zip&#39;,
    eol         =&#62; &#39;^\s*\n&#39;,
    read_sub    =&#62; sub {
        my($name,$street,$stuff) = split &#34;\n&#34;, $_[0];
        my @ary   = split &#39; &#39;,$stuff;
        my $zip   = $ary[-1];
        my $state = $ary[-2];
        my $town  = $stuff;
        $town =~ s/^(.*)\s+$state\s+$zip$/$1/;
        return($name,$street,$town,$state,$zip);
      },
    },&#39;import&#39;);

  Given the data above, this routine would create a table like this:

  name        | street              | town      | state | zip
  ------------+---------------------+-----------+-------+------
  Fred Bloggs | 123 Somewhere Lane  | Sometown  | OR    | 97215
  Joe Blow    | 567 Anywhere Street | OtherTown | WA    | 98006</pre>

<p>These are just samples, the possiblities are fairly unlimited.</p>

<p>PLEASE NOTE: If you develop generally useful parser routines that others might also be able to use, send them to me and I can encorporate them into the DBD itself (with proper credit, of course).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBI_DATABASE_RECORDS"
>DBI DATABASE RECORDS</a></h2>

<p>You can import information from any other DBI accessible database with the data_type set to &#39;DBI&#39; in the import() method. First connect to the other database via DBI and get a database handle for it separate from the database handle for DBD::RAM. Then do a prepare and execute to get a statement handle for a SELECT statement into that database. Then pass the statement handle to the DBD::RAM import() method as the data_source. This will perform the fetch and insert the fetched fields and records into the DBD::RAM table. After the import() statement, you can then close the database connection to the other database if you are not going to be using it for anything else.</p>

<p>Here&#39;s an example using DBD::mysql --</p>

<pre class="sh_perl"> use DBI;
 my $dbh_ram   = DBI-&#62;connect(&#39;dbi:RAM:&#39;,&#39;&#39;,&#39;&#39;,{RaiseError=&#62;1});
 my $dbh_mysql = DBI-&#62;connect(&#39;dbi:mysql:test&#39;,&#39;&#39;,&#39;&#39;,{RaiseError=&#62;1});
 my $sth_mysql = $dbh_mysql-&#62;prepare(&#34;SELECT * FROM cars&#34;);
 $sth_mysql-&#62;execute;
 $dbh_ram-&#62;func({
     data_type   =&#62; &#39;DBI&#39;,
     data_source =&#62; $sth_mysql,
 },&#39;import&#39; );
 $dbh_mysql-&#62;disconnect;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MP3_MUSIC_FILES"
>MP3 MUSIC FILES</a></h2>

<p>Most mp3 (mpeg three) music files contain a header describing the song name, artist, and other information about the music. This shortcut will collect all of the header information in all mp3 files in a group of directories and turn it into a searchable database:</p>

<pre class="sh_perl"> $dbh-&#62;func(
     { data_type =&#62; &#39;MP3&#39;, dirs =&#62; $dirlist }, &#39;import&#39;
 );

 $dirlist should be a reference to an array of absolute paths to
 directories containing mp3 files.  Each file in those directories
 will become a record containing the fields:  file_name, song_name,
 artist, album, year, comment,genre. The fields will be filled
 in automatically from the ID3v1x header information in the mp3 file
 itself, assuming, of course, that the mp3 file contains a
 valid ID3v1x header.</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_MULTIPLE_TABLES"
>USING MULTIPLE TABLES <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>A single script can create as many tables as your RAM will support and you can have multiple statement handles open to the tables simultaneously. This allows you to simulate joins and multi-table operations by iterating over several statement handles at once. You can also mix and match databases of different formats, for example gathering user info from .ini and .config files in many different formats and putting them all into a single table.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TO_DO"
>TO DO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Lots of stuff. Allow users to specify a file where catalog information is stored so that one could record file types once and thereafter automatically open the files with the correct data type. A convert() function to go from one format to another. Support for a variety of other easily parsed formats such as Mail files, web logs, and for various DBM formats. Support for HTML files with the directory considered as a table, each HTML file considered as a record and the filename, &#60;TITLE&#62; tag, and &#60;BODY&#62; tags considered as fields. More robust SQL (coming when I update Statement.pm) including RLIKE (a regex-based LIKE), joins, alter table, typed fields?, authorization mechanisms? transactions? Allow remote exports (e.g. with LWP POST/PUT).</p>

<p>Let me know what else...</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Jeff Zucker &#60;jeff@vpservices.com&#62;</p>

<p>Copyright (c) 2000 Jeff Zucker. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself as specified in the Perl README file.</p>

<p>No warranty of any kind is implied, use at your own risk.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl"> DBI, <a href="/perldoc?SQL%3A%3AStatement" class="podlinkpod"
>SQL::Statement</a>, <a href="/perldoc?DBD%3A%3AFile" class="podlinkpod"
>DBD::File</a></pre>

</div>
<!-- This should probably be put in the <div class="footer"></div> -->
<script type="text/javascript">
    $(document).ready(function(){
        var startingStyle = $.cookie('css') ? $.cookie('css') : 'http://st.pimg.net/tucs/css/sh_none.min.css';
        $.fn.styleSwitch(startingStyle);
        $("#styleswitch").val(startingStyle);
        sh_highlightDocument();
        $("#styleswitch").bind(($.browser.msie ? "click" : "change"), function() {
            $.fn.styleSwitch($(this).val());
        });
    });
</script>
<div class="styleswitch">
    syntax highlighting:
    <select id="styleswitch">
        <option value="http://st.pimg.net/tucs/css/sh_none.min.css">no syntax highlighting</option>
        <option value="http://st.pimg.net/tucs/css/sh_acid.min.css">acid</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-dark.min.css">berries-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-light.min.css">berries-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_bipolar.min.css">bipolar</option>
        <option value="http://st.pimg.net/tucs/css/sh_blacknblue.min.css">blacknblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_bright.min.css">bright</option>
        <option value="http://st.pimg.net/tucs/css/sh_contrast.min.css">contrast</option>
        <option value="http://st.pimg.net/tucs/css/sh_cpan.min.css">cpan</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkblue.min.css">darkblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkness.min.css">darkness</option>
        <option value="http://st.pimg.net/tucs/css/sh_desert.min.css">desert</option>
        <option value="http://st.pimg.net/tucs/css/sh_dull.min.css">dull</option>
        <option value="http://st.pimg.net/tucs/css/sh_easter.min.css">easter</option>
        <option value="http://st.pimg.net/tucs/css/sh_emacs.min.css">emacs</option>
        <option value="http://st.pimg.net/tucs/css/sh_golden.min.css">golden</option>
        <option value="http://st.pimg.net/tucs/css/sh_greenlcd.min.css">greenlcd</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-anjuta.min.css">ide-anjuta</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-codewarrior.min.css">ide-codewarrior</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-devcpp.min.css">ide-devcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-eclipse.min.css">ide-eclipse</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-kdev.min.css">ide-kdev</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-msvcpp.min.css">ide-msvcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_kwrite.min.css">kwrite</option>
        <option value="http://st.pimg.net/tucs/css/sh_matlab.min.css">matlab</option>
        <option value="http://st.pimg.net/tucs/css/sh_navy.min.css">navy</option>
        <option value="http://st.pimg.net/tucs/css/sh_nedit.min.css">nedit</option>
        <option value="http://st.pimg.net/tucs/css/sh_neon.min.css">neon</option>
        <option value="http://st.pimg.net/tucs/css/sh_night.min.css">night</option>
        <option value="http://st.pimg.net/tucs/css/sh_pablo.min.css">pablo</option>
        <option value="http://st.pimg.net/tucs/css/sh_peachpuff.min.css">peachpuff</option>
        <option value="http://st.pimg.net/tucs/css/sh_print.min.css">print</option>
        <option value="http://st.pimg.net/tucs/css/sh_rand01.min.css">rand01</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-dark.min.css">solarized-dark</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-light.min.css">solarized-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_style.min.css">style</option>
        <option value="http://st.pimg.net/tucs/css/sh_the.min.css">the</option>
        <option value="http://st.pimg.net/tucs/css/sh_typical.min.css">typical</option>
        <option value="http://st.pimg.net/tucs/css/sh_vampire.min.css">vampire</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim-dark.min.css">vim-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim.min.css">vim</option>
        <option value="http://st.pimg.net/tucs/css/sh_whatis.min.css">whatis</option>
        <option value="http://st.pimg.net/tucs/css/sh_whitengrey.min.css">whitengrey</option>
        <option value="http://st.pimg.net/tucs/css/sh_zellner.min.css">zellner</option>
    </select>
</div>



<div class="footer"><div class="cpanstats">78255 Uploads, 24722 Distributions
105996 Modules, 9649 Uploaders
</div>
hosted by <a href="http://www.yellowbot.com">YellowBot</a><br/>
<a href="http://www.yellowbot.com"><img alt="do. tag. write. share." src="http://st.pimg.net/tucs/img/yellowbot_logo.gif"></a>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="http://ipv4.v6test.develooper.com/js/v1/v6test.js"></script>

<script type="text/javascript">
   // v6.target = '';
   if (!v6.target) { v6.only_once = true }
   v6.site = '7A0D89A6-2B82-11DF-B9DA-F61CBD13F020';
   v6.api_server = 'http://ipv4.v6test.develooper.com';
   try {
     v6.test();
   } catch(err) {}
</script>
<script type="text/javascript">
  $(document).ready(function(){
    $("a[href^=http:]").click(function(){
      var href = $(this).attr('href');
      var m = href.match('\/\/([^\/:]+)');
      _gaq.push(['_trackEvent','External',m[1],'Module']);
    });
    $("a[href^=/CPAN/]").click(function(){
      var href = $(this).attr('href');
      _gaq.push(['_trackEvent','Download',href,'Module']);
    });
  });
</script>
<!-- Fri Apr 27 11:23:05 2012 GMT (0.102897167205811) @cpansearch1 -->
 </body>
</html>
