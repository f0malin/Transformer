<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <link rel="stylesheet" href="http://st.pimg.net/tucs/style.css" type="text/css" />
<style>
.styleswitch {
  text-align: right;
}
</style>


<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.cookie.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_main.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_perl.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.styleswitch.js"></script>

<link rel="stylesheet" href="http://st.pimg.net/tucs/print.css" type="text/css" media="print" />
  <link rel="alternate" type="application/rss+xml" title="RSS 1.0" href="http://search.cpan.org/uploads.rdf" />
  <link rel="search" href="http://st.pimg.net/tucs/opensearch.xml" type="application/opensearchdescription+xml" title="SearchCPAN" />
  <title>POE::Session - search.cpan.org</title>
 <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3528438-1']);
    _gaq.push(["_setCustomVar",2,"Distribution","POE",3]);
    _gaq.push(["_setCustomVar",5,"Release","POE-1.352",3]);
    _gaq.push(["_setCustomVar",3,"Module","POE::Session",3]);
    _gaq.push(["_setCustomVar",1,"Author","RCAPUTO",3]);
    _gaq.push(['_trackPageview']);
  </script>
 </head>
 <body id="cpansearch">
<center><div class="logo"><a href="/"><img src="http://st.pimg.net/tucs/img/cpan_banner.png" alt="CPAN"></a></div></center>
<div class="menubar">
 <a href="/">Home</a>
&middot; <a href="/author/">Authors</a>
&middot; <a href="/recent">Recent</a>
&middot; <a href="http://log.perl.org/cpansearch/">News</a>
&middot; <a href="/mirror">Mirrors</a>
&middot; <a href="/faq.html">FAQ</a>
&middot; <a href="/feedback">Feedback</a>
</div>
<form method="get" action="/search" name="f" class="searchbox">
<input type="text" name="query" value="" size="35">
<br>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</form>


 <a name="_top"></a>
  <div class=path>
<div id=permalink class="noprint"><a href="/perldoc?POE::Session">permalink</a></div>
  <a href="/~rcaputo/">Rocco Caputo</a> &gt;
  <a href="/~rcaputo/POE-1.352/">POE-1.352</a> &gt;
  POE::Session
 </div>

<div class="noprint" style="float:right;align:left;width:19ex">
<a href="http://hexten.net/cpan-faces/"><img src="http://www.gravatar.com/avatar/3d4f61dae367905f646713ee2a0b65c5?r=g&s=80&d=http%3A%2F%2Fst.pimg.net%2Ftucs%2Fimg%2Fwho.png" width=80 height=80 
style="float:right"
/></a>
<br style="clear:both"/>
<p style="text-align:right">Download:<br/> <a href="/CPAN/authors/id/R/RC/RCAPUTO/POE-1.352.tar.gz">POE-1.352.tar.gz</a></p>
<p style="text-align:right"><a href="http://deps.cpantesters.org/?module=POE%3A%3ASession;perl=latest">Dependencies</a></p>
<p style="text-align:right"><a href="http://www.annocpan.org/~RCAPUTO/POE-1.352/lib/POE/Session.pm">Annotate this POD
</a></p>
     <p style="text-align:right"><a href="http://poe.perl.org/">Website</a></p>
<div class=box style='width:150px; float: right'>
<h1 class=t5>Related Modules</h1>
<div style="margin:2px">
<a href="/perldoc?POE%3A%3AKernel">POE::Kernel</a><br>
<a href="/perldoc?Win32%3A%3AProcess">Win32::Process</a><br>
<a href="/perldoc?Net%3A%3AAIM">Net::AIM</a><br>
<a href="/perldoc?LWP%3A%3AParallel">LWP::Parallel</a><br>
<a href="/perldoc?CGI%3A%3AApplication">CGI::Application</a><br>
<a href="/perldoc?Data%3A%3ADumper">Data::Dumper</a><br>
<a href="/perldoc?LWP%3A%3AUserAgent">LWP::UserAgent</a><br>
<a href="/perldoc?HTML%3A%3ATemplate">HTML::Template</a><br>
<a href="/perldoc?File%3A%3ASpec">File::Spec</a><br>
<a href="/perldoc?XML%3A%3ASimple">XML::Simple</a><br>
<small>
<a href="http://perlmonks.org/?node=cpan+module+search&pivot=1&module=POE%3A%3ASession">more...</a><br>
By <a href="http://perlmonks.org/">perlmonks.org</a></small>
</div>
</div>

<div style="float:right">
<div class=box style='width:150px'>
<h1 class=t5>CPAN RT</h1>
<div style="margin:2px">
<table style="margin-left:auto;margin-right:auto">
<tr><td>New&nbsp;</td><td style="text-align:right"> 2</td></tr>
<tr><td>Open&nbsp;</td><td style="text-align:right"> 3</td></tr>
<tr><td>Stalled&nbsp;</td><td style="text-align:right"> 2</td></tr>
</table>
<a href="https://rt.cpan.org/Public/Dist/Display.html?Name=POE">View/Report Bugs</a><br/>
</div>
</div>

</div>
</div>
  Module Version:  1.352 &nbsp;
<span class="noprint">
  <a href="/src/RCAPUTO/POE-1.352/lib/POE/Session.pm">Source</a> &nbsp;
</span>
<a name="___top"></a>
<div class=pod>
<div class=toc>
<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#A_note_on_nomenclature'>A note on nomenclature</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#USING_POE::Session'>USING POE::Session</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#POE::Session&#39;s_Calling_Convention'>POE::Session&#39;s Calling Convention</a>
    <li class='indexItem indexItem2'><a href='#POE::Session_Parameters'>POE::Session Parameters</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#$_[OBJECT]'>$_[OBJECT]</a>
      <li class='indexItem indexItem3'><a href='#$_[SESSION]'>$_[SESSION]</a>
      <li class='indexItem indexItem3'><a href='#$_[KERNEL]'>$_[KERNEL]</a>
      <li class='indexItem indexItem3'><a href='#$_[HEAP]'>$_[HEAP]</a>
      <li class='indexItem indexItem3'><a href='#$_[STATE]'>$_[STATE]</a>
      <li class='indexItem indexItem3'><a href='#$_[SENDER]'>$_[SENDER]</a>
      <li class='indexItem indexItem3'><a href='#$_[CALLER_FILE],_$_[CALLER_LINE]_and_$_[CALLER_STATE]'>$_[CALLER_FILE], $_[CALLER_LINE] and $_[CALLER_STATE]</a>
      <li class='indexItem indexItem3'><a href='#@_[ARG0..ARG9]_or_@_[ARG0..$#_]'>@_[ARG0..ARG9] or @_[ARG0..$#_]</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Using_POE::Session_With_Objects'>Using POE::Session With Objects</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PUBLIC_METHODS'>PUBLIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#create_LOTS_OF_STUFF'>create LOTS_OF_STUFF</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#args_=&#62;_ARRAYREF'>args =&#62; ARRAYREF</a>
      <li class='indexItem indexItem3'><a href='#heap_=&#62;_ANYTHING'>heap =&#62; ANYTHING</a>
      <li class='indexItem indexItem3'><a href='#inline_states_=&#62;_HASHREF'>inline_states =&#62; HASHREF</a>
      <li class='indexItem indexItem3'><a href='#object_states_=&#62;_ARRAYREF'>object_states =&#62; ARRAYREF</a>
      <li class='indexItem indexItem3'><a href='#options_=&#62;_HASHREF'>options =&#62; HASHREF</a>
      <li class='indexItem indexItem3'><a href='#package_states_=&#62;_ARRAYREF'>package_states =&#62; ARRAYREF</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#ID'>ID</a>
    <li class='indexItem indexItem2'><a href='#option_OPTION_NAME_[,_OPTION_VALUE_[,_OPTION_NAME,_OPTION_VALUE]..._]'>option OPTION_NAME [, OPTION_VALUE [, OPTION_NAME, OPTION_VALUE]... ]</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#The_&#34;debug&#34;_option.'>The &#34;debug&#34; option.</a>
      <li class='indexItem indexItem3'><a href='#The_&#34;default&#34;_option.'>The &#34;default&#34; option.</a>
      <li class='indexItem indexItem3'><a href='#The_&#34;trace&#34;_option.'>The &#34;trace&#34; option.</a>
      <li class='indexItem indexItem3'><a href='#User-defined_options.'>User-defined options.</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#postback_EVENT_NAME,_EVENT_PARAMETERS'>postback EVENT_NAME, EVENT_PARAMETERS</a>
    <li class='indexItem indexItem2'><a href='#callback_EVENT_NAME,_EVENT_PARAMETERS'>callback EVENT_NAME, EVENT_PARAMETERS</a>
    <li class='indexItem indexItem2'><a href='#get_heap'>get_heap</a>
    <li class='indexItem indexItem2'><a href='#instantiate_CREATE_PARAMETERS'>instantiate CREATE_PARAMETERS</a>
    <li class='indexItem indexItem2'><a href='#try_alloc_START_ARGS'>try_alloc START_ARGS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#POE::Session&#39;s_EVENTS'>POE::Session&#39;s EVENTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#_default'>_default</a>
    <li class='indexItem indexItem2'><a href='#POE::Session&#39;s_Debugging_Features'>POE::Session&#39;s Debugging Features</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#ASSERT_STATES'>ASSERT_STATES</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Beware_circular_references'>Beware circular references</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHORS_&#38;_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>POE::Session - a generic event-driven task</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl">  use POE; # auto-includes POE::Kernel and POE::Session

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub { $_[KERNEL]-&#62;yield(&#34;next&#34;) },
      next   =&#62; sub {
        print &#34;tick...\n&#34;;
        $_[KERNEL]-&#62;delay(next =&#62; 1);
      },
    },
  );

  POE::Kernel-&#62;run();
  exit;</pre>

<p>POE::Session can also dispatch to object and class methods through <a href="#object_states" class="podlinkpod"
>&#34;object_states&#34;</a> and <a href="#package_states" class="podlinkpod"
>&#34;package_states&#34;</a> callbacks.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>POE::Session and its subclasses translate events from POE::Kernel&#39;s generic dispatcher into the particular calling conventions suitable for application code. In design pattern parlance, POE::Session classes are adapters between <a href="/~rcaputo/POE-1.352/lib/POE/Kernel.pm" class="podlinkpod"
>POE::Kernel</a> and application code.</p>

<p>The <a href="/~rcaputo/POE-1.352/lib/POE/Kernel.pm#Sessions" class="podlinkpod"
>sessions</a> that POE::Kernel manages are more like generic task structures. Unfortunately these two disparate concepts have virtually identical names.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="A_note_on_nomenclature"
>A note on nomenclature</a></h2>

<p>This documentation will refer to event handlers as &#34;states&#34; in certain unavoidable situations. Sessions were originally meant to be event-driven state machines, but their purposes evolved over time. Some of the legacy vocabulary lives on in the API for backward compatibility, however.</p>

<p>Confusingly, <a href="/~rcaputo/POE-1.352/lib/POE/NFA.pm" class="podlinkpod"
>POE::NFA</a> is a class for implementing actual event-driven state machines. Its documentation uses &#34;state&#34; in the proper sense.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_POE::Session"
>USING POE::Session <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>POE::Session has two main purposes. First, it maps event names to the code that will handle them. Second, it maps a consistent event dispatch interface to those handlers.</p>

<p>Consider the <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> for example. A POE::Session instance is created with two <code>inline_states</code>, each mapping an event name (&#34;_start&#34; and &#34;next&#34;) to an inline subroutine. POE::Session ensures that <a href="#$_[KERNEL]" class="podlinkpod"
>&#34;$_[KERNEL]&#34;</a> and so on are meaningful within an event handler.</p>

<p>Event handlers may also be object or class methods, using <a href="#object_states" class="podlinkpod"
>&#34;object_states&#34;</a> and <a href="#package_states" class="podlinkpod"
>&#34;package_states&#34;</a> respectively. The create() syntax is different than for <code>inline_states</code>, but the calling convention is nearly identical.</p>

<p>Notice that the created POE::Session object has not been saved to a variable. The new POE::Session object gives itself to POE::Kernel, which then manages it and all the resources it uses.</p>

<p>It&#39;s possible to keep references to new POE::Session objects, but it&#39;s not usually necessary. If an application is not careful about cleaning up these references you will create circular references, which will leak memory when POE::Kernel would normally destroy the POE::Session object. It is recommended that you keep the session&#39;s <a href="/perldoc?ID" class="podlinkpod"
>ID</a> instead.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="POE::Session&#39;s_Calling_Convention"
>POE::Session&#39;s Calling Convention</a></h2>

<p>The biggest syntactical hurdle most people have with POE is POE::Session&#39;s unconventional calling convention. For example:</p>

<pre class="sh_perl">  sub handle_event {
    my ($kernel, $heap, $parameter) = @_[KERNEL, HEAP, ARG0];
    ...;
  }</pre>

<p>Or the use of <code>$_[KERNEL]</code>, <code>$_[HEAP]</code> and <code>$_[ARG0]</code> inline, as is done in most examples.</p>

<p>What&#39;s going on here is rather basic. Perl passes parameters into subroutines or methods using the @_ array. <code>KERNEL</code>, <code>HEAP</code>, <code>ARG0</code> and others are constants exported by POE::Session (which is included for free when a program uses POE).</p>

<p>So <code>$_[KERNEL]</code> is an event handler&#39;s KERNELth parameter. <code>@_[HEAP, ARG0]</code> is a slice of @_ containing the HEAPth and ARG0th parameters.</p>

<p>While this looks odd, it&#39;s perfectly plain and legal Perl syntax. POE uses it for a few reasons:</p>

<ol>
<li>In the common case, passing parameters in <code>@_</code> is faster than passing hash or array references and then dereferencing them in the handler.</li>

<li>Typos in hash-based parameter lists are either subtle run-time errors or requires constant run-time checking. Constants are either known at compile time, or are clear compile-time errors.</li>

<li>Referencing <code>@_</code> offsets by constants allows parameters to move in the future without breaking application code.</li>

<li>Most event handlers don&#39;t need all of <code>@_</code>. Slices allow handlers to use only the parameters they&#39;re interested in.</li>
</ol>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="POE::Session_Parameters"
>POE::Session Parameters</a></h2>

<p>Event handlers receive most of their run-time context in up to nine callback parameters. POE::Kernel provides many of them.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$_[OBJECT]"
>$_[OBJECT]</a></h3>

<p><code>$_[OBJECT]</code> is $self for event handlers that are an object method. It is the class (package) name for class-based event handlers. It is undef for plain coderef callbacks, which have no special <code>$self</code>-ish value.</p>

<p><code>OBJECT</code> is always zero, since <code>$_[0]</code> is always <code>$self</code> or <code>$class</code> in object and class methods. Coderef handlers are called with an <code>undef</code> placeholder in <code>$_[0]</code> so that the other offsets remain valid.</p>

<p>It&#39;s often useful for method-based event handlers to call other methods in the same object. <code>$_[OBJECT]</code> helps this happen.</p>

<pre class="sh_perl">  sub ui_update_everything {
    my $self = $_[OBJECT];
    $self-&#62;update_menu();
    $self-&#62;update_main_window();
    $self-&#62;update_status_line();
  }</pre>

<p>You may also use method inheritance. Here we invoke $self-&#62;a_method(@_). Since Perl&#39;s <code>&#60;-</code>&#62;&#62; operator unshifts $self onto the beginning of @_, we must first shift a copy off to maintain POE&#39;s parameter offsets:</p>

<pre class="sh_perl">  sub a_method {
    my $self = shift;
    $self-&#62;SUPER::a_method( @_ );
    # ... more work ...
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$_[SESSION]"
>$_[SESSION]</a></h3>

<p><code>$_[SESSION]</code> is a reference to the current session object. This lets event handlers access their session&#39;s methods. Programs may also compare <code>$_[SESSION]</code> to <code>$_[SENDER]</code> to verify that intra-session events did not come from other sessions.</p>

<p><code>$_[SESSION]</code> may also be used as the destination for intra-session <a href="/~rcaputo/POE-1.352/lib/POE/Kernel.pm#post" class="podlinkpod"
>post()</a> and <a href="/~rcaputo/POE-1.352/lib/POE/Kernel.pm#call" class="podlinkpod"
>call()</a>. <a href="/~rcaputo/POE-1.352/lib/POE/Kernel.pm#yield" class="podlinkpod"
>yield()</a> is marginally more convenient and efficient than <code>post($_[SESSION], ...)</code> however.</p>

<p>It is bad form to access another session directly. The recommended approach is to manipulate a session through an event handler.</p>

<pre class="sh_perl">  sub enable_trace {
    my $previous_trace = $_[SESSION]-&#62;option( trace =&#62; 1 );
    my $id = $_[SESSION]-&#62;ID;
    if ($previous_trace) {
      print &#34;Session $id: dispatch trace is still on.\n&#34;;
    }
    else {
      print &#34;Session $id: dispatch trace has been enabled.\n&#34;;
    }
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$_[KERNEL]"
>$_[KERNEL]</a></h3>

<p>The KERNELth parameter is always a reference to the application&#39;s singleton <a href="/~rcaputo/POE-1.352/lib/POE/Kernel.pm" class="podlinkpod"
>POE::Kernel</a> instance. It is most often used to call POE::Kernel methods from event handlers.</p>

<pre class="sh_perl">  # Set a 10-second timer.
  $_[KERNEL]-&#62;delay( time_is_up =&#62; 10 );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$_[HEAP]"
>$_[HEAP]</a></h3>

<p>Every POE::Session object contains its own variable namespace known as the session&#39;s <code>HEAP</code>. It is modeled and named after process memory heaps (not priority heaps). Heaps are by default anonymous hash references, but they may be initialized in <a href="#create" class="podlinkpod"
>create()</a> to be almost anything. POE::Session itself never uses <code>$_[HEAP]</code>, although some POE components do.</p>

<p>Heaps do not overlap between sessions, although create()&#39;s &#34;heap&#34; parameter can be used to make this happen.</p>

<p>These two handlers time the lifespan of a session:</p>

<pre class="sh_perl">  sub _start_handler {
    $_[HEAP]{ts_start} = time();
  }

  sub _stop_handler {
    my $time_elapsed = time() - $_[HEAP]{ts_start};
    print &#34;Session &#34;, $_[SESSION]-&#62;ID, &#34; elapsed seconds: $elapsed\n&#34;;
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$_[STATE]"
>$_[STATE]</a></h3>

<p>The STATEth handler parameter contains the name of the event being dispatched in the current callback. This can be important since the event and handler names may significantly differ. Also, a single handler may be assigned to more than one event.</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    inline_states =&#62; {
      one =&#62; \&#38;some_handler,
      two =&#62; \&#38;some_handler,
      six =&#62; \&#38;some_handler,
      ten =&#62; \&#38;some_handler,
      _start =&#62; sub {
        $_[KERNEL]-&#62;yield($_) for qw(one two six ten);
      }
    }
  );

  sub some_handler {
    print(
      &#34;Session &#34;, $_[SESSION]-&#62;ID,
      &#34;: some_handler() handled event $_[STATE]\n&#34;
    );
  }</pre>

<p>It should be noted however that having event names and handlers names match will make your code easier to navigate.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$_[SENDER]"
>$_[SENDER]</a></h3>

<p>Events must come from somewhere. <code>$_[SENDER]</code> contains the currently dispatched event&#39;s source.</p>

<p><code>$_[SENDER]</code> is commonly used as a return address for responses. It may also be compared against <code>$_[KERNEL]</code> to verify that timers and other POE::Kernel-generated events were not spoofed.</p>

<p>This <code>echo_handler()</code> reponds to the sender with an &#34;echo&#34; event that contains all the parameters it received. It avoids a feedback loop by ensuring the sender session and event (STATE) are not identical to the current ones.</p>

<pre class="sh_perl">  sub echo_handler {
    return if $_[SENDER] == $_[SESSION] and $_[STATE] eq &#34;echo&#34;;
    $_[KERNEL]-&#62;post( $_[SENDER], &#34;echo&#34;, @_[ARG0..$#_] );
  }</pre>

<p></p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$_[CALLER_FILE],_$_[CALLER_LINE]_and_$_[CALLER_STATE]"
>$_[CALLER_FILE], $_[CALLER_LINE] and $_[CALLER_STATE]</a></h3>

<p>These parameters are a form of caller(), but they describe where the currently dispatched event originated. CALLER_FILE and CALLER_LINE are fairly plain. CALLER_STATE contains the name of the event that was being handled when the event was created, or when the event watcher that ultimately created the event was registered.</p>

<p></p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="@_[ARG0..ARG9]_or_@_[ARG0..$#_]"
>@_[ARG0..ARG9] or @_[ARG0..$#_]</a></h3>

<p>Parameters $_[ARG0] through the end of @_ contain parameters provided by application code, event watchers, or higher-level libraries. These parameters are guaranteed to be at the end of @_ so that @_[ARG0..$#_] will always catch them all.</p>

<p>$#_ is the index of the last value in @_. Blame Perl if it looks odd. It&#39;s merely the $#array syntax where the array name is an underscore.</p>

<p>Consider</p>

<pre class="sh_perl">  $_[KERNEL]-&#62;yield( ev_whatever =&#62; qw( zero one two three ) );</pre>

<p>The handler for ev_whatever will be called with &#34;zero&#34; in $_[ARG0], &#34;one&#34; in $_[ARG1], and so on. @_[ARG0..$#_] will contain all four words.</p>

<pre class="sh_perl">  sub ev_whatever {
    $_[OBJECT]-&#62;whatever( @_[ARG0..$#_] );
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_POE::Session_With_Objects"
>Using POE::Session With Objects</a></h2>

<p>One session may handle events across many objects. Or looking at it the other way, multiple objects can be combined into one session. And what the heck---go ahead and mix in some inline code as well.</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    object_states =&#62; [
      $object_1 =&#62; { event_1a =&#62; &#34;method_1a&#34; },
      $object_2 =&#62; { event_2a =&#62; &#34;method_2a&#34; },
    ],
    inline_states =&#62; {
      event_3 =&#62; \&#38;piece_of_code,
    },
  );</pre>

<p>However only one handler may be assigned to a given event name. Duplicates will overwrite earlier ones.</p>

<p>event_1a is handled by calling <code>$object_1-&#62;method_1a(...)</code>. <code>$_[OBJECT]</code> is <code>$object_1</code> in this case. <code>$_[HEAP]</code> belongs to the session, which means anything stored there will be available to any other event handler regardless of the object.</p>

<p>event_2a is handled by calling <code>$object_2-&#62;method_2a(...)</code>. In this case <code>$_[OBJECT]</code> is $object_2. <code>$_[HEAP]</code> is the same anonymous hashref that was passed to the event_1a handler, though. The methods are resolved when the event is handled (late-binding).</p>

<p>event_3 is handled by calling <code>piece_of_code(...)</code>. <code>$_[OBJECT]</code> is <code>undef</code> here because there&#39;s no object. And once again, <code>$_[HEAP]</code> is the same shared hashref that the handlers for event_1a and event_2a saw.</p>

<p>Interestingly, there&#39;s no technical reason that a single object can&#39;t handle events from more than one session:</p>

<pre class="sh_perl">  for (1..2) {
    POE::Session-&#62;create(
      object_states =&#62; [
        $object_4 =&#62; { event_4 =&#62; &#34;method_4&#34; },
      ]
    );
  }</pre>

<p>Now <code>$object_4-&#62;method_4(...)</code> may be called to handle events from one of two sessions. In both cases, <code>$_[OBJECT]</code> will be <code>$object_4</code>, but <code>$_[HEAP]</code> will hold data for a particular session.</p>

<p>The same goes for inline states. One subroutine may handle events from many sessions. <code>$_[SESSION]</code> and <code>$_[HEAP]</code> can be used within the handler to easily access the context of the session in which the event is being handled.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_METHODS"
>PUBLIC METHODS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>POE::Session has just a few public methods.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create_LOTS_OF_STUFF"
>create LOTS_OF_STUFF</a></h2>

<p><code>create()</code> starts a new session running. It returns a new POE::Session object upon success, but most applications won&#39;t need to save it.</p>

<p><code>create()</code> invokes the newly started session&#39;s _start event handler before returning.</p>

<p><code>create()</code> also passes the new POE::Session object to <a href="/~rcaputo/POE-1.352/lib/POE/Kernel.pm" class="podlinkpod"
>POE::Kernel</a>. POE&#39;s kernel holds onto the object in order to dispatch events to it. POE::Kernel will release the object when it detects the object has become moribund. This should cause Perl to destroy the object if application code has not saved a copy of it.</p>

<p><code>create()</code> accepts several named parameters, most of which are optional. Note however that the parameters are not part of a hashref.</p>

<p></p>

<p></p>

<p></p>

<p></p>

<p></p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="args_=&#62;_ARRAYREF"
>args =&#62; ARRAYREF</a></h3>

<p>The <code>args</code> parameter accepts a reference to a list of parameters that will be passed to the session&#39;s _start event handler in <code>@_</code> positions <code>ARG0</code> through <code>$#_</code> (the end of <code>@_</code>).</p>

<p>This example would print &#34;arg0 arg1 etc.&#34;:</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        print &#34;Session started with arguments: @_[ARG0..$#_]\n&#34;;
      },
    },
    args =&#62; [ &#39;arg0&#39;, &#39;arg1&#39;, &#39;etc.&#39; ],
  );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="heap_=&#62;_ANYTHING"
>heap =&#62; ANYTHING</a></h3>

<p>The <code>heap</code> parameter allows a session&#39;s heap to be initialized differently at instantiation time. Heaps are usually anonymous hashrefs, but <code>heap</code> may set them to be array references or even objects.</p>

<p>This example prints &#34;tree&#34;:</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        print &#34;Slot 0 = $_[HEAP][0]\n&#34;;
      },
    },
    heap =&#62; [ &#39;tree&#39;, &#39;bear&#39; ],
  );</pre>

<p>Be careful when initializing the heap to be something that doesn&#39;t behave like a hashref. Some libraries assume hashref heap semantics, and they will fail if the heap doesn&#39;t work that way.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="inline_states_=&#62;_HASHREF"
>inline_states =&#62; HASHREF</a></h3>

<p><code>inline_states</code> maps events names to the subroutines that will handle them. Its value is a hashref that maps event names to the coderefs of their corresponding handlers:</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        print &#34;arg0=$_[ARG0], arg1=$_[ARG1], etc.=$_[ARG2]\n&#34;;
      },
      _stop  =&#62; \&#38;stop_handler,
    },
    args =&#62; [qw( arg0 arg1 etc. )],
  );</pre>

<p>The term &#34;inline&#34; comes from the fact that coderefs can be inlined anonymous subroutines.</p>

<p>Be very careful with closures, however. <a href="#Beware_circular_references" class="podlinkpod"
>&#34;Beware circular references&#34;</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="object_states_=&#62;_ARRAYREF"
>object_states =&#62; ARRAYREF</a></h3>

<p><code>object_states</code> associates one or more objects to a session and maps event names to the object methods that will handle them. It&#39;s value is an <code>ARRAYREF</code>; <code>HASHREFs</code> would stringify the objects, ruining them for method invocation.</p>

<p>Here _start is handled by <code>$object-&#62;_session_start()</code> and _stop triggers <code>$object-&#62;_session_stop()</code>:</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    object_states =&#62; [
      $object =&#62; {
        _start =&#62; &#39;_session_start&#39;,
        _stop  =&#62; &#39;_session_stop&#39;,
      }
    ]
  );</pre>

<p>POE::Session also supports a short form where the event and method names are identical. Here _start invokes $object-&#62;_start(), and _stop triggers $object-&#62;_stop():</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    object_states =&#62; [
      $object =&#62; [ &#39;_start&#39;, &#39;_stop&#39; ],
    ]
  );</pre>

<p>Methods are verified when the session is created, but also resolved when the handler is called (late binding). Most of the time, a method won&#39;t change. But in some circumstance, such as dynamic inheritance, a method could resolve to a different subroutine.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="options_=&#62;_HASHREF"
>options =&#62; HASHREF</a></h3>

<p>POE::Session sessions support a small number of options, which may be initially set with the <code>option</code> constructor parameter and changed at run time with the <code>option()|/option</code> mehtod.</p>

<p><code>option</code> takes a hashref with option =&#62; value pairs:</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    ... set up handlers ...,
    options =&#62; { trace =&#62; 1, debug =&#62; 1 },
  );</pre>

<p>This is equivalent to the previous example:</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    ... set up handlers ...,
  )-&#62;option( trace =&#62; 1, debug =&#62; 1 );</pre>

<p>The supported options and values are documented with the <code>option()|/option</code> method.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="package_states_=&#62;_ARRAYREF"
>package_states =&#62; ARRAYREF</a></h3>

<p><code>package_states</code> associates one or more classes to a session and maps event names to the class methods that will handle them. Its function is analogous to <code>object_states</code>, but package names are specified rather than objects.</p>

<p>In fact, the following documentation is a copy of the <code>object_states</code> description with some word substitutions.</p>

<p>The value for <code>package_states</code> is an <b>ARRAYREF</b> to be consistent with <code>object_states</code>, even though class names (also known as package names) are already strings, so it&#39;s not necessary to avoid stringifying them.</p>

<p>Here _start is handled by <code>$class_name-&#62;_session_start()</code> and _stop triggers <code>$class_name-&#62;_session_stop()</code>:</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    package_states =&#62; [
      $class_name =&#62; {
        _start =&#62; &#39;_session_start&#39;,
        _stop  =&#62; &#39;_session_stop&#39;,
      }
    ]
  );</pre>

<p>POE::Session also supports a short form where the event and method names are identical. Here _start invokes <code>$class_name-&#62;_start()</code>, and _stop triggers <code>$class_name-&#62;_stop()</code>:</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    package_states =&#62; [
      $class_name =&#62; [ &#39;_start&#39;, &#39;_stop&#39; ],
    ]
  );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ID"
>ID</a></h2>

<p><code>ID()</code> returns the session instance&#39;s unique identifier. This is an integer that starts at 1 and counts up forever, or until the number wraps around.</p>

<p>It&#39;s theoretically possible that a session ID will not be unique, but this requires at least 4.29 billion sessions to be created within a program&#39;s lifespan. POE guarantees that no two sessions will have the same ID at the same time, however; your computer doesn&#39;t have enough memory to store 4.29 billion session objects.</p>

<p>A session&#39;s ID is unique within a running process, but multiple processes are likely to have the same session IDs. If a global ID is required, it will need to include both <code>$_[KERNEL]-&#62;ID</code> and <code>$_[SESSION]-&#62;ID</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="option_OPTION_NAME_[,_OPTION_VALUE_[,_OPTION_NAME,_OPTION_VALUE]..._]"
>option OPTION_NAME [, OPTION_VALUE [, OPTION_NAME, OPTION_VALUE]... ]</a></h2>

<p><code>option()</code> sets and/or retrieves the values of various session options. The options in question are implemented by POE::Session and do not have any special meaning anywhere else.</p>

<p>It may be called with a single OPTION_NAME to retrieve the value of that option.</p>

<pre class="sh_perl">  my $trace_value = $_[SESSION]-&#62;option(&#39;trace&#39;);</pre>

<p><code>option()</code> sets an option&#39;s value when called with a single OPTION_NAME, OPTION_VALUE pair. In this case, <code>option()</code> returns the option&#39;s previous value.</p>

<pre class="sh_perl">  my $previous_trace = $_[SESSION]-&#62;option(trace =&#62; 1);</pre>

<p><code>option()</code> may also be used to set the values of multiple options at once. In this case, <code>option()</code> returns all the specified options&#39; previous values in an anonymous hashref:</p>

<pre class="sh_perl">  my $previous_values = $_[SESSION]-&#62;option(
    trace =&#62; 1,
    debug =&#62; 1,
  );

  print &#34;Previous option values:\n&#34;;
  while (my ($option, $old_value) = each %$previous_values) {
    print &#34;  $option = $old_value\n&#34;;
  }</pre>

<p>POE::Session currently supports three options:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_&#34;debug&#34;_option."
>The &#34;debug&#34; option.</a></h3>

<p>The &#34;debug&#34; option is intended to enable additional warnings when strange things are afoot within POE::Session. At this time, there is only one additional warning:</p>

<ul>
<li>Redefining an event handler does not usually cause a warning, but it will when the &#34;debug&#34; option is set.</li>
</ul>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_&#34;default&#34;_option."
>The &#34;default&#34; option.</a></h3>

<p>Enabling the &#34;default&#34; option causes unknown events to become warnings, if there is no _default handler to catch them.</p>

<p>The class-level <code>POE::Session::ASSERT_STATES</code> flag is implemented by enabling the &#34;default&#34; option on all new sessions.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_&#34;trace&#34;_option."
>The &#34;trace&#34; option.</a></h3>

<p>Turn on the &#34;trace&#34; option to dump a log of all the events dispatched to a particular session. This is a session-specific trace option that allows individual sessions to be debugged.</p>

<p>Session-level tracing also indicates when events are redirected to _default. This can be used to discover event naming errors.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="User-defined_options."
>User-defined options.</a></h3>

<p><code>option()</code> does not verify whether OPTION_NAMEs are known, so <code>option()</code> may be used to store and retrieve user-defined information.</p>

<p>Choose option names with caution. There is no established convention to avoid namespace collisions between user-defined options and future internal options.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="postback_EVENT_NAME,_EVENT_PARAMETERS"
>postback EVENT_NAME, EVENT_PARAMETERS</a></h2>

<p><code>postback()</code> manufactures callbacks that post POE events. It returns an anonymous code reference that will post EVENT_NAME to the target session, with optional EVENT_PARAMETERS in an array reference in ARG0. Parameters passed to the callback will be sent in an array reference in ARG1.</p>

<p>In other words, ARG0 allows the postback&#39;s creator to pass context through the postback. ARG1 allows the caller to return information.</p>

<p>This example creates a coderef that when called posts &#34;ok_button&#34; to <code>$some_session</code> with ARG0 containing <code>[ 8, 6, 7 ]</code>.</p>

<pre class="sh_perl">  my $postback = $some_session-&#62;postback( &#34;ok_button&#34;, 8, 6, 7 );</pre>

<p>Here&#39;s an example event handler for &#34;ok_button&#34;.</p>

<pre class="sh_perl">  sub handle_ok_button {
    my ($creation_args, $called_args) = @_[ARG0, ARG1];
    print &#34;Postback created with (@$creation_args).\n&#34;;
    print &#34;Postback called with (@$called_args).\n&#34;;
  }</pre>

<p>Calling $postback-&#62;(5, 3, 0, 9) would perform the equivalent of...</p>

<pre class="sh_perl">  $poe_kernel-&#62;post(
    $some_session, &#34;ok_button&#34;,
    [ 8, 6, 7 ],
    [ 5, 3, 0, 9 ]
  );</pre>

<p>This would be displayed when &#34;ok_button&#34; was dispatched to handle_ok_button():</p>

<pre class="sh_perl">  Postback created with (8 6 7).
  Postback called with (5 3 0 9).</pre>

<p>Postbacks hold references to their target sessions. Therefore sessions with outstanding postbacks will remain active. Under every event loop except Tk, postbacks are blessed so that DESTROY may be called when their users are done. This triggers a decrement on their reference counts, allowing sessions to stop.</p>

<p>Postbacks have one method, weaken(), which may be used to reduce their reference counts upon demand. weaken() returns the postback, so you can do:</p>

<pre class="sh_perl">  my $postback = $session-&#62;postback(&#34;foo&#34;)-&#62;weaken();</pre>

<p>Postbacks were created as a thin adapter between callback libraries and POE. The problem at hand was how to turn callbacks from the Tk graphical toolkit&#39;s widgets into POE events without subclassing several Tk classes. The solution was to provide Tk with plain old callbacks that posted POE events.</p>

<p>Since <code>postback()</code> and <code>callback()</code> are Session methods, they may be called on <code>$_[SESSION]</code> or <code>$_[SENDER]</code>, depending on particular needs. There are usually better ways to interact between sessions than abusing postbacks, however.</p>

<p>Here&#39;s a brief example of attaching a <a href="/perldoc?Gtk2" class="podlinkpod"
>Gtk2</a> button to a POE event handler:</p>

<pre class="sh_perl">  my $btn = Gtk2::Button-&#62;new(&#34;Clear&#34;);
  $btn-&#62;signal_connect( &#34;clicked&#34;, $_[SESSION]-&#62;postback(&#34;ev_clear&#34;) );</pre>

<p>Points to remember: The session will remain alive as long as $btn exists and holds a copy of $_[SESSION]&#39;s postback. Any parameters passed by the Gtk2 button will be in ARG1.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="callback_EVENT_NAME,_EVENT_PARAMETERS"
>callback EVENT_NAME, EVENT_PARAMETERS</a></h2>

<p>callback() manufactures callbacks that use <code>$poe_kernel-&#62;call()</code> to deliver POE events rather than <code>$poe_kernel-&#62;post()</code>. It is identical to <code>postback()</code> in every other respect.</p>

<p>callback() was created to avoid race conditions that arise when external libraries assume callbacks will execute synchronously. <a href="/perldoc?File%3A%3AFind" class="podlinkpod"
>File::Find</a> is an obvious (but not necessarily appropriate) example. It provides a lot of information in local variables that stop being valid after the callback. The information would be unavailable by the time a post()ed event was dispatched.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_heap"
>get_heap</a></h2>

<p><code>get_heap()</code> returns a reference to a session&#39;s heap. This is the same value as <code>$_[HEAP]</code> for the target session. <code>get_heap()</code> is intended to be used with <code>$poe_kernel</code> and POE::Kernel&#39;s <code>get_active_session()</code> so that libraries do not need these three common values explicitly passed to them.</p>

<p>That is, it prevents the need for:</p>

<pre class="sh_perl">  sub some_helper_function {
    my ($kernel, $session, $heap, @specific_parameters) = @_;
    ...;
  }</pre>

<p>Rather, helper functions may use:</p>

<pre class="sh_perl">  use POE::Kernel; # exports $poe_kernel
  sub some_helper_function {
    my (@specific_parameters) = @_;
    my $session = $poe_kernel-&#62;get_active_session();
    my $heap = $session-&#62;get_heap();
  }</pre>

<p>This isn&#39;t very convenient for people writing libraries, but it makes the libraries much more convenient to use.</p>

<p>Using <code>get_heap()</code> to break another session&#39;s encapsulation is strongly discouraged.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="instantiate_CREATE_PARAMETERS"
>instantiate CREATE_PARAMETERS</a></h2>

<p><code>instantiate()</code> creates and returns an empty POE::Session object. It is called with the CREATE_PARAMETERS in a hash reference just before <code>create()</code> processes them. Modifications to the CREATE_PARAMETERS will affect how <code>create()</code> initializes the new session.</p>

<p>Subclasses may override <code>instantiate()</code> to alter the underlying session&#39;s structure. They may extend <code>instantiate()</code> to add new parameters to <code>create()</code>.</p>

<p>Any parameters not recognized by <code>create()</code> must be removed from the CREATE_PARAMETERS before <code>instantiate()</code> returns. <code>create()</code> will <a href="/perldoc?Carp" class="podlinkpod"
>croak</a> if it discovers unknown parameters.</p>

<p>Be sure to return <code>$self</code> from instantiate.</p>

<pre class="sh_perl">  sub instantiate {
    my ($class, $create_params) = @_;

    # Have the base class instantiate the new session.
    my $self = $class-&#62;SUPER::instantiate($create_parameters);

    # Extend the parameters recognized by create().
    my $new_option = delete $create_parameters-&#62;{new_option};
    if (defined $new_option) {
      # ... customize $self here ...
    }

    return $self;
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="try_alloc_START_ARGS"
>try_alloc START_ARGS</a></h2>

<p><code>try_alloc()</code> calls POE::Kernel&#39;s <code>session_alloc()</code> to allocate a session structure and begin managing the session within POE&#39;s kernel. It is called at the end of POE::Session&#39;s <code>create()</code>. It returns <code>$self</code>.</p>

<p>It is a subclassing hook for late session customization prior to <code>create()</code> returning. It may also affect the contents of <code>@_[ARG0..$#_]</code> that are passed to the session&#39;s _start handler.</p>

<pre class="sh_perl">  sub try_alloc {
    my ($self, @start_args) = @_;

    # Perform late initialization.
    # ...

    # Give $self to POE::Kernel.
    return $self-&#62;SUPER::try_alloc(@args);
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="POE::Session&#39;s_EVENTS"
>POE::Session&#39;s EVENTS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Please do not define new events that begin with a leading underscore. POE claims /^_/ events as its own.</p>

<p>POE::Session only generates one event, _default. All other internal POE events are generated by (and documented in) POE::Kernel.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_default"
>_default</a></h2>

<p>_default is the <code>AUTOLOAD</code> of event handlers. If POE::Session can&#39;t find a handler at dispatch time, it attempts to redirect the event to _default&#39;s handler instead.</p>

<p>If there&#39;s no _default handler, POE::Session will silently drop the event unless the &#34;default&#34; option is set.</p>

<p>To preserve the original information, the original event is slightly changed before being redirected to the _default handler: The original event parameters are moved to an array reference in ARG1, and the original event name is passed to _default in ARG0.</p>

<pre class="sh_perl">  sub handle_default {
    my ($event, $args) = @_[ARG0, ARG1];
    print(
      &#34;Session &#34;, $_[SESSION]-&#62;ID,
      &#34; caught unhandled event $event with (@$args).\n&#34;
    );
  }</pre>

<p>_default is quite flexible. It may be used for debugging, or to handle dynamically generated event names without pre-defining their handlers. In the latter sense, _default performs analogously to Perl&#39;s <code>AUTOLOAD</code>.</p>

<p>_default may also be used as the default or &#34;otherwise&#34; clause of a switch statement. Consider an input handler that throws events based on a command name:</p>

<pre class="sh_perl">  sub parse_command {
    my ($command, @parameters) = split /\s+/, $_[ARG0];
    $_[KERNEL]-&#62;post( &#34;cmd_$command&#34;, @parameters );
  }</pre>

<p>A _default handler may be used to emit errors for unknown commands:</p>

<pre class="sh_perl">  sub handle_default {
    my $event = $_[ARG0];
    return unless $event =~ /^cmd_(\S+)/;
    warn &#34;Unknown command: $1\n&#34;;
  }</pre>

<p>The _default behavior is implemented in POE::Session, so it may be different for other session types.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="POE::Session&#39;s_Debugging_Features"
>POE::Session&#39;s Debugging Features</a></h2>

<p>POE::Session contains one debugging assertion, for now.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="ASSERT_STATES"
>ASSERT_STATES</a></h3>

<p>Setting ASSERT_STATES to true causes every Session to warn when they are asked to handle unknown events. Session.pm implements the guts of ASSERT_STATES by defaulting the &#34;default&#34; option to true instead of false. See the option() method earlier in this document for details about the &#34;default&#34; option.</p>

<p></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><a href="/~rcaputo/POE-1.352/lib/POE/Kernel.pm" class="podlinkpod"
>POE::Kernel</a>.</p>

<p>The SEE ALSO section in <a href="/~rcaputo/POE-1.352/lib/POE.pm" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>There is a chance that session IDs may collide after Perl&#39;s integer value wraps. This can occur after as <i>few</i> as 4.29 billion sessions.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Beware_circular_references"
>Beware circular references</a></h2>

<p>As you&#39;re probably aware, a circular reference is when a variable is part of a reference chain that eventually refers back to itself. Perl will not reclaim the memory involved in such a reference chain until the chain is manually broken.</p>

<p>Here a POE::Session is created that refers to itself via an external scalar. The event handlers import $session via closures which are in turn stored within $session. Even if this session stops, the circular references will remain.</p>

<pre class="sh_perl">  my $session;
  $session = POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[HEAP]-&#62;{todo} = [ qw( step1 step2 step2a ) ],
        $_[KERNEL]-&#62;post( $session, &#39;next&#39; );
      },
      next =&#62; sub {
        my $next = shift @{ $_[HEAP]-&#62;{todo} };
        return unless $next;
        $_[KERNEL]-&#62;post( $session, $next );
      }
      # ....
    }
  );</pre>

<p>Reduced to its essence:</p>

<pre class="sh_perl">  my %event_handlers;
  $event_handler{_start} = sub { \%event_handlers };</pre>

<p>Note also that an anonymous sub creates a closure on all lexical variables in the scope it was defined in, even if it doesn&#39;t reference them. $session is still being held in a circular reference here:</p>

<pre class="sh_perl">  my $self = $package-&#62;new;
  my $session;
  $session = POE::Session-&#62;create(
    inline_state =&#62; {
      _start =&#62; sub { $self-&#62;_start( @_[ARG0..$#_] ) }
    }
  );</pre>

<p>To avoid this, a session may set an alias for itself. Other parts of the program may then refer to it by alias. In this case, one needn&#39;t keep track of the session themselves (POE::Kernel will do it anyway).</p>

<pre class="sh_perl">  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[HEAP]-&#62;{todo} = [ qw( step1 step2 step2a ) ],
        $_[KERNEL]-&#62;alias_set(&#39;step_doer&#39;);
        $_[KERNEL]-&#62;post( &#39;step_doer&#39;, &#39;next&#39; );
      },
      next =&#62; sub {
        my $next = shift @{ $_[HEAP]-&#62;{todo} };
        return unless $next;
        $_[KERNEL]-&#62;post( &#39;step_doer&#39;, $next );
      }
      # ....
    }
  );</pre>

<p>Aliases aren&#39;t even needed in the previous example because the session refers to itself. One could instead use POE::Kernel&#39;s yield() method to post the event back to the current session:</p>

<pre class="sh_perl">  next =&#62; sub {
    my $next = shift @{ $_[HEAP]-&#62;{todo} };
    return unless $next;
    $_[KERNEL]-&#62;yield( $next );
  }</pre>

<p>Or the <a href="#$_[SESSION]" class="podlinkpod"
>&#34;$_[SESSION]&#34;</a> parameter passed to every event handler, but yield() is more efficient.</p>

<pre class="sh_perl">  next =&#62; sub {
    my $next = shift @{ $_[HEAP]-&#62;{todo} };
    return unless $next;
    $_[KERNEL]-&#62;post( $_[SESSION], $next );
  }</pre>

<p>Along the same lines as <a href="#$_[SESSION]" class="podlinkpod"
>&#34;$_[SESSION]&#34;</a>, a session can respond back to the sender of an event by posting to <a href="#$_[SENDER]" class="podlinkpod"
>&#34;$_[SENDER]&#34;</a>. This is great for responding to requests.</p>

<p>If a program must hold onto some kind of dynamic session reference, it&#39;s recommended to use the session&#39;s numeric ID rather than the object itself. A session ID may be converted back into its object, but post() accepts session IDs as well as objects and aliases:</p>

<pre class="sh_perl">  my $session_id;
  $session_id = POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[HEAP]-&#62;{todo} = [ qw( step1 step2 step2a ) ],
        $_[KERNEL]-&#62;post( $session_id, &#39;next&#39; );
      },
      # ....
    }
  )-&#62;ID;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Please see <a href="/~rcaputo/POE-1.352/lib/POE.pm" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>

</div>
<!-- This should probably be put in the <div class="footer"></div> -->
<script type="text/javascript">
    $(document).ready(function(){
        var startingStyle = $.cookie('css') ? $.cookie('css') : 'http://st.pimg.net/tucs/css/sh_none.min.css';
        $.fn.styleSwitch(startingStyle);
        $("#styleswitch").val(startingStyle);
        sh_highlightDocument();
        $("#styleswitch").bind(($.browser.msie ? "click" : "change"), function() {
            $.fn.styleSwitch($(this).val());
        });
    });
</script>
<div class="styleswitch">
    syntax highlighting:
    <select id="styleswitch">
        <option value="http://st.pimg.net/tucs/css/sh_none.min.css">no syntax highlighting</option>
        <option value="http://st.pimg.net/tucs/css/sh_acid.min.css">acid</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-dark.min.css">berries-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-light.min.css">berries-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_bipolar.min.css">bipolar</option>
        <option value="http://st.pimg.net/tucs/css/sh_blacknblue.min.css">blacknblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_bright.min.css">bright</option>
        <option value="http://st.pimg.net/tucs/css/sh_contrast.min.css">contrast</option>
        <option value="http://st.pimg.net/tucs/css/sh_cpan.min.css">cpan</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkblue.min.css">darkblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkness.min.css">darkness</option>
        <option value="http://st.pimg.net/tucs/css/sh_desert.min.css">desert</option>
        <option value="http://st.pimg.net/tucs/css/sh_dull.min.css">dull</option>
        <option value="http://st.pimg.net/tucs/css/sh_easter.min.css">easter</option>
        <option value="http://st.pimg.net/tucs/css/sh_emacs.min.css">emacs</option>
        <option value="http://st.pimg.net/tucs/css/sh_golden.min.css">golden</option>
        <option value="http://st.pimg.net/tucs/css/sh_greenlcd.min.css">greenlcd</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-anjuta.min.css">ide-anjuta</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-codewarrior.min.css">ide-codewarrior</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-devcpp.min.css">ide-devcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-eclipse.min.css">ide-eclipse</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-kdev.min.css">ide-kdev</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-msvcpp.min.css">ide-msvcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_kwrite.min.css">kwrite</option>
        <option value="http://st.pimg.net/tucs/css/sh_matlab.min.css">matlab</option>
        <option value="http://st.pimg.net/tucs/css/sh_navy.min.css">navy</option>
        <option value="http://st.pimg.net/tucs/css/sh_nedit.min.css">nedit</option>
        <option value="http://st.pimg.net/tucs/css/sh_neon.min.css">neon</option>
        <option value="http://st.pimg.net/tucs/css/sh_night.min.css">night</option>
        <option value="http://st.pimg.net/tucs/css/sh_pablo.min.css">pablo</option>
        <option value="http://st.pimg.net/tucs/css/sh_peachpuff.min.css">peachpuff</option>
        <option value="http://st.pimg.net/tucs/css/sh_print.min.css">print</option>
        <option value="http://st.pimg.net/tucs/css/sh_rand01.min.css">rand01</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-dark.min.css">solarized-dark</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-light.min.css">solarized-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_style.min.css">style</option>
        <option value="http://st.pimg.net/tucs/css/sh_the.min.css">the</option>
        <option value="http://st.pimg.net/tucs/css/sh_typical.min.css">typical</option>
        <option value="http://st.pimg.net/tucs/css/sh_vampire.min.css">vampire</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim-dark.min.css">vim-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim.min.css">vim</option>
        <option value="http://st.pimg.net/tucs/css/sh_whatis.min.css">whatis</option>
        <option value="http://st.pimg.net/tucs/css/sh_whitengrey.min.css">whitengrey</option>
        <option value="http://st.pimg.net/tucs/css/sh_zellner.min.css">zellner</option>
    </select>
</div>



<div class="footer"><div class="cpanstats">78280 Uploads, 24725 Distributions
106010 Modules, 9649 Uploaders
</div>
hosted by <a href="http://www.yellowbot.com">YellowBot</a><br/>
<a href="http://www.yellowbot.com"><img alt="do. tag. write. share." src="http://st.pimg.net/tucs/img/yellowbot_logo.gif"></a>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="http://ipv4.v6test.develooper.com/js/v1/v6test.js"></script>

<script type="text/javascript">
   // v6.target = '';
   if (!v6.target) { v6.only_once = true }
   v6.site = '7A0D89A6-2B82-11DF-B9DA-F61CBD13F020';
   v6.api_server = 'http://ipv4.v6test.develooper.com';
   try {
     v6.test();
   } catch(err) {}
</script>
<script type="text/javascript">
  $(document).ready(function(){
    $("a[href^=http:]").click(function(){
      var href = $(this).attr('href');
      var m = href.match('\/\/([^\/:]+)');
      _gaq.push(['_trackEvent','External',m[1],'Module']);
    });
    $("a[href^=/CPAN/]").click(function(){
      var href = $(this).attr('href');
      _gaq.push(['_trackEvent','Download',href,'Module']);
    });
  });
</script>
<!-- Sat Apr 28 05:57:22 2012 GMT (0.11246919631958) @cpansearch1 -->
 </body>
</html>
