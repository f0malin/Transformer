<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <link rel="stylesheet" href="http://st.pimg.net/tucs/style.css" type="text/css" />
<style>
.styleswitch {
  text-align: right;
}
</style>


<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.cookie.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_main.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_perl.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.styleswitch.js"></script>

<link rel="stylesheet" href="http://st.pimg.net/tucs/print.css" type="text/css" media="print" />
  <link rel="alternate" type="application/rss+xml" title="RSS 1.0" href="http://search.cpan.org/uploads.rdf" />
  <link rel="search" href="http://st.pimg.net/tucs/opensearch.xml" type="application/opensearchdescription+xml" title="SearchCPAN" />
  <title>WWW::Search - search.cpan.org</title>
 <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3528438-1']);
    _gaq.push(["_setCustomVar",2,"Distribution","WWW-Search",3]);
    _gaq.push(["_setCustomVar",5,"Release","WWW-Search-2.508",3]);
    _gaq.push(["_setCustomVar",3,"Module","WWW::Search",3]);
    _gaq.push(["_setCustomVar",1,"Author","MTHURN",3]);
    _gaq.push(['_trackPageview']);
  </script>
 </head>
 <body id="cpansearch">
<center><div class="logo"><a href="/"><img src="http://st.pimg.net/tucs/img/cpan_banner.png" alt="CPAN"></a></div></center>
<div class="menubar">
 <a href="/">Home</a>
&middot; <a href="/author/">Authors</a>
&middot; <a href="/recent">Recent</a>
&middot; <a href="http://log.perl.org/cpansearch/">News</a>
&middot; <a href="/mirror">Mirrors</a>
&middot; <a href="/faq.html">FAQ</a>
&middot; <a href="/feedback">Feedback</a>
</div>
<form method="get" action="/search" name="f" class="searchbox">
<input type="text" name="query" value="" size="35">
<br>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</form>


 <a name="_top"></a>
  <div class=path>
<div id=permalink class="noprint"><a href="/perldoc?WWW::Search">permalink</a></div>
  <a href="/~mthurn/">Martin 'Kingpin' Thurn</a> &gt;
  <a href="/~mthurn/WWW-Search-2.508/">WWW-Search-2.508</a> &gt;
  WWW::Search
 </div>

<div class="noprint" style="float:right;align:left;width:19ex">
<a href="http://hexten.net/cpan-faces/"><img src="http://www.gravatar.com/avatar/4a367e4af38ec41e2e2556c8eef047dd?r=g&s=80&d=http%3A%2F%2Fst.pimg.net%2Ftucs%2Fimg%2Fwho.png" width=80 height=80 
style="float:right"
/></a>
<br style="clear:both"/>
<p style="text-align:right">Download:<br/> <a href="/CPAN/authors/id/M/MT/MTHURN/WWW-Search-2.508.tar.gz">WWW-Search-2.508.tar.gz</a></p>
<p style="text-align:right"><a href="http://deps.cpantesters.org/?module=WWW%3A%3ASearch;perl=latest">Dependencies</a></p>
<p style="text-align:right"><a href="http://www.annocpan.org/~MTHURN/WWW-Search-2.508/lib/WWW/Search.pm">Annotate this POD
</a></p>
<div class=box style='width:150px; float: right'>
<h1 class=t5>Related Modules</h1>
<div style="margin:2px">
<a href="/perldoc?WWW%3A%3ASMS">WWW::SMS</a><br>
<a href="/perldoc?LWP%3A%3ASimple">LWP::Simple</a><br>
<a href="/perldoc?HTML%3A%3AParser">HTML::Parser</a><br>
<a href="/perldoc?LWP%3A%3AUserAgent">LWP::UserAgent</a><br>
<a href="/perldoc?WWW%3A%3AMechanize">WWW::Mechanize</a><br>
<a href="/perldoc?WWW%3A%3ASearch%3A%3AEbay">WWW::Search::Ebay</a><br>
<a href="/perldoc?HTTP%3A%3AGHTTP">HTTP::GHTTP</a><br>
<a href="/perldoc?HTTP%3A%3ADaemon">HTTP::Daemon</a><br>
<a href="/perldoc?HTTP%3A%3ACookies">HTTP::Cookies</a><br>
<a href="/perldoc?URI%3A%3ASequin">URI::Sequin</a><br>
<small>
<a href="http://perlmonks.org/?node=cpan+module+search&pivot=1&module=WWW%3A%3ASearch">more...</a><br>
By <a href="http://perlmonks.org/">perlmonks.org</a></small>
</div>
</div>

<div style="float:right">
<div class=box style='width:150px'>
<h1 class=t5>CPAN RT</h1>
<div style="margin:2px">
<table style="margin-left:auto;margin-right:auto">
<tr><td>Open&nbsp;</td><td style="text-align:right"> 0</td></tr>
</table>
<a href="https://rt.cpan.org/Public/Dist/Display.html?Name=WWW-Search">View/Report Bugs</a><br/>
</div>
</div>

</div>
</div>
  Module Version:  2.565 &nbsp;
<span class="noprint">
  <a href="/src/MTHURN/WWW-Search-2.508/lib/WWW/Search.pm">Source</a> &nbsp;
</span>
<a name="___top"></a>
<div class=pod>
<div class=toc>
<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Sample_program'>Sample program</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#METHODS_AND_FUNCTIONS_FOR_SEARCHERS'>METHODS AND FUNCTIONS FOR SEARCHERS</a>
  <li class='indexItem indexItem1'><a href='#METHODS_AND_FUNCTIONS_FOR_BACKEND_PROGRAMMERS'>METHODS AND FUNCTIONS FOR BACKEND PROGRAMMERS</a>
  <li class='indexItem indexItem1'><a href='#IMPLEMENTING_NEW_BACKENDS'>IMPLEMENTING NEW BACKENDS</a>
  <li class='indexItem indexItem1'><a href='#BUGS_AND_DESIRED_FEATURES'>BUGS AND DESIRED FEATURES</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>WWW::Search - Virtual base class for WWW searches</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl">  use WWW::Search;
  my $sEngine = &#39;AltaVista&#39;;
  my $oSearch = new WWW::Search($sEngine);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>This class is the parent for all access methods supported by the <code>WWW::Search</code> library. This library implements a Perl API to web-based search engines.</p>

<p>See README for a list of search engines currently supported, and for a lot of interesting high-level information about this distribution.</p>

<p>Search results can be limited, and there is a pause between each request to avoid overloading either the client or the server.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Sample_program"
>Sample program</a></h2>

<p>Here is a sample program:</p>

<pre class="sh_perl">  my $sQuery = &#39;Columbus Ohio sushi restaurant&#39;;
  my $oSearch = new WWW::Search(&#39;AltaVista&#39;);
  $oSearch-&#62;native_query(WWW::Search::escape_query($sQuery));
  $oSearch-&#62;login($sUser, $sPassword);
  while (my $oResult = $oSearch-&#62;next_result())
    {
    print $oResult-&#62;url, &#34;\n&#34;;
    } # while
  $oSearch-&#62;logout;</pre>

<p>Results are objects of type <code>WWW::SearchResult</code> (see <a href="/~mthurn/WWW-Search-2.508/lib/WWW/SearchResult.pm" class="podlinkpod"
>WWW::SearchResult</a> for details). Note that different backends support different result fields. All backends are required to support title and url.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>For specific search engines, see <a href="/perldoc?WWW%3A%3ASearch%3A%3ATheEngineName" class="podlinkpod"
>WWW::Search::TheEngineName</a> (replacing TheEngineName with a particular search engine).</p>

<p>For details about the results of a search, see <a href="/~mthurn/WWW-Search-2.508/lib/WWW/SearchResult.pm" class="podlinkpod"
>WWW::SearchResult</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS_AND_FUNCTIONS_FOR_SEARCHERS"
>METHODS AND FUNCTIONS FOR SEARCHERS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<p>To create a new WWW::Search, call</p>

<pre class="sh_perl">    $oSearch = new WWW::Search(&#39;SearchEngineName&#39;);</pre>

<p>where SearchEngineName is replaced with a particular search engine. For example:</p>

<pre class="sh_perl">    $oSearch = new WWW::Search(&#39;Yahoo&#39;);</pre>

<p>If no search engine is specified, a default (currently &#39;Null::Empty&#39;) will be chosen for you.</p>

<dt><a name="version"
>version</a></dt>

<dd>
<p>Returns the value of the $VERSION variable of the backend engine, or $WWW::Search::VERSION if the backend does not contain $VERSION.</p>

<dt><a name="maintainer"
>maintainer</a></dt>

<dd>
<p>Returns the value of the $MAINTAINER variable of the backend engine, or $WWW::Search::MAINTAINER if the backend does not contain $MAINTAINER.</p>

<dt><a name="installed_engines"
>installed_engines</a></dt>

<dd>
<p>Returns a list of the names of all installed backends. We can not tell if they are up-to-date or working, though.</p>

<pre class="sh_perl">  use WWW::Search;
  my @asEngines = sort &#38;WWW::Search::installed_engines();
  local $&#34; = &#39;, &#39;;
  print (&#34; + These WWW::Search backends are installed: @asEngines\n&#34;);
  # Choose a backend at random (yes, this is rather silly):
  my $oSearch = WWW::Search-&#62;new($asEngines[rand(scalar(@asEngines))]);</pre>

<dt><a name="native_query"
>native_query</a></dt>

<dd>
<p>Specify a query (and optional options) to the current search object. Previous query (if any) and its cached results (if any) will be thrown away. The option values and the query must be escaped; call <a href="/perldoc?WWW%3A%3ASearch%3A%3Aescape_query()" class="podlinkpod"
>WWW::Search::escape_query()</a> to escape a string. The search process is not actually begun until <code>results()</code> or <code>next_result()</code> is called (lazy!), so native_query does not return anything.</p>

<p>Example:</p>

<pre class="sh_perl">  $oSearch-&#62;native_query(&#39;search-engine-specific+escaped+query+string&#39;,
                        { option1 =&#62; &#39;able&#39;, option2 =&#62; &#39;baker&#39; } );</pre>

<p>The hash of options following the query string is optional. The query string is backend-specific. There are two kinds of options: options specific to the backend, and generic options applicable to multiple backends.</p>

<p>Generic options all begin with &#39;search_&#39;. Currently a few are supported:</p>

<dl>
<dt><a name="search_url"
>search_url</a></dt>

<dd>
<p>Specifies the base URL for the search engine.</p>

<dt><a name="search_debug"
>search_debug</a></dt>

<dd>
<p>Enables backend debugging. The default is 0 (no debugging).</p>

<dt><a name="search_parse_debug"
>search_parse_debug</a></dt>

<dd>
<p>Enables backend parser debugging. The default is 0 (no debugging).</p>

<dt><a name='search_to_file'></a><a name="search_to_file_FILE"
>search_to_file FILE</a></dt>

<dd>
<p>Causes the search results to be saved in a set of files prefixed by FILE. (Used internally by the test-suite, not intended for general use.)</p>

<dt><a name='search_from_file'></a><a name="search_from_file_FILE"
>search_from_file FILE</a></dt>

<dd>
<p>Reads a search from a set of files prefixed by FILE. (Used internally by the test-suite, not intended for general use.)</p>
</dd>
</dl>

<p>Some backends may not implement these generic options, but any which do implement them must provide these semantics.</p>

<p>Backend-specific options are described in the documentation for each backend. In most cases the options and their values are packed together to create the query portion of the final URL.</p>

<p>Details about how the search string and option hash are interpreted might be found in the search-engine-specific manual pages (WWW::Search::SearchEngineName).</p>

<dt><a name="gui_query"
>gui_query</a></dt>

<dd>
<p>Specify a query to the current search object; the query will be performed with the engine&#39;s default options, as if it were typed by a user in a browser window.</p>

<p>Same arguments as <code>native_query()</code> above.</p>

<p>Currently, this feature is supported by only a few backends; consult the documentation for each backend to see if it is implemented.</p>

<dt><a name="cookie_jar"
>cookie_jar</a></dt>

<dd>
<p>Call this method (anytime before asking for results) if you want to communicate cookie data with the search engine. Takes one argument, either a filename or an HTTP::Cookies object. If you give a filename, WWW::Search will attempt to read/store cookies there (by passing the filename to HTTP::Cookies::new).</p>

<pre class="sh_perl">  $oSearch-&#62;cookie_jar(&#39;/tmp/my_cookies&#39;);</pre>

<p>If you give an HTTP::Cookies object, it is up to you to save the cookies if/when you wish.</p>

<pre class="sh_perl">  use HTTP::Cookies;
  my $oJar = HTTP::Cookies-&#62;new(...);
  $oSearch-&#62;cookie_jar($oJar);</pre>

<p>If you pass in no arguments, the cookie jar (if any) is returned.</p>

<pre class="sh_perl">  my $oJar = $oSearch-&#62;cookie_jar;
  unless (ref $oJar) { print &#34;No jar&#34; };</pre>

<dt><a name="date_from"
>date_from</a></dt>

<dd>
<p>Set/get the start date for limiting the query by a date range. See the documentation for each backend to find out if date ranges are supported.</p>

<dt><a name="date_to"
>date_to</a></dt>

<dd>
<p>Set/get the end date for limiting the query by a date range. See the documentation for each backend to find out if date ranges are supported.</p>

<dt><a name="env_proxy"
>env_proxy</a></dt>

<dd>
<p>Enable loading proxy settings from environment variables. The proxy URL will be read from $ENV{http_proxy}. The username for authentication will be read from $ENV{http_proxy_user}. The password for authentication will be read from $ENV{http_proxy_pwd}.</p>

<p>If you don&#39;t want to put passwords in the environment, one solution would be to subclass LWP::UserAgent and use $ENV{WWW_SEARCH_USERAGENT} instead (see user_agent below).</p>

<p>env_proxy() must be called before the first retrieval is attempted.</p>

<p>Example:</p>

<pre class="sh_perl">  $ENV{http_proxy     } = &#39;<a href="http://my.proxy.com:80" class="podlinkurl"
>http://my.proxy.com:80</a>&#39;;
  $ENV{http_proxy_user} = &#39;bugsbun&#39;;
  $ENV{http_proxy_pwd } = &#39;c4rr0t5&#39;;
  $oSearch-&#62;env_proxy(&#39;yes&#39;);  # Turn on with any true value
  ...
  $oSearch-&#62;env_proxy(0);  # Turn off with zero
  ...
  if ($oSearch-&#62;env_proxy)  # Test</pre>

<dt><a name="http_proxy"
>http_proxy</a></dt>

<dd>
<p>Set up an HTTP proxy (for connections from behind a firewall).</p>

<p>Takes the same arguments as LWP::UserAgent::proxy().</p>

<p>This routine should be called before calling any of the result functions (any method with &#34;result&#34; in its name).</p>

<p>Example:</p>

<pre class="sh_perl">  # Turn on and set address:
  $oSearch-&#62;http_proxy([&#39;http&#39;,&#39;ftp&#39;] =&#62; &#39;<a href="http://proxy:8080" class="podlinkurl"
>http://proxy:8080</a>&#39;);
  # Turn off:
  $oSearch-&#62;http_proxy(&#39;&#39;);</pre>

<dt><a name='http_proxy_user'></a><a name="http_proxy_user,_http_proxy_pwd"
>http_proxy_user, http_proxy_pwd</a></dt>

<dd>
<p>Set/get HTTP proxy authentication data.</p>

<p>These routines set/get username and password used in proxy authentication. Authentication is attempted only if all three items (proxy URL, username and password) have been set.</p>

<p>Example:</p>

<pre class="sh_perl">    $oSearch-&#62;http_proxy_user(&#34;myuser&#34;);
    $oSearch-&#62;http_proxy_pwd(&#34;mypassword&#34;);
    $oSearch-&#62;http_proxy_user(undef);   # Example for no authentication

    $username = $oSearch-&#62;http_proxy_user();</pre>

<dt><a name="maximum_to_retrieve"
>maximum_to_retrieve</a></dt>

<dd>
<p>Set the maximum number of hits to return. Queries resulting in more than this many hits will return the first hits, up to this limit. Although this specifies a maximum limit, search engines might return less than this number.</p>

<p>Defaults to 500.</p>

<p>Example: $max = $oSearch-&#62;maximum_to_retrieve(100);</p>

<p>You can also spell this method &#34;maximum_to_return&#34;.</p>

<dt><a name="maximum_to_return"
>maximum_to_return</a></dt>

<dd>
<p>Synonym for maximum_to_retrieve</p>

<dt><a name="timeout"
>timeout</a></dt>

<dd>
<p>The maximum length of time any portion of the query should take, in seconds.</p>

<p>Defaults to 60.</p>

<p>Example: $oSearch-&#62;timeout(120);</p>

<dt><a name="login"
>login</a></dt>

<dd>
<p>Backends which need to login to the search engine should implement this function. Takes two arguments, user and password. Return nonzero if login was successful. Return undef or 0 if login failed.</p>

<dt><a name="logout"
>logout</a></dt>

<dd>
<p>Backends which need to logout from the search engine should implement this function.</p>

<dt><a name="approximate_result_count"
>approximate_result_count</a></dt>

<dd>
<p>Some backends indicate how many results they have found. Typically this is an approximate value.</p>

<dt><a name="approximate_hit_count"
>approximate_hit_count</a></dt>

<dd>
<p>This is an alias for approximate_result_count().</p>

<dt><a name="results"
>results</a></dt>

<dd>
<p>Return all the results of a query as an array of WWW::SearchResult objects.</p>

<p>Note: This might take a while, because a web backend will keep asking the search engine for &#34;next page of results&#34; over and over until there are no more next pages, and THEN return from this function.</p>

<p>If an error occurs at any time during query processing, it will be indicated in the response().</p>

<p>Example:</p>

<pre class="sh_perl">    @results = $oSearch-&#62;results();
    # Go have a cup of coffee while the previous line executes...
    foreach $oResult (@results)
      {
      print $oResult-&#62;url(), &#34;\n&#34;;
      } # foreach</pre>

<dt><a name="next_result"
>next_result</a></dt>

<dd>
<p>Call this method repeatedly to return each result of a query as a WWW::SearchResult object. Example:</p>

<pre class="sh_perl">    while ($oResult = $oSearch-&#62;next_result())
      {
      print $oResult-&#62;url(), &#34;\n&#34;;
      } # while</pre>

<p>When there are no more results, or if an error occurs, next_result() will return undef.</p>

<p>If an error occurs at any time during query processing, it will be indicated in the response().</p>

<dt><a name='seek_result'></a><a name="seek_result($offset)"
>seek_result($offset)</a></dt>

<dd>
<p>Set which result should be returned next time <code>next_result()</code> is called. Results are zero-indexed.</p>

<p>The only guaranteed valid offset is 0, which will replay the results from the beginning. In particular, seeking past the end of the current cached results probably will not do what you might think it should.</p>

<p>Results are cached, so this does not re-issue the query or cause IO (unless you go off the end of the results). To re-do the query, create a new search object.</p>

<p>Example:</p>

<pre class="sh_perl">    $oSearch-&#62;seek_result(0);</pre>

<dt><a name="response"
>response</a></dt>

<dd>
<p>Returns an <a href="/perldoc?HTTP%3A%3AResponse" class="podlinkpod"
>HTTP::Response</a> object which resulted from the most-recently-sent query. Errors can be detected like this:</p>

<pre class="sh_perl">    if (! $oSearch-&#62;response-&#62;is_success)
      {
      print STDERR &#34;Error:  &#34; . $oSearch-&#62;response-&#62;as_string() . &#34;\n&#34;;
      } # if</pre>

<p>Note to backend authors: even if the backend does not involve the web, it should return an <a href="/perldoc?HTTP%3A%3AResponse" class="podlinkpod"
>HTTP::Response</a> object.</p>

<dt><a name="submit"
>submit</a></dt>

<dd>
<p>This method can be used to submit URLs to the search engines for indexing. Consult the documentation for each backend to find out if it is implemented there, and if so what the arguments are.</p>

<p>Returns an HTTP::Response object describing the result of the submission request. Consult the documentation for each backend to find out the meaning of the response.</p>

<dt><a name="opaque"
>opaque</a></dt>

<dd>
<p>This function provides an application a place to store one opaque data element (or many, via a Perl reference). This facility is useful to (for example), maintain client-specific information in each active query when you have multiple concurrent queries.</p>

<dt><a name="escape_query"
>escape_query</a></dt>

<dd>
<p>Escape a query. Before queries are sent to the internet, special characters must be escaped so that a proper URL can be formed. This is like escaping a URL, but all non-alphanumeric characters are escaped and and spaces are converted to &#34;+&#34;s.</p>

<p>Example:</p>

<pre class="sh_perl">    $escaped = WWW::Search::escape_query(&#39;+hi +mom&#39;);
    # $escaped is now &#39;%2Bhi+%2Bmom&#39;</pre>

<p>See also <code>unescape_query()</code>. NOTE that this is not a method, it is a plain function.</p>

<dt><a name="unescape_query"
>unescape_query</a></dt>

<dd>
<p>Unescape a query. See <code>escape_query()</code> for details.</p>

<p>Example:</p>

<pre class="sh_perl">    $unescaped = WWW::Search::unescape_query(&#39;%22hi+mom%22&#39;);
    # $unescaped eq q{&#34;hi mom&#34;}</pre>

<p>NOTE that this is not a method, it is a plain function.</p>

<dt><a name="strip_tags"
>strip_tags</a></dt>

<dd>
<p>Given a string, returns a copy of that string with HTML tags removed. This should be used by each backend as they insert the title and description values into the search results objects.</p>

<p>NOTE that this is not a method, it is a plain function.</p>

<dt><a name="is_http_proxy"
>is_http_proxy</a></dt>

<dd>
<p>Returns true if proxy information is available.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS_AND_FUNCTIONS_FOR_BACKEND_PROGRAMMERS"
>METHODS AND FUNCTIONS FOR BACKEND PROGRAMMERS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<dl>
<dt><a name="reset_search"
>reset_search</a></dt>

<dd>
<p>Resets internal data structures to start over with a new search (on the same engine).</p>

<dt><a name="is_http_proxy_auth_data"
>is_http_proxy_auth_data</a></dt>

<dd>
<p>Returns true if all authentication data (proxy URL, username, and password) are available.</p>

<dt><a name='agent_name'></a><a name="agent_name($sName)"
>agent_name($sName)</a></dt>

<dd>
<p>If your search engine rejects certain browser, you can trick it into thinking you&#39;re any browser type you want. See below under user_agent().</p>

<dt><a name='agent_email'></a><a name="agent_email($sName)"
>agent_email($sName)</a></dt>

<dd>
<dt><a name='user_agent'></a><a name="user_agent($NON_ROBOT)"
>user_agent($NON_ROBOT)</a></dt>

<dd>
<p>This internal routine creates a user-agent for derived classes that query the web. If any non-false argument is given, a normal LWP::UserAgent (rather than a LWP::RobotUA) is used.</p>

<p>Returns the user-agent object.</p>

<p>If a backend needs the low-level LWP::UserAgent or LWP::RobotUA to have a particular name, $oSearch-&#62;agent_name() and possibly $oSearch-&#62;agent_email() should be called to set the desired values *before* calling $oSearch-&#62;user_agent().</p>

<p>If the environment variable WWW_SEARCH_USERAGENT has a value, it will be used as the class for a new user agent object. This class should be a subclass of LWP::UserAgent. For example,</p>

<pre class="sh_perl">  $ENV{WWW_SEARCH_USERAGENT} = &#39;My::Own::UserAgent&#39;;
  # If this env.var. has no value,
  # LWP::UserAgent or LWP::RobotUA will be used.
  $oSearch = new WWW::Search(&#39;MyBackend&#39;);
  $oSearch-&#62;agent_name(&#39;MySpider&#39;);
  if ($iBackendWebsiteRequiresNonRobot)
    {
    $oSearch-&#62;user_agent(&#39;non-robot&#39;);
    }
  else
    {
    $oSearch-&#62;agent_email(&#39;me@here.com&#39;);
    $oSearch-&#62;user_agent();
    }</pre>

<p>Backends should use robot-style user-agents whenever possible.</p>

<dt><a name="http_referer"
>http_referer</a></dt>

<dd>
<p>Get / set the value of the HTTP_REFERER variable for this search object. Some search engines might only accept requests that originated at some specific previous page. This method lets backend authors &#34;fake&#34; the previous page. Call this method before calling http_request.</p>

<pre class="sh_perl">  $oSearch-&#62;http_referer(&#39;<a href="http://prev.engine.com/wherever/setup.html" class="podlinkurl"
>http://prev.engine.com/wherever/setup.html</a>&#39;);
  $oResponse = $oSearch-&#62;http_request(&#39;GET&#39;, $url);</pre>

<dt><a name="http_method"
>http_method</a></dt>

<dd>
<p>Get / set the method to be used for the HTTP request. Must be either &#39;GET&#39; or &#39;POST&#39;. Call this method before calling http_request. (Normally you would set this during _native_setup_search().) The default is &#39;GET&#39;.</p>

<pre class="sh_perl">  $oSearch-&#62;http_method(&#39;POST&#39;);</pre>

<dt><a name='http_request'></a><a name="http_request($method,_$url)"
>http_request($method, $url)</a></dt>

<dd>
<p>Submit the HTTP request to the world, and return the response. Similar to LWP::UserAgent::request. Handles cookies, follows redirects, etc. Requires that http_referer already be set up, if needed.</p>

<dt><a name="next_url"
>next_url</a></dt>

<dd>
<p>Get or set the URL for the next backend request. This can be used to save the WWW::Search state between sessions (e.g. if you are showing pages of results to the user in a web browser). Before closing down a session, save the value of next_url:</p>

<pre class="sh_perl">  ...
  $oSearch-&#62;maximum_to_return(10);
  while ($oSearch-&#62;next_result) { ... }
  my $urlSave = $oSearch-&#62;next_url;</pre>

<p>Then, when you start up the next session (e.g. after the user clicks your &#34;next&#34; button), restore this value before calling for the results:</p>

<pre class="sh_perl">  $oSearch-&#62;native_query(...);
  $oSearch-&#62;next_url($urlSave);
  $oSearch-&#62;maximum_to_return(20);
  while ($oSearch-&#62;next_result) { ... }</pre>

<p>WARNING: It is entirely up to you to keep your interface in sync with the number of hits per page being returned from the backend. And, we make no guarantees whether this method will work for any given backend. (Their caching scheme might not enable you to jump into the middle of a list of search results, for example.)</p>

<dt><a name="split_lines"
>split_lines</a></dt>

<dd>
<p>This internal routine splits data (typically the result of the web page retrieval) into lines in a way that is OS independent. If the first argument is a reference to an array, that array is taken to be a list of possible delimiters for this split. For example, Yahoo.pm uses &#60;p&#62; and &#60;dd&#62;&#60;li&#62; as &#34;line&#34; delimiters for convenience.</p>

<dt><a name="generic_option"
>generic_option</a></dt>

<dd>
<p>This internal routine checks if an option is generic or backend specific. Currently all generic options begin with &#39;search_&#39;. This routine is not a method.</p>

<dt><a name="_native_setup_search"
>_native_setup_search</a></dt>

<dd>
<p>Do some backend-specific initialization. It will be called with the same arguments as native_query().</p>

<dt><a name="setup_search"
>setup_search</a></dt>

<dd>
<p>This internal routine does generic Search setup. It calls <code>_native_setup_search()</code> to do backend-specific setup.</p>

<dt><a name="need_to_delay"
>need_to_delay</a></dt>

<dd>
<p>A backend should override this method in order to dictate whether user_agent_delay() needs to be called before the next HTTP request is sent. Return any perlish true or zero value.</p>

<dt><a name="user_agent_delay"
>user_agent_delay</a></dt>

<dd>
<p>According to what need_to_delay() returns, user_agent_delay() will be called between requests to remote servers to avoid overloading them with many back-to-back requests.</p>

<dt><a name="absurl"
>absurl</a></dt>

<dd>
<p>An internal routine to convert a relative URL into a absolute URL. It takes two arguments, the &#39;base&#39; url (usually the search engine CGI URL) and the URL to be converted. Returns a URI object.</p>

<dt><a name="retrieve_some"
>retrieve_some</a></dt>

<dd>
<p>An internal routine to interface with <code>_native_retrieve_some()</code>. Checks for overflow.</p>

<dt><a name="_native_retrieve_some"
>_native_retrieve_some</a></dt>

<dd>
<p>Fetch the next page of results from the web engine, parse the results, and prepare for the next page of results.</p>

<p>If a backend defines this method, it is in total control of the WWW fetch, parsing, and preparing for the next page of results. See the WWW::Search::AltaVista module for example usage of the _native_retrieve_some method.</p>

<p>An easier way to achieve this in a backend is to inherit _native_retrieve_some from WWW::Search, and do only the HTML parsing. Simply define a method _parse_tree which takes one argument, an HTML::TreeBuilder object, and returns an integer, the number of results found on this page. See the WWW::Search::Yahoo module for example usage of the _parse_tree method.</p>

<p>A backend should, in general, define either _parse_tree() or _native_retrieve_some(), but not both.</p>

<p>Additional features of the default _native_retrieve_some method:</p>

<p>Sets $self-&#62;{_prev_url} to the URL of the page just retrieved.</p>

<p>Calls $self-&#62;preprocess_results_page() on the raw HTML of the page.</p>

<p>Then, parses the page with an HTML::TreeBuilder object and passes that populated object to $self-&#62;_parse_tree().</p>

<p>Additional notes on using the _parse_tree method:</p>

<p>The built-in HTML::TreeBuilder object used to parse the page has store_comments turned ON. If a backend needs to use a subclassed or modified HTML::TreeBuilder object, the backend should set $self-&#62;{&#39;_treebuilder&#39;} to that object before any results are retrieved. The best place to do this is at the end of _native_setup_search.</p>

<pre class="sh_perl">  my $oTree = new myTreeBuilder;
  $oTree-&#62;store_pis(1);  # for example
  $self-&#62;{&#39;_treebuilder&#39;} = $oTree;</pre>

<p>When _parse_tree() is called, the $self-&#62;next_url is cleared. During parsing, the backend should set $self-&#62;next_url to the appropriate URL for the next page of results. (If _parse_tree() does not set the value, the search will end after parsing this page of results.)</p>

<p>When _parse_tree() is called, the URL for the page being parsed can be found in $self-&#62;{_prev_url}.</p>

<dt><a name="result_as_HTML"
>result_as_HTML</a></dt>

<dd>
<p>Given a WWW::SearchResult object, formats it human-readable with HTML.</p>

<dt><a name="preprocess_results_page"
>preprocess_results_page</a></dt>

<dd>
<p>A filter on the raw HTML of the results page. This allows the backend to alter the HTML before it is parsed, such as to correct for known problems, HTML that can not be parsed correctly, etc.</p>

<p>Takes one argument, a string (the HTML webpage); returns one string (the same HTML, modified).</p>

<p>This method is called from within _native_retrieve_some (above) before the HTML of the page is parsed.</p>

<p>See the WWW::Search::Ebay distribution 2.07 or higher for example usage.</p>

<dt><a name='test_cases'></a><a name="test_cases_(DEPRECATED)"
>test_cases (DEPRECATED)</a></dt>

<dd>
<p>Deprecated.</p>

<p>Returns the value of the $TEST_CASES variable of the backend engine.</p>

<dt><a name='hash_to_cgi_string'></a><a name="hash_to_cgi_string_(DEPRECATED)"
>hash_to_cgi_string (DEPRECATED)</a></dt>

<dd>
<p>Given a reference to a hash of string =&#62; string, constructs a CGI parameter string that looks like &#39;key1=value1&#38;key2=value2&#39;.</p>

<p>If the value is undef, the key will not be added to the string.</p>

<p>At one time, for testing purposes, we asked backends to use this function rather than piecing the URL together by hand, to ensure that URLs are identical across platforms and software versions. But this is no longer necessary.</p>

<p>Example:</p>

<pre class="sh_perl">    $self-&#62;{_options} = {
                         &#39;opt3&#39; =&#62; &#39;val3&#39;,
                         &#39;search_url&#39; =&#62; &#39;<a href="http://www.deja.com/dnquery.xp" class="podlinkurl"
>http://www.deja.com/dnquery.xp</a>&#39;,
                         &#39;opt1&#39; =&#62; &#39;val1&#39;,
                         &#39;QRY&#39; =&#62; $native_query,
                         &#39;opt2&#39; =&#62; &#39;val2&#39;,
                        };
    $self-&#62;{_next_url} = $self-&#62;{_options}{&#39;search_url&#39;} .&#39;?&#39;.
                         $self-&#62;hash_to_cgi_string($self-&#62;{_options});</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPLEMENTING_NEW_BACKENDS"
>IMPLEMENTING NEW BACKENDS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><code>WWW::Search</code> supports backends to separate search engines. Each backend is implemented as a subclass of <code>WWW::Search</code>. <a href="/perldoc?WWW%3A%3ASearch%3A%3AYahoo" class="podlinkpod"
>WWW::Search::Yahoo</a> provides a good sample backend.</p>

<p>A backend must have the routine <code>_native_setup_search()</code>. A backend must have the routine <code>_native_retrieve_some()</code> or <code>_parse_tree()</code>.</p>

<p><code>_native_setup_search()</code> is invoked before the search. It is passed a single argument: the escaped, native version of the query.</p>

<p><code>_native_retrieve_some()</code> is the core of a backend. It will be called periodically to fetch URLs. It should retrieve several hits from the search service and add them to the cache. It should return the number of hits found, or undef when there are no more hits.</p>

<p>Internally, <code>_native_retrieve_some()</code> typically sends an HTTP request to the search service, parses the HTML, extracts the links and descriptions, then saves the URL for the next page of results. See the code for the <code>WWW::Search::AltaVista</code> module for an example.</p>

<p>Alternatively, a backend can define the method <code>_parse_tree()</code> instead of <code>_native_retrieve_some()</code>. See the <code>WWW::Search::Ebay</code> module for a good example.</p>

<p>If you implement a new backend, please let the authors know.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS_AND_DESIRED_FEATURES"
>BUGS AND DESIRED FEATURES <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>The bugs are there for you to find (some people call them Easter Eggs).</p>

<p>Desired features:</p>

<dl>
<dt><a name='A'></a><a name="A_portable_query_language."
>A portable query language.</a></dt>

<dd>
<p>A portable language would easily allow you to move queries easily between different search engines. A query abstraction is non-trivial and unfortunately will not be done any time soon by the current maintainer. If you want to take a shot at it, please let me know.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>John Heidemann &#60;johnh@isi.edu&#62; Maintained by Martin Thurn, <code>mthurn@cpan.org</code>, <a href="http://www.sandcrawler.com/SWB/cpan-modules.html" class="podlinkurl"
>http://www.sandcrawler.com/SWB/cpan-modules.html</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Copyright (c) 1996 University of Southern California. All rights reserved.</p>

<p>Redistribution and use in source and binary forms are permitted provided that the above copyright notice and this paragraph are duplicated in all such forms and that any documentation, advertising materials, and other materials related to such distribution and use acknowledge that the software was developed by the University of Southern California, Information Sciences Institute. The name of the University may not be used to endorse or promote products derived from this software without specific prior written permission.</p>

<p>THIS SOFTWARE IS PROVIDED &#34;AS IS&#34; AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</p>

</div>
<!-- This should probably be put in the <div class="footer"></div> -->
<script type="text/javascript">
    $(document).ready(function(){
        var startingStyle = $.cookie('css') ? $.cookie('css') : 'http://st.pimg.net/tucs/css/sh_none.min.css';
        $.fn.styleSwitch(startingStyle);
        $("#styleswitch").val(startingStyle);
        sh_highlightDocument();
        $("#styleswitch").bind(($.browser.msie ? "click" : "change"), function() {
            $.fn.styleSwitch($(this).val());
        });
    });
</script>
<div class="styleswitch">
    syntax highlighting:
    <select id="styleswitch">
        <option value="http://st.pimg.net/tucs/css/sh_none.min.css">no syntax highlighting</option>
        <option value="http://st.pimg.net/tucs/css/sh_acid.min.css">acid</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-dark.min.css">berries-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-light.min.css">berries-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_bipolar.min.css">bipolar</option>
        <option value="http://st.pimg.net/tucs/css/sh_blacknblue.min.css">blacknblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_bright.min.css">bright</option>
        <option value="http://st.pimg.net/tucs/css/sh_contrast.min.css">contrast</option>
        <option value="http://st.pimg.net/tucs/css/sh_cpan.min.css">cpan</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkblue.min.css">darkblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkness.min.css">darkness</option>
        <option value="http://st.pimg.net/tucs/css/sh_desert.min.css">desert</option>
        <option value="http://st.pimg.net/tucs/css/sh_dull.min.css">dull</option>
        <option value="http://st.pimg.net/tucs/css/sh_easter.min.css">easter</option>
        <option value="http://st.pimg.net/tucs/css/sh_emacs.min.css">emacs</option>
        <option value="http://st.pimg.net/tucs/css/sh_golden.min.css">golden</option>
        <option value="http://st.pimg.net/tucs/css/sh_greenlcd.min.css">greenlcd</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-anjuta.min.css">ide-anjuta</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-codewarrior.min.css">ide-codewarrior</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-devcpp.min.css">ide-devcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-eclipse.min.css">ide-eclipse</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-kdev.min.css">ide-kdev</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-msvcpp.min.css">ide-msvcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_kwrite.min.css">kwrite</option>
        <option value="http://st.pimg.net/tucs/css/sh_matlab.min.css">matlab</option>
        <option value="http://st.pimg.net/tucs/css/sh_navy.min.css">navy</option>
        <option value="http://st.pimg.net/tucs/css/sh_nedit.min.css">nedit</option>
        <option value="http://st.pimg.net/tucs/css/sh_neon.min.css">neon</option>
        <option value="http://st.pimg.net/tucs/css/sh_night.min.css">night</option>
        <option value="http://st.pimg.net/tucs/css/sh_pablo.min.css">pablo</option>
        <option value="http://st.pimg.net/tucs/css/sh_peachpuff.min.css">peachpuff</option>
        <option value="http://st.pimg.net/tucs/css/sh_print.min.css">print</option>
        <option value="http://st.pimg.net/tucs/css/sh_rand01.min.css">rand01</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-dark.min.css">solarized-dark</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-light.min.css">solarized-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_style.min.css">style</option>
        <option value="http://st.pimg.net/tucs/css/sh_the.min.css">the</option>
        <option value="http://st.pimg.net/tucs/css/sh_typical.min.css">typical</option>
        <option value="http://st.pimg.net/tucs/css/sh_vampire.min.css">vampire</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim-dark.min.css">vim-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim.min.css">vim</option>
        <option value="http://st.pimg.net/tucs/css/sh_whatis.min.css">whatis</option>
        <option value="http://st.pimg.net/tucs/css/sh_whitengrey.min.css">whitengrey</option>
        <option value="http://st.pimg.net/tucs/css/sh_zellner.min.css">zellner</option>
    </select>
</div>



<div class="footer"><div class="cpanstats">78069 Uploads, 24686 Distributions
105893 Modules, 9637 Uploaders
</div>
hosted by <a href="http://www.yellowbot.com">YellowBot</a><br/>
<a href="http://www.yellowbot.com"><img alt="do. tag. write. share." src="http://st.pimg.net/tucs/img/yellowbot_logo.gif"></a>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="http://ipv4.v6test.develooper.com/js/v1/v6test.js"></script>

<script type="text/javascript">
   // v6.target = '';
   if (!v6.target) { v6.only_once = true }
   v6.site = '7A0D89A6-2B82-11DF-B9DA-F61CBD13F020';
   v6.api_server = 'http://ipv4.v6test.develooper.com';
   try {
     v6.test();
   } catch(err) {}
</script>
<script type="text/javascript">
  $(document).ready(function(){
    $("a[href^=http:]").click(function(){
      var href = $(this).attr('href');
      var m = href.match('\/\/([^\/:]+)');
      _gaq.push(['_trackEvent','External',m[1],'Module']);
    });
    $("a[href^=/CPAN/]").click(function(){
      var href = $(this).attr('href');
      _gaq.push(['_trackEvent','Download',href,'Module']);
    });
  });
</script>
<!-- Sun Apr 22 04:39:46 2012 GMT (0.127525806427002) @cpansearch1 -->
 </body>
</html>
