<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <link rel="stylesheet" href="http://st.pimg.net/tucs/style.css" type="text/css" />
<style>
.styleswitch {
  text-align: right;
}
</style>


<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.cookie.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_main.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_perl.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.styleswitch.js"></script>

<link rel="stylesheet" href="http://st.pimg.net/tucs/print.css" type="text/css" media="print" />
  <link rel="alternate" type="application/rss+xml" title="RSS 1.0" href="http://search.cpan.org/uploads.rdf" />
  <link rel="search" href="http://st.pimg.net/tucs/opensearch.xml" type="application/opensearchdescription+xml" title="SearchCPAN" />
  <title>Net::Pcap - search.cpan.org</title>
 <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3528438-1']);
    _gaq.push(["_setCustomVar",2,"Distribution","Net-Pcap",3]);
    _gaq.push(["_setCustomVar",5,"Release","Net-Pcap-0.16",3]);
    _gaq.push(["_setCustomVar",3,"Module","Net::Pcap",3]);
    _gaq.push(["_setCustomVar",1,"Author","SAPER",3]);
    _gaq.push(['_trackPageview']);
  </script>
 </head>
 <body id="cpansearch">
<center><div class="logo"><a href="/"><img src="http://st.pimg.net/tucs/img/cpan_banner.png" alt="CPAN"></a></div></center>
<div class="menubar">
 <a href="/">Home</a>
&middot; <a href="/author/">Authors</a>
&middot; <a href="/recent">Recent</a>
&middot; <a href="http://log.perl.org/cpansearch/">News</a>
&middot; <a href="/mirror">Mirrors</a>
&middot; <a href="/faq.html">FAQ</a>
&middot; <a href="/feedback">Feedback</a>
</div>
<form method="get" action="/search" name="f" class="searchbox">
<input type="text" name="query" value="" size="35">
<br>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</form>


 <a name="_top"></a>
  <div class=path>
<div id=permalink class="noprint"><a href="/perldoc?Net::Pcap">permalink</a></div>
  <a href="/~saper/">S&eacute;bastien Aperghis-Tramoni</a> &gt;
  <a href="/~saper/Net-Pcap-0.16/">Net-Pcap-0.16</a> &gt;
  Net::Pcap
 </div>

<div class="noprint" style="float:right;align:left;width:19ex">
<a href="http://hexten.net/cpan-faces/"><img src="http://www.gravatar.com/avatar/cad36eb4c5da1a39158c9c58b45590bd?r=g&s=80&d=http%3A%2F%2Fst.pimg.net%2Ftucs%2Fimg%2Fwho.png" width=80 height=80 
style="float:right"
/></a>
<br style="clear:both"/>
<p style="text-align:right">Download:<br/> <a href="/CPAN/authors/id/S/SA/SAPER/Net-Pcap-0.16.tar.gz">Net-Pcap-0.16.tar.gz</a></p>
<p style="text-align:right"><a href="http://deps.cpantesters.org/?module=Net%3A%3APcap;perl=latest">Dependencies</a></p>
<p style="text-align:right"><a href="http://www.annocpan.org/~SAPER/Net-Pcap-0.16/Pcap.pm">Annotate this POD
(4)
</a></p>
<div class=box style='width:150px; float: right'>
<h1 class=t5>Related Modules</h1>
<div style="margin:2px">
<a href="/perldoc?IO%3A%3ASocket">IO::Socket</a><br>
<a href="/perldoc?LWP%3A%3AUserAgent">LWP::UserAgent</a><br>
<a href="/perldoc?NetPacket%3A%3AIP">NetPacket::IP</a><br>
<a href="/perldoc?IO%3A%3AFile">IO::File</a><br>
<a href="/perldoc?Net%3A%3APacket">Net::Packet</a><br>
<a href="/perldoc?Time%3A%3AHiRes">Time::HiRes</a><br>
<a href="/perldoc?IO%3A%3ASelect">IO::Select</a><br>
<a href="/perldoc?Tk%3A%3AGraph">Tk::Graph</a><br>
<a href="/perldoc?NetPacket%3A%3AUDP">NetPacket::UDP</a><br>
<a href="/perldoc?XML%3A%3ATwig">XML::Twig</a><br>
<small>
<a href="http://perlmonks.org/?node=cpan+module+search&pivot=1&module=Net%3A%3APcap">more...</a><br>
By <a href="http://perlmonks.org/">perlmonks.org</a></small>
</div>
</div>

<div style="float:right">
<div class=box style='width:150px'>
<h1 class=t5>CPAN RT</h1>
<div style="margin:2px">
<table style="margin-left:auto;margin-right:auto">
<tr><td>New&nbsp;</td><td style="text-align:right"> 8</td></tr>
<tr><td>Open&nbsp;</td><td style="text-align:right"> 9</td></tr>
</table>
<a href="https://rt.cpan.org/Public/Dist/Display.html?Name=Net-Pcap">View/Report Bugs</a><br/>
</div>
</div>

</div>
</div>
  Module Version:  0.16 &nbsp;
<span class="noprint">
  <a href="/src/SAPER/Net-Pcap-0.16/Pcap.pm">Source</a> &nbsp;
</span>
<a name="___top"></a>
<div class=pod>
<div class=toc>
<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#EXPORTS'>EXPORTS</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Lookup_functions'>Lookup functions</a>
    <li class='indexItem indexItem2'><a href='#Packet_capture_functions'>Packet capture functions</a>
    <li class='indexItem indexItem2'><a href='#Savefile_commands'>Savefile commands</a>
    <li class='indexItem indexItem2'><a href='#Status_functions'>Status functions</a>
    <li class='indexItem indexItem2'><a href='#Error_handling'>Error handling</a>
    <li class='indexItem indexItem2'><a href='#Information'>Information</a>
    <li class='indexItem indexItem2'><a href='#WinPcap_specific_functions'>WinPcap specific functions</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CONSTANTS'>CONSTANTS</a>
  <li class='indexItem indexItem1'><a href='#DIAGNOSTICS'>DIAGNOSTICS</a>
  <li class='indexItem indexItem1'><a href='#LIMITATIONS'>LIMITATIONS</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Perl_Modules'>Perl Modules</a>
    <li class='indexItem indexItem2'><a href='#Base_Libraries'>Base Libraries</a>
    <li class='indexItem indexItem2'><a href='#Articles'>Articles</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGEMENTS'>ACKNOWLEDGEMENTS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_&#38;_LICENSE'>COPYRIGHT &#38; LICENSE</a>
</ul>
</div>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Net::Pcap - Interface to pcap(3) LBL packet capture library</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Version 0.16</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl">    use Net::Pcap;

    my $err = &#39;&#39;;
    my $dev = pcap_lookupdev(\$err);  # find a device

    # open the device for live listening
    my $pcap = pcap_open_live($dev, 1024, 1, 0, \$err);

    # loop over next 10 packets
    pcap_loop($pcap, 10, \&#38;process_packet, &#34;just for the demo&#34;);

    # close the device
    pcap_close($pcap);

    sub process_packet {
        my($user_data, $header, $packet) = @_;
        # do something ...
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><code>Net::Pcap</code> is a Perl binding to the LBL pcap(3) library. The README for libpcap describes itself as:</p>

<pre class="sh_perl">  &#34;a system-independent interface for user-level packet capture.
  libpcap provides a portable framework for low-level network
  monitoring.  Applications include network statistics collection,
  security monitoring, network debugging, etc.&#34;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXPORTS"
>EXPORTS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><code>Net::Pcap</code> supports the following <code>Exporter</code> tags:</p>

<ul>
<li><code>:bpf</code> exports a few BPF related constants:
<pre class="sh_perl">    BPF_ALIGNMENT  BPF_MAJOR_VERSION  BPF_MAXBUFSIZE  BPF_MAXINSNS
    BPF_MEMWORDS  BPF_MINBUFSIZE  BPF_MINOR_VERSION  BPF_RELEASE</pre>
</li>

<li><code>:datalink</code> exports the data link types macros:
<pre class="sh_perl">    DLT_AIRONET_HEADER  DLT_APPLE_IP_OVER_IEEE1394  DLT_ARCNET
    DLT_ARCNET_LINUX  DLT_ATM_CLIP  DLT_ATM_RFC1483  DLT_AURORA  DLT_AX25
    DLT_CHAOS  DLT_CHDLC  DLT_CISCO_IOS  DLT_C_HDLC  DLT_DOCSIS  DLT_ECONET
    DLT_EN10MB  DLT_EN3MB  DLT_ENC  DLT_FDDI  DLT_FRELAY  DLT_HHDLC
    DLT_IBM_SN  DLT_IBM_SP  DLT_IEEE802  DLT_IEEE802_11  DLT_IEEE802_11_RADIO
    DLT_IEEE802_11_RADIO_AVS  DLT_IPFILTER  DLT_IP_OVER_FC  DLT_JUNIPER_ATM1
    DLT_JUNIPER_ATM2  DLT_JUNIPER_ES  DLT_JUNIPER_GGSN  DLT_JUNIPER_MFR
    DLT_JUNIPER_MLFR  DLT_JUNIPER_MLPPP  DLT_JUNIPER_MONITOR  DLT_JUNIPER_SERVICES
    DLT_LINUX_IRDA  DLT_LINUX_SLL  DLT_LOOP  DLT_LTALK  DLT_NULL  DLT_OLD_PFLOG
    DLT_PCI_EXP  DLT_PFLOG  DLT_PFSYNC  DLT_PPP  DLT_PPP_BSDOS  DLT_PPP_ETHER
    DLT_PPP_SERIAL  DLT_PRISM_HEADER  DLT_PRONET  DLT_RAW  DLT_RIO  DLT_SLIP
    DLT_SLIP_BSDOS  DLT_SUNATM  DLT_SYMANTEC_FIREWALL  DLT_TZSP  DLT_USER0
    DLT_USER1  DLT_USER2  DLT_USER3  DLT_USER4  DLT_USER5  DLT_USER6  DLT_USER7
    DLT_USER8  DLT_USER9  DLT_USER10  DLT_USER11  DLT_USER12  DLT_USER13
    DLT_USER14  DLT_USER15</pre>
</li>

<li><code>:pcap</code> exports the following <code>pcap</code> constants:
<pre class="sh_perl">    PCAP_ERRBUF_SIZE    PCAP_IF_LOOPBACK
    PCAP_VERSION_MAJOR  PCAP_VERSION_MINOR</pre>
</li>

<li><code>:mode</code> exports the following constants:
<pre class="sh_perl">    MODE_CAPT  MODE_MON  MODE_STAT</pre>
</li>

<li><code>:openflag</code> exports the following constants:
<pre class="sh_perl">    OPENFLAG_PROMISCUOUS  OPENFLAG_DATATX_UDP  OPENFLAG_NOCAPTURE_RPCAP</pre>
</li>

<li><code>:source</code> exports the following constants:
<pre class="sh_perl">    PCAP_SRC_FILE  PCAP_SRC_IFLOCAL  PCAP_SRC_IFREMOTE</pre>
</li>

<li><code>:sample</code> exports the following constants:
<pre class="sh_perl">    PCAP_SAMP_NOSAMP  PCAP_SAMP_1_EVERY_N  PCAP_SAMP_FIRST_AFTER_N_MS</pre>
</li>

<li><code>:rpcap</code> exports the following constants:
<pre class="sh_perl">    RMTAUTH_NULL  RMTAUTH_PWD</pre>
</li>

<li><code>:functions</code> exports the function names with the same names as the C library, so you can write <code>pcap_lookupdev()</code> instead of <code>Net::Pcap::lookupdev()</code> for example. This should also ease porting C programs to Perl.
<p>It also exports short names of the functions (without the <code>&#34;pcap_&#34;</code> prefix) for those which would not cause a clash with an already defined name. Namely, the following functions are not available in short form: <code>open()</code>, <code>close()</code>, <code>next()</code>, <code>dump()</code>, <code>file()</code>, <code>fileno()</code>. Using these short names is now discouraged, and may be removed in the future.</p>
</li>
</ul>

<p>The symbols from the <code>:datalink</code> and <code>:pcap</code> tags are exported by default.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>All functions defined by <code>Net::Pcap</code> are direct mappings to the libpcap functions. Consult the pcap(3) documentation and source code for more information.</p>

<p>Arguments that change a parameter, for example <code>pcap_lookupdev()</code>, are passed that parameter as a reference. This is to retain compatibility with previous versions of <code>Net::Pcap</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Lookup_functions"
>Lookup functions</a></h2>

<dl>
<dt><a name='pcap_lookupdev'></a><a name="pcap_lookupdev(\$err)"
><b>pcap_lookupdev(\$err)</b></a></dt>

<dd>
<p>Returns the name of a network device that can be used with <code>pcap_open_live()</code> function. On error, the <code>$err</code> parameter is filled with an appropriate error message else it is undefined.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    $dev = pcap_lookupdev();</pre>

<dt><a name='pcap_findalldevs'></a><a name="pcap_findalldevs(\%devinfo,_\$err)"
><b>pcap_findalldevs(\%devinfo, \$err)</b></a></dt>

<dd>
<p>Returns a list of all network device names that can be used with <code>pcap_open_live()</code> function. On error, the <code>$err</code> parameter is filled with an appropriate error message else it is undefined.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    @devs = pcap_findalldevs(\%devinfo, \$err);
    for my $dev (@devs) {
        print &#34;$dev : $devinfo{$dev}\n&#34;
    }</pre>

<dl>
<dt><a name="Note"
><b>Note</b></a></dt>

<dd>
<p>For backward compatibility reasons, this function can also be called using the following signatures:</p>

<pre class="sh_perl">    @devs = pcap_findalldevs(\$err);

    @devs = pcap_findalldevs(\$err, \%devinfo);</pre>

<p>The first form was introduced by Marco Carnut in <code>Net::Pcap</code> version 0.05 and kept intact in versions 0.06 and 0.07. The second form was introduced by Jean-Louis Morel for the Windows only, ActivePerl port of <code>Net::Pcap</code>, in versions 0.04.01 and 0.04.02.</p>

<p>The new syntax has been introduced for consistency with the rest of the Perl API and the C API of <code>libpcap(3)</code>, where <code>$err</code> is always the last argument.</p>
</dd>
</dl>

<dt><a name='pcap_lookupnet'></a><a name="pcap_lookupnet($dev,_\$net,_\$mask,_\$err)"
><b>pcap_lookupnet($dev, \$net, \$mask, \$err)</b></a></dt>

<dd>
<p>Determine the network number and netmask for the device specified in <code>$dev</code>. The function returns 0 on success and sets the <code>$net</code> and <code>$mask</code> parameters with values. On failure it returns -1 and the <code>$err</code> parameter is filled with an appropriate error message.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Packet_capture_functions"
>Packet capture functions</a></h2>

<dl>
<dt><a name='pcap_open_live'></a><a name="pcap_open_live($dev,_$snaplen,_$promisc,_$to_ms,_\$err)"
><b>pcap_open_live($dev, $snaplen, $promisc, $to_ms, \$err)</b></a></dt>

<dd>
<p>Returns a packet capture descriptor for looking at packets on the network. The <code>$dev</code> parameter specifies which network interface to capture packets from. The <code>$snaplen</code> and <code>$promisc</code> parameters specify the maximum number of bytes to capture from each packet, and whether to put the interface into promiscuous mode, respectively. The <code>$to_ms</code> parameter specifies a read timeout in milliseconds. The packet descriptor will be undefined if an error occurs, and the <code>$err</code> parameter will be set with an appropriate error message.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    $dev = pcap_lookupdev();
    $pcap = pcap_open_live($dev, 1024, 1, 0, \$err)
        or die &#34;Can&#39;t open device $dev: $err\n&#34;;</pre>

<dt><a name='pcap_open_dead'></a><a name="pcap_open_dead($linktype,_$snaplen)"
><b>pcap_open_dead($linktype, $snaplen)</b></a></dt>

<dd>
<p>Creates and returns a new packet descriptor to use when calling the other functions in <code>libpcap</code>. It is typically used when just using <code>libpcap</code> for compiling BPF code.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    $pcap = pcap_open_dead(0, 1024);</pre>

<dt><a name='pcap_open_offline'></a><a name="pcap_open_offline($filename,_\$err)"
><b>pcap_open_offline($filename, \$err)</b></a></dt>

<dd>
<p>Return a packet capture descriptor to read from a previously created &#34;savefile&#34;. The returned descriptor is undefined if there was an error and in this case the <code>$err</code> parameter will be filled. Savefiles are created using the <code>pcap_dump_*</code> commands.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    $pcap = pcap_open_offline($dump, \$err)
        or die &#34;Can&#39;t read &#39;$dump&#39;: $err\n&#34;;</pre>

<dt><a name='pcap_loop'></a><a name="pcap_loop($pcap,_$count,_\&#38;callback,_$user_data)"
><b>pcap_loop($pcap, $count, \&#38;callback, $user_data)</b></a></dt>

<dd>
<p>Read <code>$count</code> packets from the packet capture descriptor <code>$pcap</code> and call the perl function <code>&#38;callback</code> with an argument of <code>$user_data</code>. If <code>$count</code> is negative, then the function loops forever or until an error occurs. Returns 0 if <code>$count</code> is exhausted, -1 on error, and -2 if the loop terminated due to a call to pcap_breakloop() before any packets were processed.</p>

<p>The callback function is also passed packet header information and packet data like so:</p>

<pre class="sh_perl">    sub process_packet {
        my($user_data, $header, $packet) = @_;

        ...
    }</pre>

<p>The header information is a reference to a hash containing the following fields.</p>

<ul>
<li><code>len</code> - the total length of the packet.</li>

<li><code>caplen</code> - the actual captured length of the packet data. This corresponds to the snapshot length parameter passed to <code>open_live()</code>.</li>

<li><code>tv_sec</code> - seconds value of the packet timestamp.</li>

<li><code>tv_usec</code> - microseconds value of the packet timestamp.</li>
</ul>

<p><b>Example</b></p>

<pre class="sh_perl">    pcap_loop($pcap, 10, \&#38;process_packet, &#34;user data&#34;);

    sub process_packet {
        my($user_data, $header, $packet) = @_;
        # ...
    }</pre>

<dt><a name='pcap_breakloop'></a><a name="pcap_breakloop($pcap)"
><b>pcap_breakloop($pcap)</b></a></dt>

<dd>
<p>Sets a flag that will force <code>pcap_dispatch()</code> or <code>pcap_loop()</code> to return rather than looping; they will return the number of packets that have been processed so far, or -2 if no packets have been processed so far.</p>

<p>This routine is safe to use inside a signal handler on UNIX or a console control handler on Windows, as it merely sets a flag that is checked within the loop.</p>

<p>Please see the section on <code>pcap_breakloop()</code> in <a href="http://man.he.net/man3/pcap" class="podlinkman"
>pcap(3)</a> for more information.</p>

<dt><a name='pcap_close'></a><a name="pcap_close($pcap)"
><b>pcap_close($pcap)</b></a></dt>

<dd>
<p>Close the packet capture device associated with the descriptor <code>$pcap</code>.</p>

<dt><a name='pcap_dispatch'></a><a name="pcap_dispatch($pcap,_$count,_\&#38;callback,_$user_data)"
><b>pcap_dispatch($pcap, $count, \&#38;callback, $user_data)</b></a></dt>

<dd>
<p>Collect <code>$count</code> packets and process them with callback function <code>&#38;callback</code>. if <code>$count</code> is -1, all packets currently buffered are processed. If <code>$count</code> is 0, process all packets until an error occurs.</p>

<dt><a name='pcap_next'></a><a name="pcap_next($pcap,_\%header)"
><b>pcap_next($pcap, \%header)</b></a></dt>

<dd>
<p>Return the next available packet on the interface associated with packet descriptor <code>$pcap</code>. Into the <code>%header</code> hash is stored the received packet header. If not packet is available, the return value and header is undefined.</p>

<dt><a name='pcap_next_ex'></a><a name="pcap_next_ex($pcap,_\%header,_\$packet)"
><b>pcap_next_ex($pcap, \%header, \$packet)</b></a></dt>

<dd>
<p>Reads the next available packet on the interface associated with packet descriptor <code>$pcap</code>, stores its header in <code>\%header</code> and its data in <code>\$packet</code> and returns a success/failure indication:</p>

<ul>
<li><code>1</code> means that the packet was read without problems;</li>

<li><code>0</code> means that packets are being read from a live capture, and the timeout expired;</li>

<li><code>-1</code> means that an error occurred while reading the packet;</li>

<li><code>-2</code> packets are being read from a dump file, and there are no more packets to read from the savefile.</li>
</ul>

<dt><a name='pcap_compile'></a><a name="pcap_compile($pcap,_\$filter,_$filter_str,_$optimize,_$netmask)"
><b>pcap_compile($pcap, \$filter, $filter_str, $optimize, $netmask)</b></a></dt>

<dd>
<p>Compile the filter string contained in <code>$filter_str</code> and store it in <code>$filter</code>. A description of the filter language can be found in the libpcap source code, or the manual page for tcpdump(8) . The filter is optimized if the <code>$optimize</code> variable is true. The netmask of the network device must be specified in the <code>$netmask</code> parameter. The function returns 0 if the compilation was successful, or -1 if there was a problem.</p>

<dt><a name='pcap_compile_nopcap'></a><a name="pcap_compile_nopcap($snaplen,_$linktype,_\$filter,_$filter_str,_$optimize,_$netmask)"
><b>pcap_compile_nopcap($snaplen, $linktype, \$filter, $filter_str, $optimize, $netmask)</b></a></dt>

<dd>
<p>Similar to <code>compile()</code> except that instead of passing a <code>$pcap</code> descriptor, one passes <code>$snaplen</code> and <code>$linktype</code> directly. Returns -1 if there was an error, but the error message is not available.</p>

<dt><a name='pcap_setfilter'></a><a name="pcap_setfilter($pcap,_$filter)"
><b>pcap_setfilter($pcap, $filter)</b></a></dt>

<dd>
<p>Associate the compiled filter stored in <code>$filter</code> with the packet capture descriptor <code>$pcap</code>.</p>

<dt><a name='pcap_freecode'></a><a name="pcap_freecode($filter)"
><b>pcap_freecode($filter)</b></a></dt>

<dd>
<p>Used to free the allocated memory used by a compiled filter, as created by <code>pcap_compile()</code>.</p>

<dt><a name='pcap_setnonblock'></a><a name="pcap_setnonblock($pcap,_$mode,_\$err)"
><b>pcap_setnonblock($pcap, $mode, \$err)</b></a></dt>

<dd>
<p>Set the <i>non-blocking</i> mode of a live capture descriptor, depending on the value of <code>$mode</code> (zero to activate and non-zero to deactivate). It has no effect on offline descriptors. If there is an error, it returns -1 and sets <code>$err</code>.</p>

<p>In non-blocking mode, an attempt to read from the capture descriptor with <code>pcap_dispatch()</code> will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive. <code>pcap_loop()</code> and <code>pcap_next()</code> will not work in non-blocking mode.</p>

<dt><a name='pcap_getnonblock'></a><a name="pcap_getnonblock($pcap,_\$err)"
><b>pcap_getnonblock($pcap, \$err)</b></a></dt>

<dd>
<p>Returns the <i>non-blocking</i> state of the capture descriptor <code>$pcap</code>. Always returns 0 on savefiles. If there is an error, it returns -1 and sets <code>$err</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Savefile_commands"
>Savefile commands</a></h2>

<dl>
<dt><a name='pcap_dump_open'></a><a name="pcap_dump_open($pcap,_$filename)"
><b>pcap_dump_open($pcap, $filename)</b></a></dt>

<dd>
<p>Open a savefile for writing and return a descriptor for doing so. If <code>$filename</code> is <code>&#34;-&#34;</code> data is written to standard output. On error, the return value is undefined and <code>pcap_geterr()</code> can be used to retrieve the error text.</p>

<dt><a name='pcap_dump'></a><a name="pcap_dump($dumper,_\%header,_$packet)"
><b>pcap_dump($dumper, \%header, $packet)</b></a></dt>

<dd>
<p>Dump the packet described by header <code>%header</code> and packet data <code>$packet</code> to the savefile associated with <code>$dumper</code>. The packet header has the same format as that passed to the <code>pcap_loop()</code> callback.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    my $dump_file = &#39;network.dmp&#39;;
    my $dev = pcap_lookupdev();
    my $pcap = pcap_open_live($dev, 1024, 1, 0, \$err);

    my $dumper = pcap_dump_open($pcap, $dump_file);
    pcap_loop($pcap, 10, \&#38;process_packet, &#39;&#39;);
    pcap_dump_close($dumper);

    sub process_packet {
        my($user_data, $header, $packet) = @_;
        pcap_dump($dumper, $header, $packet);
    }</pre>

<dt><a name='pcap_dump_file'></a><a name="pcap_dump_file($dumper)"
><b>pcap_dump_file($dumper)</b></a></dt>

<dd>
<p>Returns the filehandle associated with a savefile opened with <code>pcap_dump_open()</code>.</p>

<dt><a name='pcap_dump_flush'></a><a name="pcap_dump_flush($dumper)"
><b>pcap_dump_flush($dumper)</b></a></dt>

<dd>
<p>Flushes the output buffer to the corresponding save file, so that any packets written with <code>pcap_dump()</code> but not yet written to the save file will be written. Returns -1 on error, 0 on success.</p>

<dt><a name='pcap_dump_close'></a><a name="pcap_dump_close($dumper)"
><b>pcap_dump_close($dumper)</b></a></dt>

<dd>
<p>Close the savefile associated with the descriptor <code>$dumper</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Status_functions"
>Status functions</a></h2>

<dl>
<dt><a name='pcap_datalink'></a><a name="pcap_datalink($pcap)"
><b>pcap_datalink($pcap)</b></a></dt>

<dd>
<p>Returns the link layer type associated with the given pcap descriptor.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    $linktype = pcap_datalink($pcap);</pre>

<dt><a name='pcap_set_datalink'></a><a name="pcap_set_datalink($pcap,_$linktype)"
><b>pcap_set_datalink($pcap, $linktype)</b></a></dt>

<dd>
<p>Sets the data link type of the given pcap descriptor to the type specified by <code>$linktype</code>. Returns -1 on failure.</p>

<dt><a name='pcap_datalink_name_to_val'></a><a name="pcap_datalink_name_to_val($name)"
><b>pcap_datalink_name_to_val($name)</b></a></dt>

<dd>
<p>Translates a data link type name, which is a <code>DLT_</code> name with the <code>DLT_</code> part removed, to the corresponding data link type value. The translation is case-insensitive. Returns -1 on failure.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    $linktype = pcap_datalink_name_to_val(&#39;LTalk&#39;);  # returns DLT_LTALK</pre>

<dt><a name='pcap_datalink_val_to_name'></a><a name="pcap_datalink_val_to_name($linktype)"
><b>pcap_datalink_val_to_name($linktype)</b></a></dt>

<dd>
<p>Translates a data link type value to the corresponding data link type name.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    $name = pcap_datalink_val_to_name(DLT_LTALK);  # returns &#39;LTALK&#39;</pre>

<dt><a name='pcap_datalink_val_to_description'></a><a name="pcap_datalink_val_to_description($linktype)"
><b>pcap_datalink_val_to_description($linktype)</b></a></dt>

<dd>
<p>Translates a data link type value to a short description of that data link type.</p>

<p><b>Example</b></p>

<pre class="sh_perl">    $descr = pcap_datalink_val_to_description(DLT_LTALK);  # returns &#39;Localtalk&#39;</pre>

<dt><a name='pcap_snapshot'></a><a name="pcap_snapshot($pcap)"
><b>pcap_snapshot($pcap)</b></a></dt>

<dd>
<p>Returns the snapshot length (snaplen) specified in the call to <code>pcap_open_live()</code>.</p>

<dt><a name='pcap_is_swapped'></a><a name="pcap_is_swapped($pcap)"
><b>pcap_is_swapped($pcap)</b></a></dt>

<dd>
<p>This function returns true if the endianness of the currently open savefile is different from the endianness of the machine.</p>

<dt><a name='pcap_major_version'></a><a name="pcap_major_version($pcap)"
><b>pcap_major_version($pcap)</b></a></dt>

<dd>
<p>Return the major version number of the pcap library used to write the currently open savefile.</p>

<dt><a name='pcap_minor_version'></a><a name="pcap_minor_version($pcap)"
><b>pcap_minor_version($pcap)</b></a></dt>

<dd>
<p>Return the minor version of the pcap library used to write the currently open savefile.</p>

<dt><a name='pcap_stats'></a><a name="pcap_stats($pcap,_\%stats)"
><b>pcap_stats($pcap, \%stats)</b></a></dt>

<dd>
<p>Returns a hash containing information about the status of packet capture device <code>$pcap</code>. The hash contains the following fields.</p>

<p>This function is supported only on live captures, not on savefiles; no statistics are stored in savefiles, so no statistics are available when reading from a savefile.</p>

<ul>
<li><code>ps_recv</code> - the number of packets received by the packet capture software.</li>

<li><code>ps_drop</code> - the number of packets dropped by the packet capture software.</li>

<li><code>ps_ifdrop</code> - the number of packets dropped by the network interface.</li>
</ul>

<dt><a name='pcap_file'></a><a name="pcap_file($pcap)"
><b>pcap_file($pcap)</b></a></dt>

<dd>
<p>Returns the filehandle associated with a savefile opened with <code>pcap_open_offline()</code> or <code>undef</code> if the device was opened with <code>pcap_open_live()</code>.</p>

<dt><a name='pcap_fileno'></a><a name="pcap_fileno($pcap)"
><b>pcap_fileno($pcap)</b></a></dt>

<dd>
<p>Returns the file number of the network device opened with <code>pcap_open_live()</code>.</p>

<dt><a name='pcap_get_selectable_fd'></a><a name="pcap_get_selectable_fd($pcap)"
><b>pcap_get_selectable_fd($pcap)</b></a></dt>

<dd>
<p>Returns, on Unix, a file descriptor number for a file descriptor on which one can do a <code>select()</code> or <code>poll()</code> to wait for it to be possible to read packets without blocking, if such a descriptor exists, or -1, if no such descriptor exists. Some network devices opened with <code>pcap_open_live()</code> do not support <code>select()</code> or <code>poll()</code>, so -1 is returned for those devices. See <a href="http://man.he.net/man3/pcap" class="podlinkman"
>pcap(3)</a> for more details.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Error_handling"
>Error handling</a></h2>

<dl>
<dt><a name='pcap_geterr'></a><a name="pcap_geterr($pcap)"
><b>pcap_geterr($pcap)</b></a></dt>

<dd>
<p>Returns an error message for the last error associated with the packet capture device <code>$pcap</code>.</p>

<dt><a name='pcap_strerror'></a><a name="pcap_strerror($errno)"
><b>pcap_strerror($errno)</b></a></dt>

<dd>
<p>Returns a string describing error number <code>$errno</code>.</p>

<dt><a name='pcap_perror'></a><a name="pcap_perror($pcap,_$prefix)"
><b>pcap_perror($pcap, $prefix)</b></a></dt>

<dd>
<p>Prints the text of the last error associated with descriptor <code>$pcap</code> on standard error, prefixed by <code>$prefix</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Information"
>Information</a></h2>

<dl>
<dt><a name='pcap_lib_version'></a><a name="pcap_lib_version()"
><b>pcap_lib_version()</b></a></dt>

<dd>
<p>Returns the name and version of the <code>pcap</code> library the module was linked against.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="WinPcap_specific_functions"
>WinPcap specific functions</a></h2>

<p>The following functions are only available with WinPcap, the Win32 port of the Pcap library. If a called function is not available, it will cleanly <code>croak()</code>.</p>

<dl>
<dt><a name='pcap_createsrcstr'></a><a name="pcap_createsrcstr(\$source,_$type,_$host,_$port,_$name,_\$err)"
><b>pcap_createsrcstr(\$source, $type, $host, $port, $name, \$err)</b></a></dt>

<dd>
<p>Accepts a set of strings (host name, port, ...), and stores the complete source string according to the new format (e.g. <code>&#34;<a href="rpcap://1.2.3.4/eth0" class="podlinkurl"
>rpcap://1.2.3.4/eth0</a>&#34;</code>) in <code>$source</code>.</p>

<p>This function is provided in order to help the user creating the source string according to the new format. An unique source string is used in order to make easy for old applications to use the remote facilities. Think about <b>tcpdump(1)</b>, for example, which has only one way to specify the interface on which the capture has to be started. However, GUI-based programs can find more useful to specify hostname, port and interface name separately. In that case, they can use this function to create the source string before passing it to the <code>pcap_open()</code> function.</p>

<p>Returns 0 if everything is fine, -1 if some errors occurred. The string containing the complete source is returned in the <code>$source</code> variable.</p>

<dt><a name='pcap_parsesrcstr'></a><a name="pcap_parsesrcstr($source,_\$type,_\$host,_\$port,_\$name,_\$err)"
><b>pcap_parsesrcstr($source, \$type, \$host, \$port, \$name, \$err)</b></a></dt>

<dd>
<p>Parse the source string and stores the pieces in which the source can be split in the corresponding variables.</p>

<p>This call is the other way round of <code>pcap_createsrcstr()</code>. It accepts a null-terminated string and it returns the parameters related to the source. This includes:</p>

<ul>
<li>the type of the source (file, WinPcap on a remote adapter, WinPcap on local adapter), which is determined by the source prefix (<code>PCAP_SRC_IF_STRING</code> and so on);</li>

<li>the host on which the capture has to be started (only for remote captures);</li>

<li>the raw name of the source (file name, name of the remote adapter, name of the local adapter), without the source prefix. The string returned does not include the type of the source itself (i.e. the string returned does not include <code>&#34;file://&#34;</code> or <code>&#34;rpcap://&#34;</code> or such).</li>
</ul>

<p>The user can omit some parameters in case it is not interested in them.</p>

<p>Returns 0 if everything is fine, -1 if some errors occurred. The requested values (host name, network port, type of the source) are returned into the proper variables passed by reference.</p>

<dt><a name='pcap_open'></a><a name="pcap_open($source,_$snaplen,_$flags,_$read_timeout,_\$auth,_\$err)"
><b>pcap_open($source, $snaplen, $flags, $read_timeout, \$auth, \$err)</b></a></dt>

<dd>
<p>Open a generic source in order to capture / send (WinPcap only) traffic.</p>

<p>The <code>pcap_open()</code> replaces all the <code>pcap_open_xxx()</code> functions with a single call.</p>

<p>This function hides the differences between the different <code>pcap_open_xxx()</code> functions so that the programmer does not have to manage different opening function. In this way, the <i>true</i> <code>open()</code> function is decided according to the source type, which is included into the source string (in the form of source prefix).</p>

<p>Returns a pointer to a pcap descriptor which can be used as a parameter to the following calls (<code>compile()</code> and so on) and that specifies an opened WinPcap session. In case of problems, it returns <code>undef</code> and the <code>$err</code> variable keeps the error message.</p>

<dt><a name='pcap_setbuff'></a><a name="pcap_setbuff($pcap,_$dim)"
><b>pcap_setbuff($pcap, $dim)</b></a></dt>

<dd>
<p>Sets the size of the kernel buffer associated with an adapter. <code>$dim</code> specifies the size of the buffer in bytes. The return value is 0 when the call succeeds, -1 otherwise.</p>

<p>If an old buffer was already created with a previous call to <code>setbuff()</code>, it is deleted and its content is discarded. <code>open_live()</code> creates a 1&#160;MB buffer by default.</p>

<dt><a name='pcap_setmode'></a><a name="pcap_setmode($pcap,_$mode)"
><b>pcap_setmode($pcap, $mode)</b></a></dt>

<dd>
<p>Sets the working mode of the interface <code>$pcap</code> to <code>$mode</code>. Valid values for <code>$mode</code> are <code>MODE_CAPT</code> (default capture mode) and <code>MODE_STAT</code> (statistical mode).</p>

<dt><a name='pcap_setmintocopy'></a><a name="pcap_setmintocopy($pcap_t,_$size)"
><b>pcap_setmintocopy($pcap_t, $size)</b></a></dt>

<dd>
<p>Changes the minimum amount of data in the kernel buffer that causes a read from the application to return (unless the timeout expires).</p>

<dt><a name='pcap_getevent'></a><a name="pcap_getevent($pcap)"
><b>pcap_getevent($pcap)</b></a></dt>

<dd>
<p>Returns the <code>Win32::Event</code> object associated with the interface <code>$pcap</code>. Can be used to wait until the driver&#39;s buffer contains some data without performing a read. See <a href="/perldoc?Win32%3A%3AEvent" class="podlinkpod"
>Win32::Event</a>.</p>

<dt><a name='pcap_sendpacket'></a><a name="pcap_sendpacket($pcap,_$packet)"
><b>pcap_sendpacket($pcap, $packet)</b></a></dt>

<dd>
<p>Send a raw packet to the network. <code>$pcap</code> is the interface that will be used to send the packet, <code>$packet</code> contains the data of the packet to send (including the various protocol headers). The MAC CRC doesn&#39;t need to be included, because it is transparently calculated and added by the network interface driver. The return value is 0 if the packet is successfully sent, -1 otherwise.</p>

<dt><a name='pcap_sendqueue_alloc'></a><a name="pcap_sendqueue_alloc($memsize)"
><b>pcap_sendqueue_alloc($memsize)</b></a></dt>

<dd>
<p>This function allocates and returns a send queue, i.e. a buffer containing a set of raw packets that will be transmitted on the network with <code>sendqueue_transmit()</code>.</p>

<p><code>$memsize</code> is the size, in bytes, of the queue, therefore it determines the maximum amount of data that the queue will contain. This memory is automatically deallocated when the queue ceases to exist.</p>

<dt><a name='pcap_sendqueue_queue'></a><a name="pcap_sendqueue_queue($queue,_\%header,_$packet)"
><b>pcap_sendqueue_queue($queue, \%header, $packet)</b></a></dt>

<dd>
<p>Adds a packet at the end of the send queue pointed by <code>$queue</code>. The packet header <code>%header</code> has the same format as that passed to the <code>loop()</code> callback. <code>$ackekt</code> is a buffer with the data of the packet.</p>

<p>The <code>%headerr</code> header structure is the same used by WinPcap and libpcap to store the packets in a file, therefore sending a capture file is straightforward. &#34;Raw packet&#34; means that the sending application will have to include the protocol headers, since every packet is sent to the network <i>as is</i>. The CRC of the packets needs not to be calculated, because it will be transparently added by the network interface.</p>

<dt><a name='pcap_sendqueue_transmit'></a><a name="pcap_sendqueue_transmit($pcap,_$queue,_$sync)"
><b>pcap_sendqueue_transmit($pcap, $queue, $sync)</b></a></dt>

<dd>
<p>This function transmits the content of a queue to the wire. <code>$pcapt</code> is the interface on which the packets will be sent, <code>$queue</code> is to a <code>send_queue</code> containing the packets to send, <code>$sync</code> determines if the send operation must be synchronized: if it is non-zero, the packets are sent respecting the timestamps, otherwise they are sent as fast as possible.</p>

<p>The return value is the amount of bytes actually sent. If it is smaller than the size parameter, an error occurred during the send. The error can be caused by a driver/adapter problem or by an inconsistent/bogus send queue.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONSTANTS"
>CONSTANTS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><code>Net::Pcap</code> exports by default the names of several constants in order to ease the development of programs. See <a href="#EXPORTS" class="podlinkpod"
>&#34;EXPORTS&#34;</a> for details about which constants are exported.</p>

<p>Here are the descriptions of a few data link types. See <a href="http://man.he.net/man3/pcap" class="podlinkman"
>pcap(3)</a> for a more complete description and semantics associated with each data link.</p>

<ul>
<li><code>DLT_NULL</code> - BSD loopback encapsulation</li>

<li><code>DLT_EN10MB</code> - Ethernet (10Mb, 100Mb, 1000Mb, and up)</li>

<li><code>DLT_RAW</code> - raw IP</li>

<li><code>DLT_IEEE802</code> - IEEE 802.5 Token Ring</li>

<li><code>DLT_IEEE802_11</code> - IEEE 802.11 wireless LAN</li>

<li><code>DLT_FRELAY</code> - Frame Relay</li>

<li><code>DLT_FDDI</code> - FDDI</li>

<li><code>DLT_SLIP</code> - Serial Line IP</li>

<li><code>DLT_PPP</code> - PPP (Point-to-point Protocol)</li>

<li><code>DLT_PPP_SERIAL</code> - PPP over serial with HDLC encapsulation</li>

<li><code>DLT_PPP_ETHER</code> - PPP over Ethernet</li>

<li><code>DLT_IP_OVER_FC</code> - RFC 2625 IP-over-Fibre Channel</li>

<li><code>DLT_AX25</code> - Amateur Radio AX.25</li>

<li><code>DLT_LINUX_IRDA</code> - Linux-IrDA</li>

<li><code>DLT_LTALK</code> - Apple LocalTalk</li>

<li><code>DLT_APPLE_IP_OVER_IEEE1394</code> - Apple IP-over-IEEE 1394 (a.k.a. Firewire)</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DIAGNOSTICS"
>DIAGNOSTICS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<dl>
<dt><a name='arg'></a><a name="arg%d_not_a_scalar_ref"
><code>arg%d not a scalar ref</code></a></dt>

<dd>
<dt><a name='arg'></a><a name="arg%d_not_a_hash_ref"
><code>arg%d not a hash ref</code></a></dt>

<dd>
<dt><a name='arg'></a><a name="arg%d_not_a_reference"
><code>arg%d not a reference</code></a></dt>

<dd>
<p><b>(F)</b> These errors occur if you forgot to give a reference to a function which expect one or more of its arguments to be references.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LIMITATIONS"
>LIMITATIONS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>The following limitations apply to this version of <code>Net::Pcap</code>.</p>

<ul>
<li>At present, only one callback function and user data scalar can be current at any time as they are both stored in global variables.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Please report any bugs or feature requests to <code>bug-Net-Pcap@rt.cpan.org</code>, or through the web interface at <a href="https://rt.cpan.org/NoAuth/Bugs.html?Dist=Net-Pcap" class="podlinkurl"
>https://rt.cpan.org/NoAuth/Bugs.html?Dist=Net-Pcap</a>. I will be notified, and then you&#39;ll automatically be notified of progress on your bug as I make changes.</p>

<p>Currently known bugs:</p>

<ul>
<li>the <code>ps_recv</code> field is not correctly set; see <em>t/07-stats.t</em></li>

<li><code>pcap_file()</code> seems to always returns <code>undef</code> for live connection and causes segmentation fault for dump files; see <em>t/10-fileno.t</em></li>

<li><code>pcap_fileno()</code> is documented to return -1 when called on save file, but seems to always return an actual file number. See <em>t/10-fileno.t</em></li>

<li><code>pcap_dump_file()</code> seems to corrupt something somewhere, and makes scripts dump core. See <em>t/05-dump.t</em></li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>See the <em>eg/</em> and <em>t/</em> directories of the <code>Net::Pcap</code> distribution for examples on using this module.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Perl_Modules"
>Perl Modules</a></h2>

<p><a href="/perldoc?Net%3A%3APcap%3A%3AReassemble" class="podlinkpod"
>Net::Pcap::Reassemble</a> for reassembly of TCP/IP fragments.</p>

<p><a href="/perldoc?POE%3A%3AComponent%3A%3APcap" class="podlinkpod"
>POE::Component::Pcap</a> for using <code><a href="/~saper/Net-Pcap-0.16/Pcap.pm" class="podlinkpod"
>Net::Pcap</a></code> within POE-based programs.</p>

<p><a href="/perldoc?Net%3A%3APacket" class="podlinkpod"
>Net::Packet</a> or <a href="/perldoc?NetPacket" class="podlinkpod"
>NetPacket</a> for decoding and creating network packets.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Base_Libraries"
>Base Libraries</a></h2>

<p><a href="http://man.he.net/man3/pcap" class="podlinkman"
>pcap(3)</a>, <a href="http://man.he.net/man8/tcpdump" class="podlinkman"
>tcpdump(8)</a></p>

<p>The source code for the <code>pcap(3)</code> library is available from <a href="http://www.tcpdump.org/" class="podlinkurl"
>http://www.tcpdump.org/</a></p>

<p>The source code and binary for the Win32 version of the pcap library, WinPcap, is available from <a href="http://www.winpcap.org/" class="podlinkurl"
>http://www.winpcap.org/</a></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Articles"
>Articles</a></h2>

<p><i>Hacking Linux Exposed: Sniffing with <a href="/~saper/Net-Pcap-0.16/Pcap.pm" class="podlinkpod"
>Net::Pcap</a> to stealthily managing iptables rules remotely</i>, <a href="http://www.hackinglinuxexposed.com/articles/20030730.html" class="podlinkurl"
>http://www.hackinglinuxexposed.com/articles/20030730.html</a></p>

<p><i>PerlMonks node about <a href="/~saper/Net-Pcap-0.16/Pcap.pm" class="podlinkpod"
>Net::Pcap</a></i>, <a href="http://perlmonks.org/?node_id=170648" class="podlinkurl"
>http://perlmonks.org/?node_id=170648</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Current maintainer is S&#233;bastien Aperghis-Tramoni (SAPER) &#60;sebastien@aperghis.net&#62; with the help of Jean-Louis Morel (JLMOREL) &#60;jl_morel@bribes.org&#62; for WinPcap support.</p>

<p>Previous authors &#38; maintainers:</p>

<ul>
<li>Marco Carnut (KCARNUT) &#60;kiko@tempest.com.br&#62;</li>

<li>Tim Potter (TIMPOTTER) &#60;tpot@frungy.org&#62;</li>

<li>Bo Adler (BOADLER) &#60;thumper@alumni.caltech.edu&#62;</li>

<li>Peter Lister (PLISTER) &#60;p.lister@cranfield.ac.uk&#62;</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGEMENTS"
>ACKNOWLEDGEMENTS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>To Paul Johnson for his module <code>Devel::Cover</code> and his patience for helping me using it with XS code, which revealed very useful for writing more tests.</p>

<p>To the beta-testers: Jean-Louis Morel, Max Maischen, Philippe Bruhat, David Morel, Scott Lanning, Rafael Garcia-Suarez, Karl Y. Pradene.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_&#38;_LICENSE"
>COPYRIGHT &#38; LICENSE <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Copyright (C) 2005, 2006, 2007, 2008 S&#233;bastien Aperghis-Tramoni. All rights reserved.</p>

<p>Copyright (C) 2003 Marco Carnut. All rights reserved.</p>

<p>Copyright (C) 1999, 2000 Tim Potter. All rights reserved.</p>

<p>Copyright (C) 1998 Bo Adler. All rights reserved.</p>

<p>Copyright (C) 1997 Peter Lister. All rights reserved.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

</div>
<!-- This should probably be put in the <div class="footer"></div> -->
<script type="text/javascript">
    $(document).ready(function(){
        var startingStyle = $.cookie('css') ? $.cookie('css') : 'http://st.pimg.net/tucs/css/sh_none.min.css';
        $.fn.styleSwitch(startingStyle);
        $("#styleswitch").val(startingStyle);
        sh_highlightDocument();
        $("#styleswitch").bind(($.browser.msie ? "click" : "change"), function() {
            $.fn.styleSwitch($(this).val());
        });
    });
</script>
<div class="styleswitch">
    syntax highlighting:
    <select id="styleswitch">
        <option value="http://st.pimg.net/tucs/css/sh_none.min.css">no syntax highlighting</option>
        <option value="http://st.pimg.net/tucs/css/sh_acid.min.css">acid</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-dark.min.css">berries-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-light.min.css">berries-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_bipolar.min.css">bipolar</option>
        <option value="http://st.pimg.net/tucs/css/sh_blacknblue.min.css">blacknblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_bright.min.css">bright</option>
        <option value="http://st.pimg.net/tucs/css/sh_contrast.min.css">contrast</option>
        <option value="http://st.pimg.net/tucs/css/sh_cpan.min.css">cpan</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkblue.min.css">darkblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkness.min.css">darkness</option>
        <option value="http://st.pimg.net/tucs/css/sh_desert.min.css">desert</option>
        <option value="http://st.pimg.net/tucs/css/sh_dull.min.css">dull</option>
        <option value="http://st.pimg.net/tucs/css/sh_easter.min.css">easter</option>
        <option value="http://st.pimg.net/tucs/css/sh_emacs.min.css">emacs</option>
        <option value="http://st.pimg.net/tucs/css/sh_golden.min.css">golden</option>
        <option value="http://st.pimg.net/tucs/css/sh_greenlcd.min.css">greenlcd</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-anjuta.min.css">ide-anjuta</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-codewarrior.min.css">ide-codewarrior</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-devcpp.min.css">ide-devcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-eclipse.min.css">ide-eclipse</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-kdev.min.css">ide-kdev</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-msvcpp.min.css">ide-msvcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_kwrite.min.css">kwrite</option>
        <option value="http://st.pimg.net/tucs/css/sh_matlab.min.css">matlab</option>
        <option value="http://st.pimg.net/tucs/css/sh_navy.min.css">navy</option>
        <option value="http://st.pimg.net/tucs/css/sh_nedit.min.css">nedit</option>
        <option value="http://st.pimg.net/tucs/css/sh_neon.min.css">neon</option>
        <option value="http://st.pimg.net/tucs/css/sh_night.min.css">night</option>
        <option value="http://st.pimg.net/tucs/css/sh_pablo.min.css">pablo</option>
        <option value="http://st.pimg.net/tucs/css/sh_peachpuff.min.css">peachpuff</option>
        <option value="http://st.pimg.net/tucs/css/sh_print.min.css">print</option>
        <option value="http://st.pimg.net/tucs/css/sh_rand01.min.css">rand01</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-dark.min.css">solarized-dark</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-light.min.css">solarized-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_style.min.css">style</option>
        <option value="http://st.pimg.net/tucs/css/sh_the.min.css">the</option>
        <option value="http://st.pimg.net/tucs/css/sh_typical.min.css">typical</option>
        <option value="http://st.pimg.net/tucs/css/sh_vampire.min.css">vampire</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim-dark.min.css">vim-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim.min.css">vim</option>
        <option value="http://st.pimg.net/tucs/css/sh_whatis.min.css">whatis</option>
        <option value="http://st.pimg.net/tucs/css/sh_whitengrey.min.css">whitengrey</option>
        <option value="http://st.pimg.net/tucs/css/sh_zellner.min.css">zellner</option>
    </select>
</div>



<div class="footer"><div class="cpanstats">78262 Uploads, 24722 Distributions
105996 Modules, 9649 Uploaders
</div>
hosted by <a href="http://www.yellowbot.com">YellowBot</a><br/>
<a href="http://www.yellowbot.com"><img alt="do. tag. write. share." src="http://st.pimg.net/tucs/img/yellowbot_logo.gif"></a>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="http://ipv4.v6test.develooper.com/js/v1/v6test.js"></script>

<script type="text/javascript">
   // v6.target = '';
   if (!v6.target) { v6.only_once = true }
   v6.site = '7A0D89A6-2B82-11DF-B9DA-F61CBD13F020';
   v6.api_server = 'http://ipv4.v6test.develooper.com';
   try {
     v6.test();
   } catch(err) {}
</script>
<script type="text/javascript">
  $(document).ready(function(){
    $("a[href^=http:]").click(function(){
      var href = $(this).attr('href');
      var m = href.match('\/\/([^\/:]+)');
      _gaq.push(['_trackEvent','External',m[1],'Module']);
    });
    $("a[href^=/CPAN/]").click(function(){
      var href = $(this).attr('href');
      _gaq.push(['_trackEvent','Download',href,'Module']);
    });
  });
</script>
<!-- Fri Apr 27 16:30:00 2012 GMT (0.232460021972656) @cpansearch1 -->
 </body>
</html>
