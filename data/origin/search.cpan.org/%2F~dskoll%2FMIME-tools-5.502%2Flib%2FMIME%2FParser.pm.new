<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <link rel="stylesheet" href="http://st.pimg.net/tucs/style.css" type="text/css" />
<style>
.styleswitch {
  text-align: right;
}
</style>


<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.cookie.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_main.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_perl.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.styleswitch.js"></script>

<link rel="stylesheet" href="http://st.pimg.net/tucs/print.css" type="text/css" media="print" />
  <link rel="alternate" type="application/rss+xml" title="RSS 1.0" href="http://search.cpan.org/uploads.rdf" />
  <link rel="search" href="http://st.pimg.net/tucs/opensearch.xml" type="application/opensearchdescription+xml" title="SearchCPAN" />
  <title>MIME::Parser - search.cpan.org</title>
 <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3528438-1']);
    _gaq.push(["_setCustomVar",2,"Distribution","MIME-tools",3]);
    _gaq.push(["_setCustomVar",5,"Release","MIME-tools-5.502",3]);
    _gaq.push(["_setCustomVar",3,"Module","MIME::Parser",3]);
    _gaq.push(["_setCustomVar",1,"Author","DSKOLL",3]);
    _gaq.push(['_trackPageview']);
  </script>
 </head>
 <body id="cpansearch">
<center><div class="logo"><a href="/"><img src="http://st.pimg.net/tucs/img/cpan_banner.png" alt="CPAN"></a></div></center>
<div class="menubar">
 <a href="/">Home</a>
&middot; <a href="/author/">Authors</a>
&middot; <a href="/recent">Recent</a>
&middot; <a href="http://log.perl.org/cpansearch/">News</a>
&middot; <a href="/mirror">Mirrors</a>
&middot; <a href="/faq.html">FAQ</a>
&middot; <a href="/feedback">Feedback</a>
</div>
<form method="get" action="/search" name="f" class="searchbox">
<input type="text" name="query" value="" size="35">
<br>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</form>


 <a name="_top"></a>
  <div class=path>
<div id=permalink class="noprint"><a href="/perldoc?MIME::Parser">permalink</a></div>
  <a href="/~dskoll/">David F. Skoll</a> &gt;
  <a href="/~dskoll/MIME-tools-5.502/">MIME-tools-5.502</a> &gt;
  MIME::Parser
 </div>

<div class="noprint" style="float:right;align:left;width:19ex">
<a href="http://hexten.net/cpan-faces/"><img src="http://www.gravatar.com/avatar/77ceb1d700a17c6454d82e26e73d9807?r=g&s=80&d=http%3A%2F%2Fst.pimg.net%2Ftucs%2Fimg%2Fwho.png" width=80 height=80 
style="float:right"
/></a>
<br style="clear:both"/>
<p style="text-align:right">Download:<br/> <a href="/CPAN/authors/id/D/DS/DSKOLL/MIME-tools-5.502.tar.gz">MIME-tools-5.502.tar.gz</a></p>
<p style="text-align:right"><a href="http://deps.cpantesters.org/?module=MIME%3A%3AParser;perl=latest">Dependencies</a></p>
<p style="text-align:right"><a href="http://www.annocpan.org/~DSKOLL/MIME-tools-5.502/lib/MIME/Parser.pm">Annotate this POD
</a></p>
<div class=box style='width:150px; float: right'>
<h1 class=t5>Related Modules</h1>
<div style="margin:2px">
<a href="/perldoc?MIME%3A%3AEntity">MIME::Entity</a><br>
<a href="/perldoc?Mail%3A%3APOP3Client">Mail::POP3Client</a><br>
<a href="/perldoc?Mail%3A%3ABox">Mail::Box</a><br>
<a href="/perldoc?Net%3A%3APOP3">Net::POP3</a><br>
<a href="/perldoc?Mail%3A%3AAddress">Mail::Address</a><br>
<a href="/perldoc?Data%3A%3ADumper">Data::Dumper</a><br>
<a href="/perldoc?Mail%3A%3AInternet">Mail::Internet</a><br>
<a href="/perldoc?IO%3A%3AFile">IO::File</a><br>
<a href="/perldoc?Mail%3A%3ASender">Mail::Sender</a><br>
<a href="/perldoc?MIME%3A%3AHead">MIME::Head</a><br>
<small>
<a href="http://perlmonks.org/?node=cpan+module+search&pivot=1&module=MIME%3A%3AParser">more...</a><br>
By <a href="http://perlmonks.org/">perlmonks.org</a></small>
</div>
</div>

<div style="float:right">
<div class=box style='width:150px'>
<h1 class=t5>CPAN RT</h1>
<div style="margin:2px">
<table style="margin-left:auto;margin-right:auto">
<tr><td>New&nbsp;</td><td style="text-align:right"> 6</td></tr>
<tr><td>Open&nbsp;</td><td style="text-align:right"> 8</td></tr>
</table>
<a href="https://rt.cpan.org/Public/Dist/Display.html?Name=MIME-tools">View/Report Bugs</a><br/>
</div>
</div>

</div>
</div>
  Module Version:  5.502 &nbsp;
<span class="noprint">
  <a href="/src/DSKOLL/MIME-tools-5.502/lib/MIME/Parser.pm">Source</a> &nbsp;
</span>
<a name="___top"></a>
<div class=pod>
<div class=toc>
<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Basic_usage_examples'>Basic usage examples</a>
    <li class='indexItem indexItem2'><a href='#Examples_of_input'>Examples of input</a>
    <li class='indexItem indexItem2'><a href='#Examples_of_output_control'>Examples of output control</a>
    <li class='indexItem indexItem2'><a href='#Examples_of_error_recovery'>Examples of error recovery</a>
    <li class='indexItem indexItem2'><a href='#Examples_of_parser_options'>Examples of parser options</a>
    <li class='indexItem indexItem2'><a href='#Miscellaneous_examples'>Miscellaneous examples</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_INTERFACE'>PUBLIC INTERFACE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Construction'>Construction</a>
    <li class='indexItem indexItem2'><a href='#Altering_how_messages_are_parsed'>Altering how messages are parsed</a>
    <li class='indexItem indexItem2'><a href='#Parsing_an_input_source'>Parsing an input source</a>
    <li class='indexItem indexItem2'><a href='#Specifying_output_destination'>Specifying output destination</a>
    <li class='indexItem indexItem2'><a href='#Specifying_classes_to_be_instantiated'>Specifying classes to be instantiated</a>
    <li class='indexItem indexItem2'><a href='#Temporary_File_Creation'>Temporary File Creation</a>
    <li class='indexItem indexItem2'><a href='#Parse_results_and_error_recovery'>Parse results and error recovery</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#OPTIMIZING_YOUR_PARSER'>OPTIMIZING YOUR PARSER</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Maximizing_speed'>Maximizing speed</a>
    <li class='indexItem indexItem2'><a href='#Minimizing_memory'>Minimizing memory</a>
    <li class='indexItem indexItem2'><a href='#Maximizing_tolerance_of_bad_MIME'>Maximizing tolerance of bad MIME</a>
    <li class='indexItem indexItem2'><a href='#Avoiding_disk-based_temporary_files'>Avoiding disk-based temporary files</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#WARNINGS'>WARNINGS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>MIME::Parser - experimental class for parsing MIME streams</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Before reading further,
you should see <a href="/perldoc?MIME%3A%3ATools" class="podlinkpod"
>MIME::Tools</a> to make sure that you understand where this module fits into the grand scheme of things.
Go on,
do it now.
I&#39;ll wait.</p>

<p>Ready?
Ok...</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Basic_usage_examples"
>Basic usage examples</a></h2>

<pre class="sh_perl">    ### Create a new parser object:
    my $parser = new MIME::Parser;

    ### Tell it where to put things:
    $parser-&#62;output_under(&#34;/tmp&#34;);

    ### Parse an input filehandle:
    $entity = $parser-&#62;parse(\*STDIN);

    ### Congratulations: you now have a (possibly multipart) MIME entity!
    $entity-&#62;dump_skeleton;          # for debugging</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Examples_of_input"
>Examples of input</a></h2>

<pre class="sh_perl">    ### Parse from filehandles:
    $entity = $parser-&#62;parse(\*STDIN);
    $entity = $parser-&#62;parse(IO::File-&#62;new(&#34;some command|&#34;);

    ### Parse from any object that supports getline() and read():
    $entity = $parser-&#62;parse($myHandle);

    ### Parse an in-core MIME message:
    $entity = $parser-&#62;parse_data($message);

    ### Parse an MIME message in a file:
    $entity = $parser-&#62;parse_open(&#34;/some/file.msg&#34;);

    ### Parse an MIME message out of a pipeline:
    $entity = $parser-&#62;parse_open(&#34;gunzip - &#60; file.msg.gz |&#34;);

    ### Parse already-split input (as &#34;deliver&#34; would give it to you):
    $entity = $parser-&#62;parse_two(&#34;msg.head&#34;, &#34;msg.body&#34;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Examples_of_output_control"
>Examples of output control</a></h2>

<pre class="sh_perl">    ### Keep parsed message bodies in core (default outputs to disk):
    $parser-&#62;output_to_core(1);

    ### Output each message body to a one-per-message directory:
    $parser-&#62;output_under(&#34;/tmp&#34;);

    ### Output each message body to the same directory:
    $parser-&#62;output_dir(&#34;/tmp&#34;);

    ### Change how nameless message-component files are named:
    $parser-&#62;output_prefix(&#34;msg&#34;);

    ### Put temporary files somewhere else
    $parser-&#62;tmp_dir(&#34;/var/tmp/mytmpdir&#34;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Examples_of_error_recovery"
>Examples of error recovery</a></h2>

<pre class="sh_perl">    ### Normal mechanism:
    eval { $entity = $parser-&#62;parse(\*STDIN) };
    if ($@) {
        $results  = $parser-&#62;results;
        $decapitated = $parser-&#62;last_head;  ### get last top-level head
    }

    ### Ultra-tolerant mechanism:
    $parser-&#62;ignore_errors(1);
    $entity = eval { $parser-&#62;parse(\*STDIN) };
    $error = ($@ || $parser-&#62;last_error);

    ### Cleanup all files created by the parse:
    eval { $entity = $parser-&#62;parse(\*STDIN) };
    ...
    $parser-&#62;filer-&#62;purge;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Examples_of_parser_options"
>Examples of parser options</a></h2>

<pre class="sh_perl">    ### Automatically attempt to RFC 2047-decode the MIME headers?
    $parser-&#62;decode_headers(1);             ### default is false

    ### Parse contained &#34;message/rfc822&#34; objects as nested MIME streams?
    $parser-&#62;extract_nested_messages(0);    ### default is true

    ### Look for uuencode in &#34;text&#34; messages, and extract it?
    $parser-&#62;extract_uuencode(1);           ### default is false

    ### Should we forgive normally-fatal errors?
    $parser-&#62;ignore_errors(0);              ### default is true</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Miscellaneous_examples"
>Miscellaneous examples</a></h2>

<pre class="sh_perl">    ### Convert a Mail::Internet object to a MIME::Entity:
    my $data = join(&#39;&#39;, (@{$mail-&#62;header}, &#34;\n&#34;, @{$mail-&#62;body}));
    $entity = $parser-&#62;parse_data(\$data);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>You can inherit from this class to create your own subclasses that parse MIME streams into MIME::Entity objects.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_INTERFACE"
>PUBLIC INTERFACE <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Construction"
>Construction</a></h2>

<dl>
<dt><a name='new'></a><a name="new_ARGS..."
>new ARGS...</a></dt>

<dd>
<p><i>Class method.</i> Create a new parser object. Once you do this, you can then set up various parameters before doing the actual parsing. For example:</p>

<pre class="sh_perl">    my $parser = new MIME::Parser;
    $parser-&#62;output_dir(&#34;/tmp&#34;);
    $parser-&#62;output_prefix(&#34;msg1&#34;);
    my $entity = $parser-&#62;parse(\*STDIN);</pre>

<p>Any arguments are passed into <code>init()</code>. Don&#39;t override this in your subclasses; override init() instead.</p>

<dt><a name='init'></a><a name="init_ARGS..."
>init ARGS...</a></dt>

<dd>
<p><i>Instance method.</i> Initiallize a new MIME::Parser object. This is automatically sent to a new object; you may want to override it. If you override this, be sure to invoke the inherited method.</p>

<dt><a name="init_parse"
>init_parse</a></dt>

<dd>
<p><i>Instance method.</i> Invoked automatically whenever one of the top-level parse() methods is called, to reset the parser to a &#34;ready&#34; state.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Altering_how_messages_are_parsed"
>Altering how messages are parsed</a></h2>

<dl>
<dt><a name='decode_headers'></a><a name="decode_headers_[YESNO]"
>decode_headers [YESNO]</a></dt>

<dd>
<p><i>Instance method.</i> Controls whether the parser will attempt to decode all the MIME headers (as per RFC 2047) the moment it sees them. <b>This is not advisable for two very important reasons:</b></p>

<ul>
<li><b>It screws up the extraction of information from MIME fields.</b> If you fully decode the headers into bytes, you can inadvertently transform a parseable MIME header like this:
<pre class="sh_perl">    Content-type: text/plain; filename=&#34;=?ISO-8859-1?Q?Hi=22Ho?=&#34;</pre>

<p>into unparseable gobbledygook; in this case:</p>

<pre class="sh_perl">    Content-type: text/plain; filename=&#34;Hi&#34;Ho&#34;</pre>
</li>

<li><b>It is information-lossy.</b> An encoded string which contains both Latin-1 and Cyrillic characters will be turned into a binary mishmosh which simply can&#39;t be rendered.</li>
</ul>

<p><b>History.</b> This method was once the only out-of-the-box way to deal with attachments whose filenames had non-ASCII characters. However, since MIME-tools 5.4xx this is no longer necessary.</p>

<p><b>Parameters.</b> If YESNO is true, decoding is done. However, you will get a warning unless you use one of the special &#34;true&#34; values:</p>

<pre class="sh_perl">   &#34;I_NEED_TO_FIX_THIS&#34;
          Just shut up and do it.  Not recommended.
          Provided only for those who need to keep old scripts functioning.

   &#34;I_KNOW_WHAT_I_AM_DOING&#34;
          Just shut up and do it.  Not recommended.
          Provided for those who REALLY know what they are doing.</pre>

<p>If YESNO is false (the default), no attempt at decoding will be done. With no argument, just returns the current setting. <b>Remember:</b> you can always decode the headers <i>after</i> the parsing has completed (see <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Head.pm#decode" class="podlinkpod"
>MIME::Head::decode()</a>), or decode the words on demand (see <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Words.pm" class="podlinkpod"
>MIME::Words</a>).</p>

<dt><a name='extract_nested_messages'></a><a name="extract_nested_messages_OPTION"
>extract_nested_messages OPTION</a></dt>

<dd>
<p><i>Instance method.</i> Some MIME messages will contain a part of type <code>message/rfc822</code> ,<code>message/partial</code> or <code>message/external-body</code>: literally, the text of an embedded mail/news/whatever message. This option controls whether (and how) we parse that embedded message.</p>

<p>If the OPTION is false, we treat such a message just as if it were a <code>text/plain</code> document, without attempting to decode its contents.</p>

<p>If the OPTION is true (the default), the body of the <code>message/rfc822</code> or <code>message/partial</code> part is parsed by this parser, creating an entity object. What happens then is determined by the actual OPTION:</p>

<dl>
<dt><a name='NEST'></a><a name="NEST_or_1"
>NEST or 1</a></dt>

<dd>
<p>The default setting. The contained message becomes the sole &#34;part&#34; of the <code>message/rfc822</code> entity (as if the containing message were a special kind of &#34;multipart&#34; message). You can recover the sub-entity by invoking the <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Entity.pm#parts" class="podlinkpod"
>parts()</a> method on the <code>message/rfc822</code> entity.</p>

<dt><a name="REPLACE"
>REPLACE</a></dt>

<dd>
<p>The contained message replaces the <code>message/rfc822</code> entity, as though the <code>message/rfc822</code> &#34;container&#34; never existed.</p>

<p><b>Warning:</b> notice that, with this option, all the header information in the <code>message/rfc822</code> header is lost. This might seriously bother you if you&#39;re dealing with a top-level message, and you&#39;ve just lost the sender&#39;s address and the subject line. <code>:-/</code>.</p>
</dd>
</dl>

<p><i>Thanks to Andreas Koenig for suggesting this method.</i></p>

<dt><a name='extract_uuencode'></a><a name="extract_uuencode_[YESNO]"
>extract_uuencode [YESNO]</a></dt>

<dd>
<p><i>Instance method.</i> If set true, then whenever we are confronted with a message whose effective content-type is &#34;text/plain&#34; and whose encoding is 7bit/8bit/binary, we scan the encoded body to see if it contains uuencoded data (generally given away by a &#34;begin XXX&#34; line).</p>

<p>If it does, we explode the uuencoded message into a multipart, where the text before the first &#34;begin XXX&#34; becomes the first part, and all &#34;begin...end&#34; sections following become the subsequent parts. The filename (if given) is accessible through the normal means.</p>

<dt><a name='ignore_errors'></a><a name="ignore_errors_[YESNO]"
>ignore_errors [YESNO]</a></dt>

<dd>
<p><i>Instance method.</i> Controls whether the parser will attempt to ignore normally-fatal errors, treating them as warnings and continuing with the parse.</p>

<p>If YESNO is true (the default), many syntax errors are tolerated. If YESNO is false, fatal errors throw exceptions. With no argument, just returns the current setting.</p>

<dt><a name='decode_bodies'></a><a name="decode_bodies_[YESNO]"
>decode_bodies [YESNO]</a></dt>

<dd>
<p><i>Instance method.</i> Controls whether the parser should decode entity bodies or not. If this is set to a false value (default is true), all entity bodies will be kept as-is in the original content-transfer encoding.</p>

<p>To prevent double encoding on the output side MIME::Body-&#62;is_encoded is set, which tells MIME::Body not to encode the data again, if encoded data was requested. This is in particular useful, when it&#39;s important that the content <b>must not</b> be modified, e.g. if you want to calculate OpenPGP signatures from it.</p>

<p><b>WARNING</b>: the semantics change significantly if you parse MIME messages with this option set, because MIME::Entity resp. MIME::Body *always* see encoded data now, while the default behaviour is working with *decoded* data (and encoding it only if you request it). You need to decode the data yourself, if you want to have it decoded.</p>

<p>So use this option only if you exactly know, what you&#39;re doing, and that you&#39;re sure, that you really need it.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parsing_an_input_source"
>Parsing an input source</a></h2>

<dl>
<dt><a name='parse_data'></a><a name="parse_data_DATA"
>parse_data DATA</a></dt>

<dd>
<p><i>Instance method.</i> Parse a MIME message that&#39;s already in core. This internally creates an &#34;in memory&#34; filehandle on a Perl scalar value using PerlIO</p>

<p>You may supply the DATA in any of a number of ways...</p>

<ul>
<li><b>A scalar</b> which holds the message. A reference to this scalar will be used internally.</li>

<li><b>A ref to a scalar</b> which holds the message. This reference will be used internally.</li>

<li><b>DEPRECATED</b>
<p><b>A ref to an array of scalars.</b> The array is internally concatenated into a temporary string, and a reference to the new string is used internally.</p>

<p>It is much more efficient to pass in a scalar reference, so please consider refactoring your code to use that interface instead. If you absolutely MUST pass an array, you may be better off using IO::ScalarArray in the calling code to generate a filehandle, and passing that filehandle to <i>parse()</i></p>
</li>
</ul>

<p>Returns the parsed MIME::Entity on success.</p>

<dt><a name='parse'></a><a name="parse_INSTREAM"
>parse INSTREAM</a></dt>

<dd>
<p><i>Instance method.</i> Takes a MIME-stream and splits it into its component entities.</p>

<p>The INSTREAM can be given as an IO::File, a globref filehandle (like <code>\*STDIN</code>), or as <i>any</i> blessed object conforming to the IO:: interface (which minimally implements getline() and read()).</p>

<p>Returns the parsed MIME::Entity on success. Throws exception on failure. If the message contained too many parts (as set by <i>max_parts</i>), returns undef.</p>

<dt><a name='parse_open'></a><a name="parse_open_EXPR"
>parse_open EXPR</a></dt>

<dd>
<p><i>Instance method.</i> Convenience front-end onto <code>parse()</code>. Simply give this method any expression that may be sent as the second argument to open() to open a filehandle for reading.</p>

<p>Returns the parsed MIME::Entity on success. Throws exception on failure.</p>

<dt><a name='parse_two'></a><a name="parse_two_HEADFILE,_BODYFILE"
>parse_two HEADFILE, BODYFILE</a></dt>

<dd>
<p><i>Instance method.</i> Convenience front-end onto <code>parse_open()</code>, intended for programs running under mail-handlers like <b>deliver</b>, which splits the incoming mail message into a header file and a body file. Simply give this method the paths to the respective files.</p>

<p><b>Warning:</b> it is assumed that, once the files are cat&#39;ed together, there will be a blank line separating the head part and the body part.</p>

<p><b>Warning:</b> new implementation slurps files into line array for portability, instead of using &#39;cat&#39;. May be an issue if your messages are large.</p>

<p>Returns the parsed MIME::Entity on success. Throws exception on failure.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Specifying_output_destination"
>Specifying output destination</a></h2>

<p><b>Warning:</b> in 5.212 and before, this was done by methods of MIME::Parser. However, since many users have requested fine-tuned control over how this is done, the logic has been split off from the parser into its own class, MIME::Parser::Filer Every MIME::Parser maintains an instance of a MIME::Parser::Filer subclass to manage disk output (see <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Parser/Filer.pm" class="podlinkpod"
>MIME::Parser::Filer</a> for details.)</p>

<p>The benefit to this is that the MIME::Parser code won&#39;t be confounded with a lot of garbage related to disk output. The drawback is that the way you override the default behavior will change.</p>

<p>For now, all the normal public-interface methods are still provided, but many are only stubs which create or delegate to the underlying MIME::Parser::Filer object.</p>

<dl>
<dt><a name='filer'></a><a name="filer_[FILER]"
>filer [FILER]</a></dt>

<dd>
<p><i>Instance method.</i> Get/set the FILER object used to manage the output of files to disk. This will be some subclass of <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Parser/Filer.pm" class="podlinkpod"
>MIME::Parser::Filer</a>.</p>

<dt><a name='output_dir'></a><a name="output_dir_DIRECTORY"
>output_dir DIRECTORY</a></dt>

<dd>
<p><i>Instance method.</i> Causes messages to be filed directly into the given DIRECTORY. It does this by setting the underlying <a href="#filer" class="podlinkpod"
>filer()</a> to a new instance of MIME::Parser::FileInto, and passing the arguments into that class&#39; new() method.</p>

<p><b>Note:</b> Since this method replaces the underlying filer, you must invoke it <i>before</i> doing changing any attributes of the filer, like the output prefix; otherwise those changes will be lost.</p>

<dt><a name='output_under'></a><a name="output_under_BASEDIR,_OPTS..."
>output_under BASEDIR, OPTS...</a></dt>

<dd>
<p><i>Instance method.</i> Causes messages to be filed directly into subdirectories of the given BASEDIR, one subdirectory per message. It does this by setting the underlying <a href="#filer" class="podlinkpod"
>filer()</a> to a new instance of MIME::Parser::FileUnder, and passing the arguments into that class&#39; new() method.</p>

<p><b>Note:</b> Since this method replaces the underlying filer, you must invoke it <i>before</i> doing changing any attributes of the filer, like the output prefix; otherwise those changes will be lost.</p>

<dt><a name='output_path'></a><a name="output_path_HEAD"
>output_path HEAD</a></dt>

<dd>
<p><i>Instance method, DEPRECATED.</i> Given a MIME head for a file to be extracted, come up with a good output pathname for the extracted file. Identical to the preferred form:</p>

<pre class="sh_perl">     $parser-&#62;filer-&#62;output_path(...args...);</pre>

<p>We just delegate this to the underlying <a href="#filer" class="podlinkpod"
>filer()</a> object.</p>

<dt><a name='output_prefix'></a><a name="output_prefix_[PREFIX]"
>output_prefix [PREFIX]</a></dt>

<dd>
<p><i>Instance method, DEPRECATED.</i> Get/set the short string that all filenames for extracted body-parts will begin with (assuming that there is no better &#34;recommended filename&#34;). Identical to the preferred form:</p>

<pre class="sh_perl">     $parser-&#62;filer-&#62;output_prefix(...args...);</pre>

<p>We just delegate this to the underlying <a href="#filer" class="podlinkpod"
>filer()</a> object.</p>

<dt><a name='evil_filename'></a><a name="evil_filename_NAME"
>evil_filename NAME</a></dt>

<dd>
<p><i>Instance method, DEPRECATED.</i> Identical to the preferred form:</p>

<pre class="sh_perl">     $parser-&#62;filer-&#62;evil_filename(...args...);</pre>

<p>We just delegate this to the underlying <a href="#filer" class="podlinkpod"
>filer()</a> object.</p>

<dt><a name='max_parts'></a><a name="max_parts_NUM"
>max_parts NUM</a></dt>

<dd>
<p><i>Instance method.</i> Limits the number of MIME parts we will parse.</p>

<p>Normally, instances of this class parse a message to the bitter end. Messages with many MIME parts can cause excessive memory consumption. If you invoke this method, parsing will abort with a die() if a message contains more than NUM parts.</p>

<p>If NUM is set to -1 (the default), then no maximum limit is enforced.</p>

<p>With no argument, returns the current setting as an integer</p>

<dt><a name='output_to_core'></a><a name="output_to_core_YESNO"
>output_to_core YESNO</a></dt>

<dd>
<p><i>Instance method.</i> Normally, instances of this class output all their decoded body data to disk files (via MIME::Body::File). However, you can change this behaviour by invoking this method before parsing:</p>

<p>If YESNO is false (the default), then all body data goes to disk files.</p>

<p>If YESNO is true, then all body data goes to in-core data structures This is a little risky (what if someone emails you an MPEG or a tar file, hmmm?) but people seem to want this bit of noose-shaped rope, so I&#39;m providing it. Note that setting this attribute true <i>does not</i> mean that parser-internal temporary files are avoided! Use <a href="#tmp_to_core" class="podlinkpod"
>tmp_to_core()</a> for that.</p>

<p>With no argument, returns the current setting as a boolean.</p>

<dt><a name="tmp_recycling"
>tmp_recycling</a></dt>

<dd>
<p><i>Instance method, DEPRECATED.</i></p>

<p>This method is a no-op to preserve the pre-5.421 API.</p>

<p>The tmp_recycling() feature was removed in 5.421 because it had never actually worked. Please update your code to stop using it.</p>

<dt><a name='tmp_to_core'></a><a name="tmp_to_core_[YESNO]"
>tmp_to_core [YESNO]</a></dt>

<dd>
<p><i>Instance method.</i> Should <a href="#new_tmpfile" class="podlinkpod"
>new_tmpfile()</a> create real temp files, or use fake in-core ones? Normally we allow the creation of temporary disk files, since this allows us to handle huge attachments even when core is limited.</p>

<p>If YESNO is true, we implement new_tmpfile() via in-core handles. If YESNO is false (the default), we use real tmpfiles. With no argument, just returns the current setting.</p>

<dt><a name='use_inner_files'></a><a name="use_inner_files_[YESNO]"
>use_inner_files [YESNO]</a></dt>

<dd>
<p><i>REMOVED</i>.</p>

<p><i>Instance method.</i></p>

<p>MIME::Parser no longer supports IO::InnerFile, but this method is retained for backwards compatibility. It does nothing.</p>

<p>The original reasoning for IO::InnerFile was that inner files were faster than &#34;in-core&#34; temp files. At the time, the &#34;in-core&#34; tempfile support was implemented with IO::Scalar from the IO-Stringy distribution, which used the tie() interface to wrap a scalar with the appropriate IO::Handle operations. The penalty for this was fairly hefty, and IO::InnerFile actually was faster.</p>

<p>Nowadays, MIME::Parser uses Perl&#39;s built in ability to open a filehandle on an in-memory scalar variable via PerlIO. Benchmarking shows that IO::InnerFile is slightly slower than using in-memory temporary files, and is slightly faster than on-disk temporary files. Both measurements are within a few percent of each other. Since there&#39;s no real benefit, and since the IO::InnerFile abuse was fairly hairy and evil (&#34;writes&#34; to it were faked by extending the size of the inner file with the assumption that the only data you&#39;d ever -&#62;print() to it would be the line from the &#34;outer&#34; file, for example) it&#39;s been removed.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Specifying_classes_to_be_instantiated"
>Specifying classes to be instantiated</a></h2>

<dl>
<dt><a name='interface'></a><a name="interface_ROLE,[VALUE]"
>interface ROLE,[VALUE]</a></dt>

<dd>
<p><i>Instance method.</i> During parsing, the parser normally creates instances of certain classes, like MIME::Entity. However, you may want to create a parser subclass that uses your own experimental head, entity, etc. classes (for example, your &#34;head&#34; class may provide some additional MIME-field-oriented methods).</p>

<p>If so, then this is the method that your subclass should invoke during init. Use it like this:</p>

<pre class="sh_perl">    package MyParser;
    @ISA = qw(MIME::Parser);
    ...
    sub init {
        my $self = shift;
        $self-&#62;SUPER::init(@_);        ### do my parent&#39;s init
        $self-&#62;interface(ENTITY_CLASS =&#62; &#39;MIME::MyEntity&#39;);
        $self-&#62;interface(HEAD_CLASS   =&#62; &#39;MIME::MyHead&#39;);
        $self;                         ### return
    }</pre>

<p>With no VALUE, returns the VALUE currently associated with that ROLE.</p>

<dt><a name='new_body_for'></a><a name="new_body_for_HEAD"
>new_body_for HEAD</a></dt>

<dd>
<p><i>Instance method.</i> Based on the HEAD of a part we are parsing, return a new body object (any desirable subclass of MIME::Body) for receiving that part&#39;s data.</p>

<p>If you set the <code>output_to_core</code> option to false before parsing (the default), then we call <code>output_path()</code> and create a new MIME::Body::File on that filename.</p>

<p>If you set the <code>output_to_core</code> option to true before parsing, then you get a MIME::Body::InCore instead.</p>

<p>If you want the parser to do something else entirely, you can override this method in a subclass.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Temporary_File_Creation"
>Temporary File Creation</a></h2>

<dl>
<dt><a name='tmp_dir'></a><a name="tmp_dir_DIRECTORY"
>tmp_dir DIRECTORY</a></dt>

<dd>
<p><i>Instance method.</i> Causes any temporary files created by this parser to be created in the given DIRECTORY.</p>

<p>If called without arguments, returns current value.</p>

<p>The default value is undef, which will cause new_tmpfile() to use the system default temporary directory.</p>

<dt><a name="new_tmpfile"
>new_tmpfile</a></dt>

<dd>
<p><i>Instance method.</i> Return an IO handle to be used to hold temporary data during a parse.</p>

<p>The default uses MIME::Tools::tmpopen() to create a new temporary file, unless <a href="#tmp_to_core" class="podlinkpod"
>tmp_to_core()</a> dictates otherwise, but you can override this. You shouldn&#39;t need to.</p>

<p>The location for temporary files can be changed on a per-parser basis with <a href="/perldoc?tmp_dir()" class="podlinkpod"
>tmp_dir()</a>.</p>

<p>If you do override this, make certain that the object you return is set for binmode(), and is able to handle the following methods:</p>

<pre class="sh_perl">    read(BUF, NBYTES)
    getline()
    getlines()
    print(@ARGS)
    flush()
    seek(0, 0)</pre>

<p>Fatal exception if the stream could not be established.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parse_results_and_error_recovery"
>Parse results and error recovery</a></h2>

<dl>
<dt><a name="last_error"
>last_error</a></dt>

<dd>
<p><i>Instance method.</i> Return the error (if any) that we ignored in the last parse.</p>

<dt><a name="last_head"
>last_head</a></dt>

<dd>
<p><i>Instance method.</i> Return the top-level MIME header of the last stream we attempted to parse. This is useful for replying to people who sent us bad MIME messages.</p>

<pre class="sh_perl">    ### Parse an input stream:
    eval { $entity = $parser-&#62;parse(\*STDIN) };
    if (!$entity) {    ### parse failed!
        my $decapitated = $parser-&#62;last_head;
        ...
    }</pre>

<dt><a name="results"
>results</a></dt>

<dd>
<p><i>Instance method.</i> Return an object containing lots of info from the last entity parsed. This will be an instance of class <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Parser/Results.pm" class="podlinkpod"
>MIME::Parser::Results</a>.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OPTIMIZING_YOUR_PARSER"
>OPTIMIZING YOUR PARSER <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Maximizing_speed"
>Maximizing speed</a></h2>

<p>Optimum input mechanisms:</p>

<pre class="sh_perl">    parse()                    YES (if you give it a globref or a
                                    subclass of IO::File)
    parse_open()               YES
    parse_data()               NO  (see below)
    parse_two()                NO  (see below)</pre>

<p>Optimum settings:</p>

<pre class="sh_perl">    decode_headers()           *** (no real difference; 0 is slightly faster)
    extract_nested_messages()  0   (may be slightly faster, but in
                                    general you want it set to 1)
    output_to_core()           0   (will be MUCH faster)
    tmp_to_core()              0   (will be MUCH faster)</pre>

<p><b>Native I/O is much faster than object-oriented I/O.</b> It&#39;s much faster to use &#60;$foo&#62; than $foo-&#62;getline. For backwards compatibilty, this module must continue to use object-oriented I/O in most places, but if you use <a href="#parse" class="podlinkpod"
>parse()</a> with a &#34;real&#34; filehandle (string, globref, or subclass of IO::File) then MIME::Parser is able to perform some crucial optimizations.</p>

<p><b>The parse_two() call is very inefficient.</b> Currently this is just a front-end onto parse_data(). If your OS supports it, you&#39;re <i>far</i> better off doing something like:</p>

<pre class="sh_perl">    $parser-&#62;parse_open(&#34;/bin/cat msg.head msg.body |&#34;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Minimizing_memory"
>Minimizing memory</a></h2>

<p>Optimum input mechanisms:</p>

<pre class="sh_perl">    parse()                    YES
    parse_open()               YES
    parse_data()               NO  (in-core I/O will burn core)
    parse_two()                NO  (in-core I/O will burn core)</pre>

<p>Optimum settings:</p>

<pre class="sh_perl">    decode_headers()           *** (no real difference)
    extract_nested_messages()  *** (no real difference)
    output_to_core()           0   (will use MUCH less memory)
                                    tmp_to_core is 1)
    tmp_to_core()              0   (will use MUCH less memory)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Maximizing_tolerance_of_bad_MIME"
>Maximizing tolerance of bad MIME</a></h2>

<p>Optimum input mechanisms:</p>

<pre class="sh_perl">    parse()                    *** (doesn&#39;t matter)
    parse_open()               *** (doesn&#39;t matter)
    parse_data()               *** (doesn&#39;t matter)
    parse_two()                *** (doesn&#39;t matter)</pre>

<p>Optimum settings:</p>

<pre class="sh_perl">    decode_headers()           0   (sidesteps problem of bad hdr encodings)
    extract_nested_messages()  0   (sidesteps problems of bad nested messages,
                                    but often you want it set to 1 anyway).
    output_to_core()           *** (doesn&#39;t matter)
    tmp_to_core()              *** (doesn&#39;t matter)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Avoiding_disk-based_temporary_files"
>Avoiding disk-based temporary files</a></h2>

<p>Optimum input mechanisms:</p>

<pre class="sh_perl">    parse()                    YES (if you give it a seekable handle)
    parse_open()               YES (becomes a seekable handle)
    parse_data()               NO  (unless you set tmp_to_core(1))
    parse_two()                NO  (unless you set tmp_to_core(1))</pre>

<p>Optimum settings:</p>

<pre class="sh_perl">    decode_headers()           *** (doesn&#39;t matter)
    extract_nested_messages()  *** (doesn&#39;t matter)
    output_to_core()           *** (doesn&#39;t matter)
    tmp_to_core()              1</pre>

<p><b>You can veto tmpfiles entirely.</b> You can set <a href="#tmp_to_core" class="podlinkpod"
>tmp_to_core()</a> true: this will always use in-core I/O for the buffering (<b>warning:</b> this will slow down the parsing of messages with large attachments).</p>

<p><b>Final resort.</b> You can always override <a href="#new_tmpfile" class="podlinkpod"
>new_tmpfile()</a> in a subclass.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WARNINGS"
>WARNINGS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<dl>
<dt><a name='Multipart'></a><a name="Multipart_messages_are_always_read_line-by-line"
>Multipart messages are always read line-by-line</a></dt>

<dd>
<p>Multipart document parts are read line-by-line, so that the encapsulation boundaries may easily be detected. However, bad MIME composition agents (for example, naive CGI scripts) might return multipart documents where the parts are, say, unencoded bitmap files... and, consequently, where such &#34;lines&#34; might be veeeeeeeeery long indeed.</p>

<p>A better solution for this case would be to set up some form of state machine for input processing. This will be left for future versions.</p>

<dt><a name='Multipart'></a><a name="Multipart_parts_read_into_temp_files_before_decoding"
>Multipart parts read into temp files before decoding</a></dt>

<dd>
<p>In my original implementation, the MIME::Decoder classes had to be aware of encapsulation boundaries in multipart MIME documents. While this decode-while-parsing approach obviated the need for temporary files, it resulted in inflexible and complex decoder implementations.</p>

<p>The revised implementation uses a temporary file (a la <code>tmpfile()</code>) during parsing to hold the <i>encoded</i> portion of the current MIME document or part. This file is deleted automatically after the current part is decoded and the data is written to the &#34;body stream&#34; object; you&#39;ll never see it, and should never need to worry about it.</p>

<p>Some folks have asked for the ability to bypass this temp-file mechanism, I suppose because they assume it would slow down their application. I considered accomodating this wish, but the temp-file approach solves a lot of thorny problems in parsing, and it also protects against hidden bugs in user applications (what if you&#39;ve directed the encoded part into a scalar, and someone unexpectedly sends you a 6 MB tar file?). Finally, I&#39;m just not conviced that the temp-file use adds significant overhead.</p>

<dt><a name='Fuzzing'></a><a name="Fuzzing_of_CRLF_and_newline_on_input"
>Fuzzing of CRLF and newline on input</a></dt>

<dd>
<p>RFC 2045 dictates that MIME streams have lines terminated by CRLF (<code>&#34;\r\n&#34;</code>). However, it is extremely likely that folks will want to parse MIME streams where each line ends in the local newline character <code>&#34;\n&#34;</code> instead.</p>

<p>An attempt has been made to allow the parser to handle both CRLF and newline-terminated input.</p>

<dt><a name='Fuzzing'></a><a name="Fuzzing_of_CRLF_and_newline_on_output"
>Fuzzing of CRLF and newline on output</a></dt>

<dd>
<p>The <code>&#34;7bit&#34;</code> and <code>&#34;8bit&#34;</code> decoders will decode both a <code>&#34;\n&#34;</code> and a <code>&#34;\r\n&#34;</code> end-of-line sequence into a <code>&#34;\n&#34;</code>.</p>

<p>The <code>&#34;binary&#34;</code> decoder (default if no encoding specified) still outputs stuff verbatim... so a MIME message with CRLFs and no explicit encoding will be output as a text file that, on many systems, will have an annoying ^M at the end of each line... <i>but this is as it should be</i>.</p>

<dt><a name='Inability'></a><a name="Inability_to_handle_multipart_boundaries_that_contain_newlines"
>Inability to handle multipart boundaries that contain newlines</a></dt>

<dd>
<p>First, let&#39;s get something straight: <i>this is an evil, EVIL practice,</i> and is incompatible with RFC 2046... hence, it&#39;s not valid MIME.</p>

<p>If your mailer creates multipart boundary strings that contain newlines <i>when they appear in the message body,</i> give it two weeks notice and find another one. If your mail robot receives MIME mail like this, regard it as syntactically incorrect MIME, which it is.</p>

<p>Why do I say that? Well, in RFC 2046, the syntax of a boundary is given quite clearly:</p>

<pre class="sh_perl">      boundary := 0*69&#60;bchars&#62; bcharsnospace

      bchars := bcharsnospace / &#34; &#34;

      bcharsnospace :=    DIGIT / ALPHA / &#34;&#39;&#34; / &#34;(&#34; / &#34;)&#34; / &#34;+&#34; /&#34;_&#34;
                   / &#34;,&#34; / &#34;-&#34; / &#34;.&#34; / &#34;/&#34; / &#34;:&#34; / &#34;=&#34; / &#34;?&#34;</pre>

<p>All of which means that a valid boundary string <i>cannot</i> have newlines in it, and any newlines in such a string in the message header are expected to be solely the result of <i>folding</i> the string (i.e., inserting to-be-removed newlines for readability and line-shortening <i>only</i>).</p>

<p>Yet, there is at least one brain-damaged user agent out there that composes mail like this:</p>

<pre class="sh_perl">      MIME-Version: 1.0
      Content-type: multipart/mixed; boundary=&#34;----ABC-
       123----&#34;
      Subject: Hi... I&#39;m a dork!

      This is a multipart MIME message (yeah, right...)

      ----ABC-
       123----

      Hi there!</pre>

<p>We have <i>got</i> to discourage practices like this (and the recent file upload idiocy where binary files that are part of a multipart MIME message aren&#39;t base64-encoded) if we want MIME to stay relatively simple, and MIME parsers to be relatively robust.</p>

<p><i>Thanks to Andreas Koenig for bringing a baaaaaaaaad user agent to my attention.</i></p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><a href="/perldoc?MIME%3A%3ATools" class="podlinkpod"
>MIME::Tools</a>, <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Head.pm" class="podlinkpod"
>MIME::Head</a>, <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Body.pm" class="podlinkpod"
>MIME::Body</a>, <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Entity.pm" class="podlinkpod"
>MIME::Entity</a>, <a href="/~dskoll/MIME-tools-5.502/lib/MIME/Decoder.pm" class="podlinkpod"
>MIME::Decoder</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Eryq (<em>eryq@zeegee.com</em>), ZeeGee Software Inc (<em><a href="http://www.zeegee.com" class="podlinkurl"
>http://www.zeegee.com</a></em>). David F. Skoll (dfs@roaringpenguin.com) <a href="http://www.roaringpenguin.com" class="podlinkurl"
>http://www.roaringpenguin.com</a></p>

<p>All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

</div>
<!-- This should probably be put in the <div class="footer"></div> -->
<script type="text/javascript">
    $(document).ready(function(){
        var startingStyle = $.cookie('css') ? $.cookie('css') : 'http://st.pimg.net/tucs/css/sh_none.min.css';
        $.fn.styleSwitch(startingStyle);
        $("#styleswitch").val(startingStyle);
        sh_highlightDocument();
        $("#styleswitch").bind(($.browser.msie ? "click" : "change"), function() {
            $.fn.styleSwitch($(this).val());
        });
    });
</script>
<div class="styleswitch">
    syntax highlighting:
    <select id="styleswitch">
        <option value="http://st.pimg.net/tucs/css/sh_none.min.css">no syntax highlighting</option>
        <option value="http://st.pimg.net/tucs/css/sh_acid.min.css">acid</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-dark.min.css">berries-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-light.min.css">berries-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_bipolar.min.css">bipolar</option>
        <option value="http://st.pimg.net/tucs/css/sh_blacknblue.min.css">blacknblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_bright.min.css">bright</option>
        <option value="http://st.pimg.net/tucs/css/sh_contrast.min.css">contrast</option>
        <option value="http://st.pimg.net/tucs/css/sh_cpan.min.css">cpan</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkblue.min.css">darkblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkness.min.css">darkness</option>
        <option value="http://st.pimg.net/tucs/css/sh_desert.min.css">desert</option>
        <option value="http://st.pimg.net/tucs/css/sh_dull.min.css">dull</option>
        <option value="http://st.pimg.net/tucs/css/sh_easter.min.css">easter</option>
        <option value="http://st.pimg.net/tucs/css/sh_emacs.min.css">emacs</option>
        <option value="http://st.pimg.net/tucs/css/sh_golden.min.css">golden</option>
        <option value="http://st.pimg.net/tucs/css/sh_greenlcd.min.css">greenlcd</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-anjuta.min.css">ide-anjuta</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-codewarrior.min.css">ide-codewarrior</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-devcpp.min.css">ide-devcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-eclipse.min.css">ide-eclipse</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-kdev.min.css">ide-kdev</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-msvcpp.min.css">ide-msvcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_kwrite.min.css">kwrite</option>
        <option value="http://st.pimg.net/tucs/css/sh_matlab.min.css">matlab</option>
        <option value="http://st.pimg.net/tucs/css/sh_navy.min.css">navy</option>
        <option value="http://st.pimg.net/tucs/css/sh_nedit.min.css">nedit</option>
        <option value="http://st.pimg.net/tucs/css/sh_neon.min.css">neon</option>
        <option value="http://st.pimg.net/tucs/css/sh_night.min.css">night</option>
        <option value="http://st.pimg.net/tucs/css/sh_pablo.min.css">pablo</option>
        <option value="http://st.pimg.net/tucs/css/sh_peachpuff.min.css">peachpuff</option>
        <option value="http://st.pimg.net/tucs/css/sh_print.min.css">print</option>
        <option value="http://st.pimg.net/tucs/css/sh_rand01.min.css">rand01</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-dark.min.css">solarized-dark</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-light.min.css">solarized-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_style.min.css">style</option>
        <option value="http://st.pimg.net/tucs/css/sh_the.min.css">the</option>
        <option value="http://st.pimg.net/tucs/css/sh_typical.min.css">typical</option>
        <option value="http://st.pimg.net/tucs/css/sh_vampire.min.css">vampire</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim-dark.min.css">vim-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim.min.css">vim</option>
        <option value="http://st.pimg.net/tucs/css/sh_whatis.min.css">whatis</option>
        <option value="http://st.pimg.net/tucs/css/sh_whitengrey.min.css">whitengrey</option>
        <option value="http://st.pimg.net/tucs/css/sh_zellner.min.css">zellner</option>
    </select>
</div>



<div class="footer"><div class="cpanstats">78280 Uploads, 24725 Distributions
106010 Modules, 9649 Uploaders
</div>
hosted by <a href="http://www.yellowbot.com">YellowBot</a><br/>
<a href="http://www.yellowbot.com"><img alt="do. tag. write. share." src="http://st.pimg.net/tucs/img/yellowbot_logo.gif"></a>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="http://ipv4.v6test.develooper.com/js/v1/v6test.js"></script>

<script type="text/javascript">
   // v6.target = '';
   if (!v6.target) { v6.only_once = true }
   v6.site = '7A0D89A6-2B82-11DF-B9DA-F61CBD13F020';
   v6.api_server = 'http://ipv4.v6test.develooper.com';
   try {
     v6.test();
   } catch(err) {}
</script>
<script type="text/javascript">
  $(document).ready(function(){
    $("a[href^=http:]").click(function(){
      var href = $(this).attr('href');
      var m = href.match('\/\/([^\/:]+)');
      _gaq.push(['_trackEvent','External',m[1],'Module']);
    });
    $("a[href^=/CPAN/]").click(function(){
      var href = $(this).attr('href');
      _gaq.push(['_trackEvent','Download',href,'Module']);
    });
  });
</script>
<!-- Sat Apr 28 04:46:46 2012 GMT (0.342381000518799) @cpansearch1 -->
 </body>
</html>
