<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <link rel="stylesheet" href="http://st.pimg.net/tucs/style.css" type="text/css" />
<style>
.styleswitch {
  text-align: right;
}
</style>


<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.cookie.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_main.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_perl.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.styleswitch.js"></script>

<link rel="stylesheet" href="http://st.pimg.net/tucs/print.css" type="text/css" media="print" />
  <link rel="alternate" type="application/rss+xml" title="RSS 1.0" href="http://search.cpan.org/uploads.rdf" />
  <link rel="search" href="http://st.pimg.net/tucs/opensearch.xml" type="application/opensearchdescription+xml" title="SearchCPAN" />
  <title>Parse::Lex - search.cpan.org</title>
 <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3528438-1']);
    _gaq.push(["_setCustomVar",2,"Distribution","ParseLex",3]);
    _gaq.push(["_setCustomVar",5,"Release","ParseLex-2.21",3]);
    _gaq.push(["_setCustomVar",3,"Module","Parse::Lex",3]);
    _gaq.push(["_setCustomVar",1,"Author","PSCUST",3]);
    _gaq.push(['_trackPageview']);
  </script>
 </head>
 <body id="cpansearch">
<center><div class="logo"><a href="/"><img src="http://st.pimg.net/tucs/img/cpan_banner.png" alt="CPAN"></a></div></center>
<div class="menubar">
 <a href="/">Home</a>
&middot; <a href="/author/">Authors</a>
&middot; <a href="/recent">Recent</a>
&middot; <a href="http://log.perl.org/cpansearch/">News</a>
&middot; <a href="/mirror">Mirrors</a>
&middot; <a href="/faq.html">FAQ</a>
&middot; <a href="/feedback">Feedback</a>
</div>
<form method="get" action="/search" name="f" class="searchbox">
<input type="text" name="query" value="" size="35">
<br>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</form>


 <a name="_top"></a>
  <div class=path>
<div id=permalink class="noprint"><a href="/perldoc?Parse::Lex">permalink</a></div>
  <a href="/~pscust/">Paulo Custodio</a> &gt;
  <a href="/~pscust/ParseLex-2.21/">ParseLex-2.21</a> &gt;
  Parse::Lex
 </div>

<div class="noprint" style="float:right;align:left;width:19ex">
<a href="http://hexten.net/cpan-faces/"><img src="http://www.gravatar.com/avatar/bba6aa3d7ba48d250d898d772c886093?r=g&s=80&d=http%3A%2F%2Fst.pimg.net%2Ftucs%2Fimg%2Fwho.png" width=80 height=80 
style="float:right"
/></a>
<br style="clear:both"/>
<p style="text-align:right">Download:<br/> <a href="/CPAN/authors/id/P/PS/PSCUST/ParseLex-2.21.tar.gz">ParseLex-2.21.tar.gz</a></p>
<p style="text-align:right"><a href="http://deps.cpantesters.org/?module=Parse%3A%3ALex;perl=latest">Dependencies</a></p>
<p style="text-align:right"><a href="http://www.annocpan.org/~PSCUST/ParseLex-2.21/lib/Parse/Lex.pm">Annotate this POD
</a></p>
<div class=box style='width:150px; float: right'>
<h1 class=t5>Related Modules</h1>
<div style="margin:2px">
<a href="/perldoc?Parse%3A%3ARecDescent">Parse::RecDescent</a><br>
<a href="/perldoc?Parse%3A%3AYapp">Parse::Yapp</a><br>
<a href="/perldoc?Inline%3A%3AC">Inline::C</a><br>
<small>
<a href="http://perlmonks.org/?node=cpan+module+search&pivot=1&module=Parse%3A%3ALex">more...</a><br>
By <a href="http://perlmonks.org/">perlmonks.org</a></small>
</div>
</div>

<div style="float:right">
<div class=box style='width:150px'>
<h1 class=t5>CPAN RT</h1>
<div style="margin:2px">
<table style="margin-left:auto;margin-right:auto">
<tr><td>Open&nbsp;</td><td style="text-align:right"> 0</td></tr>
</table>
<a href="https://rt.cpan.org/Public/Dist/Display.html?Name=ParseLex">View/Report Bugs</a><br/>
</div>
</div>

</div>
</div>
  Module Version:  2.21 &nbsp;
<span class="noprint">
  <a href="/src/PSCUST/ParseLex-2.21/lib/Parse/Lex.pm">Source</a> &nbsp;
</span>
<a name="___top"></a>
<div class=pod>
<div class=toc>
<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Start_Conditions'>Start Conditions</a>
    <li class='indexItem indexItem2'><a href='#Methods'>Methods</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ERROR_HANDLING'>ERROR HANDLING</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGMENTS'>ACKNOWLEDGMENTS</a>
  <li class='indexItem indexItem1'><a href='#REFERENCES'>REFERENCES</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><code>Parse::Lex</code> - Generator of lexical analyzers - moving pointer inside text</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl">        require 5.005;

        use Parse::Lex;
        @token = (
          qw(
             ADDOP    [-+]
             LEFTP    [\(]
             RIGHTP   [\)]
             INTEGER  [1-9][0-9]*
             NEWLINE  \n
             
            ),
          qw(STRING),   [qw(&#34; (?:[^&#34;]+|&#34;&#34;)* &#34;)],
          qw(ERROR  .*), sub {
            die qq!can\&#39;t analyze: &#34;$_[1]&#34;!;
          }
         );

        Parse::Lex-&#62;trace;  # Class method
        $lexer = Parse::Lex-&#62;new(@token);
        $lexer-&#62;from(\*DATA);
        print &#34;Tokenization of DATA:\n&#34;;

        TOKEN:while (1) {
          $token = $lexer-&#62;next;
          if (not $lexer-&#62;eoi) {
            print &#34;Line $.\t&#34;;
            print &#34;Type: &#34;, $token-&#62;name, &#34;\t&#34;;
            print &#34;Content:-&#62;&#34;, $token-&#62;text, &#34;&#60;-\n&#34;;
          } else {
            last TOKEN;
          }
        }

        __END__
        1+2-5
        &#34;a multiline
        string with an embedded &#34;&#34; in it&#34;
        an invalid string with a &#34;&#34; in it&#34;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>The classes <code>Parse::Lex</code> and <code>Parse::CLex</code> create lexical analyzers. They use different analysis techniques:</p>

<p>1. <code>Parse::Lex</code> steps through the analysis by moving a pointer within the character strings to be analyzed (use of <code>pos()</code> together with <code>\G</code>),</p>

<p>2. <code>Parse::CLex</code> steps through the analysis by consuming the data recognized (use of <code>s///</code>).</p>

<p>Analyzers of the <code>Parse::CLex</code> class do not allow the use of anchoring in regular expressions. In addition, the subclasses of <code>Parse::Token</code> are not implemented for this type of analyzer.</p>

<p>A lexical analyzer is specified by means of a list of tokens passed as arguments to the <code>new()</code> method. Tokens are instances of the <code>Parse::Token</code> class, which comes with <code>Parse::Lex</code>. The definition of a token usually comprises two arguments: a symbolic name (like <code>INTEGER</code>), followed by a regular expression. If a sub ref (anonymous subroutine) is given as third argument, it is called when the token is recognized. Its arguments are the <code>Parse::Token</code> instance and the string recognized by the regular expression. The anonymous subroutine&#39;s return value is used as the new string contents of the <code>Parse::Token</code> instance.</p>

<p>The order in which the lexical analyzer examines the regular expressions is determined by the order in which these expressions are passed as arguments to the <code>new()</code> method. The token returned by the lexical analyzer corresponds to the first regular expression which matches (this strategy is different from that used by Lex, which returns the longest match possible out of all that can be recognized).</p>

<p>The lexical analyzer can recognize tokens which span multiple records. If the definition of the token comprises more than one regular expression (placed within a reference to an anonymous array), the analyzer reads as many records as required to recognize the token (see the documentation for the <code>Parse::Token</code> class). When the start pattern is found, the analyzer looks for the end, and if necessary, reads more records. No backtracking is done in case of failure.</p>

<p>The analyzer can be used to analyze an isolated character string or a stream of data coming from a file handle. At the end of the input data the analyzer returns a <code>Parse::Token</code> instance named <code>EOI</code> (End Of Input).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Start_Conditions"
>Start Conditions</a></h2>

<p>You can associate start conditions with the token-recognition rules that comprise your lexical analyzer (this is similar to what Flex provides). When start conditions are used, the rule which succeeds is no longer necessarily the first rule that matches.</p>

<p>A token symbol may be preceded by a start condition specifier for the associated recognition rule. For example:</p>

<pre class="sh_perl">        qw(C1:TERMINAL_1  REGEXP), sub { # associated action },
        qw(TERMINAL_2  REGEXP), sub { # associated action },</pre>

<p>Symbol <code>TERMINAL_1</code> will be recognized only if start condition <code>C1</code> is active. Start conditions are activated/deactivated using the <code>start(CONDITION_NAME)</code> and <code>end(CONDITION_NAME)</code> methods.</p>

<p><code>start(&#39;INITIAL&#39;)</code> resets the analysis automaton.</p>

<p>Start conditions can be combined using AND/OR operators as follows:</p>

<pre class="sh_perl">        C1:SYMBOL      condition C1

        C1:C2:SYMBOL   condition C1 AND condition C2

        C1,C2:SYMBOL   condition C1 OR  condition C2</pre>

<p>There are two types of start conditions: <i>inclusive</i> and <i>exclusive</i>, which are declared by class methods <code>inclusive()</code> and <code>exclusive()</code> respectively. With an inclusive start condition, all rules are active regardless of whether or not they are qualified with the start condition. With an exclusive start condition, only the rules qualified with the start condition are active; all other rules are deactivated.</p>

<p>Example (borrowed from the documentation of Flex):</p>

<pre class="sh_perl"> use Parse::Lex;
 @token = (
          &#39;EXPECT&#39;, &#39;expect-floats&#39;, sub {
            $lexer-&#62;start(&#39;expect&#39;); 
            $_[1] 
          },
          &#39;expect:FLOAT&#39;, &#39;\d+\.\d+&#39;, sub { 
            print &#34;found a float: $_[1]\n&#34;;
            $_[1] 
          },
          &#39;expect:NEWLINE&#39;, &#39;\n&#39;, sub { 
            $lexer-&#62;end(&#39;expect&#39;) ;
            $_[1] 
          },
          &#39;NEWLINE2&#39;, &#39;\n&#39;,
          &#39;INT&#39;, &#39;\d+&#39;, sub {
            print &#34;found an integer: $_[1] \n&#34;;
            $_[1] 
          },
          &#39;DOT&#39;, &#39;\.&#39;, sub {
            print &#34;found a dot\n&#34;;
            $_[1] 
          },
         );

 Parse::Lex-&#62;exclusive(&#39;expect&#39;);
 $lexer = Parse::Lex-&#62;new(@token);</pre>

<p>The special start condition <code>ALL</code> is always verified.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Methods"
>Methods</a></h2>

<dl>
<dt><a name='analyze'></a><a name="analyze_EXPR"
>analyze EXPR</a></dt>

<dd>
<p>Analyzes <code>EXPR</code> and returns a list of pairs consisting of a token name followed by recognized text. <code>EXPR</code> can be a character string or a reference to a filehandle.</p>

<p>Examples:</p>

<pre class="sh_perl"> @tokens = Parse::Lex-&#62;new(qw(PLUS [+] NUMBER \d+))-&#62;analyze(&#34;3+3+3&#34;);
 @tokens = Parse::Lex-&#62;new(qw(PLUS [+] NUMBER \d+))-&#62;analyze(\*STREAM);</pre>

<dt><a name='buffer'></a><a name="buffer_EXPR"
>buffer EXPR</a></dt>

<dd>
<dt><a name="buffer"
>buffer</a></dt>

<dd>
<p>Returns the contents of the internal buffer of the lexical analyzer. With an expression as argument, places the result of the expression in the buffer.</p>

<p>It is not advisable to directly change the contents of the buffer without changing the position of the analysis pointer (<code>pos()</code>) and the value length of the buffer (<code>length()</code>).</p>

<dt><a name='configure'></a><a name="configure(HASH)"
>configure(HASH)</a></dt>

<dd>
<p>Instance method which permits specifying a lexical analyzer. This method accepts the list of the following attribute values:</p>

<dl>
<dt><a name='From'></a><a name="From_=&#62;_EXPR"
>From =&#62; EXPR</a></dt>

<dd>
<p>This attribute plays the same role as the <code>from(EXPR)</code> method. <code>EXPR</code> can be a filehandle or a character string.</p>

<dt><a name='Tokens'></a><a name="Tokens_=&#62;_ARRAY_REF"
>Tokens =&#62; ARRAY_REF</a></dt>

<dd>
<p><code>ARRAY_REF</code> must contain the list of attribute values specifying the tokens to be recognized (see the documentation for <code>Parse::Token</code>).</p>

<dt><a name='Skip'></a><a name="Skip_=&#62;_REGEX"
>Skip =&#62; REGEX</a></dt>

<dd>
<p>This attribute plays the same role as the <code>skip(REGEX)</code> method. <code>REGEX</code> describes the patterns to skip over during the analysis.</p>
</dd>
</dl>

<dt><a name='end'></a><a name="end_EXPR"
>end EXPR</a></dt>

<dd>
<p>Deactivates condition <code>EXPR</code>.</p>

<dt><a name="eoi"
>eoi</a></dt>

<dd>
<p>Returns TRUE when there is no more data to analyze.</p>

<dt><a name='every'></a><a name="every_SUB"
>every SUB</a></dt>

<dd>
<p>Avoids having to write a reading loop in order to analyze a stream of data. <code>SUB</code> is an anonymous subroutine executed after the recognition of each token. For example, to lex the string &#34;1+2&#34; you can write:</p>

<pre class="sh_perl">        use Parse::Lex;

        $lexer = Parse::Lex-&#62;new(
          qw(
             ADDOP [-+]
             INTEGER \d+
            ));

        $lexer-&#62;from(&#34;1+2&#34;);
        $lexer-&#62;every (sub { 
          print $_[0]-&#62;name, &#34;\t&#34;;
          print $_[0]-&#62;text, &#34;\n&#34;; 
        });</pre>

<p>The first argument of the anonymous subroutine is the <code>Parse::Token</code> instance recognized.</p>

<dt><a name='exclusive'></a><a name="exclusive_LIST"
>exclusive LIST</a></dt>

<dd>
<p>Class method declaring the conditions present in LIST to be <i>exclusive</i>.</p>

<dt><a name="flush"
>flush</a></dt>

<dd>
<p>If saving of the consumed strings is activated, <code>flush()</code> returns and clears the buffer containing the character strings recognized up to now. This is only useful if <code>hold()</code> has been called to activate saving of consumed strings.</p>

<dt><a name='from'></a><a name="from_EXPR"
>from EXPR</a></dt>

<dd>
<dt><a name="from"
>from</a></dt>

<dd>
<p><code>from(EXPR)</code> allows specifying the source of the data to be analyzed. The argument of this method can be a string (or list of strings), or a reference to a filehandle. If no argument is given, <code>from()</code> returns the filehandle if defined, or <code>undef</code> if input is a string. When an argument <code>EXPR</code> is used, the return value is the calling lexer object itself.</p>

<p>By default it is assumed that data are read from <code>STDIN</code>.</p>

<p>Examples:</p>

<pre class="sh_perl">        $handle = new IO::File;
        $handle-&#62;open(&#34;&#60; filename&#34;);
        $lexer-&#62;from($handle);

        $lexer-&#62;from(\*DATA);
        $lexer-&#62;from(&#39;the data to be analyzed&#39;);</pre>

<dt><a name="getSub"
>getSub</a></dt>

<dd>
<p><code>getSub</code> returns the anonymous subroutine that performs the lexical analysis.</p>

<p>Example:</p>

<pre class="sh_perl">        my $token = &#39;&#39;;
        my $sub = $lexer-&#62;getSub;
        while (($token = &#38;$sub()) ne $Token::EOI) {
          print $token-&#62;name, &#34;\t&#34;;
          print $token-&#62;text, &#34;\n&#34;;
        }
    
   # or 
        
        my $token = &#39;&#39;;
        local *tokenizer = $lexer-&#62;getSub;
        while (($token = tokenizer()) ne $Token::EOI) {
          print $token-&#62;name, &#34;\t&#34;;
          print $token-&#62;text, &#34;\n&#34;;
        }</pre>

<dt><a name="getToken"
>getToken</a></dt>

<dd>
<p>Same as <code>token()</code> method.</p>

<dt><a name='hold'></a><a name="hold_EXPR"
>hold EXPR</a></dt>

<dd>
<dt><a name="hold"
>hold</a></dt>

<dd>
<p>Activates/deactivates saving of the consumed strings. The return value is the current setting (TRUE or FALSE). Can be used as a class method.</p>

<p>You can obtain the contents of the buffer using the <code>flush</code> method, which also empties the buffer.</p>

<dt><a name='inclusive'></a><a name="inclusive_LIST"
>inclusive LIST</a></dt>

<dd>
<p>Class method declaring the conditions present in LIST to be <i>inclusive</i>.</p>

<dt><a name='length'></a><a name="length_EXPR"
>length EXPR</a></dt>

<dd>
<dt><a name="length"
>length</a></dt>

<dd>
<p>Returns the length of the current record. <code>length EXPR</code> sets the length of the current record.</p>

<dt><a name='line'></a><a name="line_EXPR"
>line EXPR</a></dt>

<dd>
<dt><a name="line"
>line</a></dt>

<dd>
<p>Returns the line number of the current record. <code>line EXPR</code> sets the value of the line number. Always returns 1 if a character string is being analyzed. The <code>readline()</code> method increments the line number.</p>

<dt><a name='name'></a><a name="name_EXPR"
>name EXPR</a></dt>

<dd>
<dt><a name="name"
>name</a></dt>

<dd>
<p><code>name EXPR</code> lets you give a name to the lexical analyzer. <code>name()</code> return the value of this name.</p>

<dt><a name="next"
>next</a></dt>

<dd>
<p>Causes searching for the next token. Return the recognized <code>Parse::Token</code> instance. Returns the <code>Token::EOI</code> instance at the end of the data.</p>

<p>Examples:</p>

<pre class="sh_perl">        $lexer = Parse::Lex-&#62;new(@token);
        print $lexer-&#62;next-&#62;name;   # print the token type
        print $lexer-&#62;next-&#62;text;   # print the token content</pre>

<dt><a name='nextis'></a><a name="nextis_SCALAR_REF"
>nextis SCALAR_REF</a></dt>

<dd>
<p>Variant of the <code>next()</code> method. Tokens are placed in <code>SCALAR_REF</code>. The method returns 1 as long as the token is not <code>EOI</code>.</p>

<p>Example:</p>

<pre class="sh_perl">        while($lexer-&#62;nextis(\$token)) {
           print $token-&#62;text();
        }</pre>

<dt><a name='new'></a><a name="new_LIST"
>new LIST</a></dt>

<dd>
<p>Creates and returns a new lexical analyzer. The argument of the method is a list of <code>Parse::Token</code> instances, or a list of triplets permitting their creation. The triplets consist of: the symbolic name of the token, the regular expression necessary for its recognition, and possibly an anonymous subroutine that is called when the token is recognized. For each triplet, an instance of type <code>Parse::Token</code> is created in the calling package.</p>

<dt><a name="offset"
>offset</a></dt>

<dd>
<p>Returns the number of characters already consumed since the beginning of the analyzed data stream.</p>

<dt><a name='pos'></a><a name="pos_EXPR"
>pos EXPR</a></dt>

<dd>
<dt><a name="pos"
>pos</a></dt>

<dd>
<p><code>pos EXPR</code> sets the position of the beginning of the next token to be recognized in the current line (this doesn&#39;t work with analyzers of the <code>Parse::CLex</code> class). <code>pos()</code> returns the number of characters already consumed in the current line.</p>

<dt><a name="readline"
>readline</a></dt>

<dd>
<p>Reads data from the input specified by the <code>from()</code> method. Returns the result of the reading.</p>

<p>Example:</p>

<pre class="sh_perl">        use Parse::Lex;

        $lexer = Parse::Lex-&#62;new();
        while (not $lexer-&#62;eoi) {
          print $lexer-&#62;readline() # read and print one line
        }</pre>

<dt><a name="reset"
>reset</a></dt>

<dd>
<p>Clears the internal buffer of the lexical analyzer and erases all tokens already recognized.</p>

<dt><a name="restart"
>restart</a></dt>

<dd>
<p>Reinitializes the analysis automaton. The only active condition becomes the condition <code>INITIAL</code>.</p>

<dt><a name='setToken'></a><a name="setToken_TOKEN"
>setToken TOKEN</a></dt>

<dd>
<p>Sets the token to <code>TOKEN</code>. Useful to requalify a token inside the anonymous subroutine associated with this token.</p>

<dt><a name='skip'></a><a name="skip_EXPR"
>skip EXPR</a></dt>

<dd>
<dt><a name="skip"
>skip</a></dt>

<dd>
<p><code>EXPR</code> is a regular expression defining the token separator pattern (by default <code>[ \t]+</code>). <code>skip(&#39;&#39;)</code> sets this to no pattern. With no argument, <code>skip()</code> returns the value of the pattern. <code>skip()</code> can be used as a class method.</p>

<p>Changing the skip pattern causes recompilation of the lexical analyzer.</p>

<p>Example:</p>

<pre class="sh_perl">  Parse::Lex-&#62;skip(&#39;\s*#(?s:.*)|\s+&#39;);
  @tokens = Parse::Lex-&#62;new(&#39;INTEGER&#39; =&#62; &#39;\d+&#39;)-&#62;analyze(\*DATA);
  print &#34;@tokens\n&#34;; # print INTEGER 1 INTEGER 2 INTEGER 3 INTEGER 4 EOI 
  __END__
  1 # first string to skip
  2
  3# second string to skip
  4</pre>

<dt><a name='start'></a><a name="start_EXPR"
>start EXPR</a></dt>

<dd>
<p>Activates condition EXPR.</p>

<dt><a name='state'></a><a name="state_EXPR"
>state EXPR</a></dt>

<dd>
<p>Returns the state of the condition represented by EXPR.</p>

<dt><a name="token"
>token</a></dt>

<dd>
<p>Returns the instance corresponding to the last recognized token. In case no token was recognized, return the special token named <code>DEFAULT</code>.</p>

<dt><a name='tokenClass'></a><a name="tokenClass_EXPR"
>tokenClass EXPR</a></dt>

<dd>
<dt><a name="tokenClass"
>tokenClass</a></dt>

<dd>
<p>Indicates which is the class of the tokens to be created from the list passed as argument to the <code>new()</code> method. If no argument is given, returns the name of the class. By default the class is <code>Parse::Token</code>.</p>

<dt><a name='trace'></a><a name="trace_OUTPUT"
>trace OUTPUT</a></dt>

<dd>
<dt><a name="trace"
>trace</a></dt>

<dd>
<p>Class method which activates trace mode. The activation of trace mode must take place before the creation of the lexical analyzer. The mode can then be deactivated by another call of this method.</p>

<p><code>OUTPUT</code> can be a file name or a reference to a filehandle where the trace will be redirected.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ERROR_HANDLING"
>ERROR HANDLING <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>To handle the cases of token non-recognition, you can define a specific token at the end of the list of tokens that comprise our lexical analyzer. If searching for this token succeeds, it is then possible to call an error handling function:</p>

<pre class="sh_perl">     qw(ERROR  (?s:.*)), sub {
       print STDERR &#34;ERROR: buffer content-&#62;&#34;, $_[0]-&#62;lexer-&#62;buffer, &#34;&#60;-\n&#34;;
       die qq!can\&#39;t analyze: &#34;$_[1]&#34;!;
     }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>ctokenizer.pl - Scan a stream of data using the <code>Parse::CLex</code> class.</p>

<p>tokenizer.pl - Scan a stream of data using the <code>Parse::Lex</code> class.</p>

<p>every.pl - Use of the <code>every</code> method.</p>

<p>sexp.pl - Interpreter for prefix arithmetic expressions.</p>

<p>sexpcond.pl - Interpeter for prefix arithmetic expressions, using conditions.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Analyzers of the <code>Parse::CLex</code> class do not allow the use of regular expressions with anchoring.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><code><a href="/~pscust/ParseLex-2.21/lib/Parse/Token.pm" class="podlinkpod"
>Parse::Token</a></code>, <code><a href="/~pscust/ParseLex-2.21/lib/Parse/LexEvent.pm" class="podlinkpod"
>Parse::LexEvent</a></code>, <code><a href="/~pscust/ParseLex-2.21/lib/Parse/YYLex.pm" class="podlinkpod"
>Parse::YYLex</a></code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Philippe Verdret. Documentation translated to English by Vladimir Alexiev and Ocrat.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGMENTS"
>ACKNOWLEDGMENTS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Version 2.0 owes much to suggestions made by Vladimir Alexiev. Ocrat has significantly contributed to improving this documentation. Thanks also to the numerous people who have sent me bug reports and occasionally fixes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="REFERENCES"
>REFERENCES <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Friedl, J.E.F. Mastering Regular Expressions. O&#39;Reilly &#38; Associates 1996.</p>

<p>Mason, T. &#38; Brown, D. - Lex &#38; Yacc. O&#39;Reilly &#38; Associates, Inc. 1990.</p>

<p>FLEX - A Scanner generator (available at <a href="ftp://ftp.ee.lbl.gov/" class="podlinkurl"
>ftp://ftp.ee.lbl.gov/</a> and elsewhere)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Copyright (c) 1995-1999 Philippe Verdret. All rights reserved. This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

</div>
<!-- This should probably be put in the <div class="footer"></div> -->
<script type="text/javascript">
    $(document).ready(function(){
        var startingStyle = $.cookie('css') ? $.cookie('css') : 'http://st.pimg.net/tucs/css/sh_none.min.css';
        $.fn.styleSwitch(startingStyle);
        $("#styleswitch").val(startingStyle);
        sh_highlightDocument();
        $("#styleswitch").bind(($.browser.msie ? "click" : "change"), function() {
            $.fn.styleSwitch($(this).val());
        });
    });
</script>
<div class="styleswitch">
    syntax highlighting:
    <select id="styleswitch">
        <option value="http://st.pimg.net/tucs/css/sh_none.min.css">no syntax highlighting</option>
        <option value="http://st.pimg.net/tucs/css/sh_acid.min.css">acid</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-dark.min.css">berries-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-light.min.css">berries-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_bipolar.min.css">bipolar</option>
        <option value="http://st.pimg.net/tucs/css/sh_blacknblue.min.css">blacknblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_bright.min.css">bright</option>
        <option value="http://st.pimg.net/tucs/css/sh_contrast.min.css">contrast</option>
        <option value="http://st.pimg.net/tucs/css/sh_cpan.min.css">cpan</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkblue.min.css">darkblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkness.min.css">darkness</option>
        <option value="http://st.pimg.net/tucs/css/sh_desert.min.css">desert</option>
        <option value="http://st.pimg.net/tucs/css/sh_dull.min.css">dull</option>
        <option value="http://st.pimg.net/tucs/css/sh_easter.min.css">easter</option>
        <option value="http://st.pimg.net/tucs/css/sh_emacs.min.css">emacs</option>
        <option value="http://st.pimg.net/tucs/css/sh_golden.min.css">golden</option>
        <option value="http://st.pimg.net/tucs/css/sh_greenlcd.min.css">greenlcd</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-anjuta.min.css">ide-anjuta</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-codewarrior.min.css">ide-codewarrior</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-devcpp.min.css">ide-devcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-eclipse.min.css">ide-eclipse</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-kdev.min.css">ide-kdev</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-msvcpp.min.css">ide-msvcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_kwrite.min.css">kwrite</option>
        <option value="http://st.pimg.net/tucs/css/sh_matlab.min.css">matlab</option>
        <option value="http://st.pimg.net/tucs/css/sh_navy.min.css">navy</option>
        <option value="http://st.pimg.net/tucs/css/sh_nedit.min.css">nedit</option>
        <option value="http://st.pimg.net/tucs/css/sh_neon.min.css">neon</option>
        <option value="http://st.pimg.net/tucs/css/sh_night.min.css">night</option>
        <option value="http://st.pimg.net/tucs/css/sh_pablo.min.css">pablo</option>
        <option value="http://st.pimg.net/tucs/css/sh_peachpuff.min.css">peachpuff</option>
        <option value="http://st.pimg.net/tucs/css/sh_print.min.css">print</option>
        <option value="http://st.pimg.net/tucs/css/sh_rand01.min.css">rand01</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-dark.min.css">solarized-dark</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-light.min.css">solarized-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_style.min.css">style</option>
        <option value="http://st.pimg.net/tucs/css/sh_the.min.css">the</option>
        <option value="http://st.pimg.net/tucs/css/sh_typical.min.css">typical</option>
        <option value="http://st.pimg.net/tucs/css/sh_vampire.min.css">vampire</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim-dark.min.css">vim-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim.min.css">vim</option>
        <option value="http://st.pimg.net/tucs/css/sh_whatis.min.css">whatis</option>
        <option value="http://st.pimg.net/tucs/css/sh_whitengrey.min.css">whitengrey</option>
        <option value="http://st.pimg.net/tucs/css/sh_zellner.min.css">zellner</option>
    </select>
</div>



<div class="footer"><div class="cpanstats">78275 Uploads, 24724 Distributions
106002 Modules, 9649 Uploaders
</div>
hosted by <a href="http://www.yellowbot.com">YellowBot</a><br/>
<a href="http://www.yellowbot.com"><img alt="do. tag. write. share." src="http://st.pimg.net/tucs/img/yellowbot_logo.gif"></a>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="http://ipv4.v6test.develooper.com/js/v1/v6test.js"></script>

<script type="text/javascript">
   // v6.target = '';
   if (!v6.target) { v6.only_once = true }
   v6.site = '7A0D89A6-2B82-11DF-B9DA-F61CBD13F020';
   v6.api_server = 'http://ipv4.v6test.develooper.com';
   try {
     v6.test();
   } catch(err) {}
</script>
<script type="text/javascript">
  $(document).ready(function(){
    $("a[href^=http:]").click(function(){
      var href = $(this).attr('href');
      var m = href.match('\/\/([^\/:]+)');
      _gaq.push(['_trackEvent','External',m[1],'Module']);
    });
    $("a[href^=/CPAN/]").click(function(){
      var href = $(this).attr('href');
      _gaq.push(['_trackEvent','Download',href,'Module']);
    });
  });
</script>
<!-- Sat Apr 28 01:09:38 2012 GMT (0.0773248672485352) @cpansearch1 -->
 </body>
</html>
