<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <link rel="stylesheet" href="http://st.pimg.net/tucs/style.css" type="text/css" />
<style>
.styleswitch {
  text-align: right;
}
</style>


<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.cookie.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_main.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_perl.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.styleswitch.js"></script>

<link rel="stylesheet" href="http://st.pimg.net/tucs/print.css" type="text/css" media="print" />
  <link rel="alternate" type="application/rss+xml" title="RSS 1.0" href="http://search.cpan.org/uploads.rdf" />
  <link rel="search" href="http://st.pimg.net/tucs/opensearch.xml" type="application/opensearchdescription+xml" title="SearchCPAN" />
  <title>Text::CSV - search.cpan.org</title>
 <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3528438-1']);
    _gaq.push(["_setCustomVar",2,"Distribution","Text-CSV",3]);
    _gaq.push(["_setCustomVar",5,"Release","Text-CSV-1.21",3]);
    _gaq.push(["_setCustomVar",3,"Module","Text::CSV",3]);
    _gaq.push(["_setCustomVar",1,"Author","MAKAMAKA",3]);
    _gaq.push(['_trackPageview']);
  </script>
 </head>
 <body id="cpansearch">
<center><div class="logo"><a href="/"><img src="http://st.pimg.net/tucs/img/cpan_banner.png" alt="CPAN"></a></div></center>
<div class="menubar">
 <a href="/">Home</a>
&middot; <a href="/author/">Authors</a>
&middot; <a href="/recent">Recent</a>
&middot; <a href="http://log.perl.org/cpansearch/">News</a>
&middot; <a href="/mirror">Mirrors</a>
&middot; <a href="/faq.html">FAQ</a>
&middot; <a href="/feedback">Feedback</a>
</div>
<form method="get" action="/search" name="f" class="searchbox">
<input type="text" name="query" value="" size="35">
<br>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</form>


 <a name="_top"></a>
  <div class=path>
<div id=permalink class="noprint"><a href="/perldoc?Text::CSV">permalink</a></div>
  <a href="/~makamaka/">Makamaka Hannyaharamitu</a> &gt;
  <a href="/~makamaka/Text-CSV-1.21/">Text-CSV-1.21</a> &gt;
  Text::CSV
 </div>

<div class="noprint" style="float:right;align:left;width:19ex">
<a href="http://hexten.net/cpan-faces/"><img src="http://www.gravatar.com/avatar/36daaac2532981268006980d18ed4795?r=g&s=80&d=http%3A%2F%2Fst.pimg.net%2Ftucs%2Fimg%2Fwho.png" width=80 height=80 
style="float:right"
/></a>
<br style="clear:both"/>
<p style="text-align:right">Download:<br/> <a href="/CPAN/authors/id/M/MA/MAKAMAKA/Text-CSV-1.21.tar.gz">Text-CSV-1.21.tar.gz</a></p>
<p style="text-align:right"><a href="http://deps.cpantesters.org/?module=Text%3A%3ACSV;perl=latest">Dependencies</a></p>
<p style="text-align:right"><a href="http://www.annocpan.org/~MAKAMAKA/Text-CSV-1.21/lib/Text/CSV.pm">Annotate this POD
(3)
</a></p>
<div class=box style='width:150px; float: right'>
<h1 class=t5>Related Modules</h1>
<div style="margin:2px">
<a href="/perldoc?Text%3A%3ACSV_XS">Text::CSV_XS</a><br>
<a href="/perldoc?Text%3A%3AxSV">Text::xSV</a><br>
<a href="/perldoc?DBD%3A%3ACSV">DBD::CSV</a><br>
<a href="/perldoc?Data%3A%3ADumper">Data::Dumper</a><br>
<a href="/perldoc?DBD%3A%3AAnyData">DBD::AnyData</a><br>
<a href="/perldoc?Text%3A%3AParseWords">Text::ParseWords</a><br>
<a href="/perldoc?CGI%3A%3AApplication">CGI::Application</a><br>
<a href="/perldoc?Win32%3A%3AOLE">Win32::OLE</a><br>
<a href="/perldoc?HTML%3A%3ATemplate">HTML::Template</a><br>
<a href="/perldoc?XML%3A%3AXSLT">XML::XSLT</a><br>
<small>
<a href="http://perlmonks.org/?node=cpan+module+search&pivot=1&module=Text%3A%3ACSV">more...</a><br>
By <a href="http://perlmonks.org/">perlmonks.org</a></small>
</div>
</div>

<div style="float:right">
<div class=box style='width:150px'>
<h1 class=t5>CPAN RT</h1>
<div style="margin:2px">
<table style="margin-left:auto;margin-right:auto">
<tr><td>New&nbsp;</td><td style="text-align:right"> 3</td></tr>
<tr><td>Open&nbsp;</td><td style="text-align:right"> 3</td></tr>
</table>
<a href="https://rt.cpan.org/Public/Dist/Display.html?Name=Text-CSV">View/Report Bugs</a><br/>
</div>
</div>

</div>
</div>
  Module Version:  1.21 &nbsp;
<span class="noprint">
  <a href="/src/MAKAMAKA/Text-CSV-1.21/lib/Text/CSV.pm">Source</a> &nbsp;
</span>
<a name="___top"></a>
<div class=pod>
<div class=toc>
<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Embedded_newlines'>Embedded newlines</a>
    <li class='indexItem indexItem2'><a href='#Unicode_(UTF8)'>Unicode (UTF8)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SPECIFICATION'>SPECIFICATION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#version_()'>version ()</a>
    <li class='indexItem indexItem2'><a href='#new_(\%attr)'>new (\%attr)</a>
    <li class='indexItem indexItem2'><a href='#print'>print</a>
    <li class='indexItem indexItem2'><a href='#combine'>combine</a>
    <li class='indexItem indexItem2'><a href='#string'>string</a>
    <li class='indexItem indexItem2'><a href='#getline'>getline</a>
    <li class='indexItem indexItem2'><a href='#getline_all'>getline_all</a>
    <li class='indexItem indexItem2'><a href='#parse'>parse</a>
    <li class='indexItem indexItem2'><a href='#getline_hr'>getline_hr</a>
    <li class='indexItem indexItem2'><a href='#getline_hr_all'>getline_hr_all</a>
    <li class='indexItem indexItem2'><a href='#column_names'>column_names</a>
    <li class='indexItem indexItem2'><a href='#bind_columns'>bind_columns</a>
    <li class='indexItem indexItem2'><a href='#eof'>eof</a>
    <li class='indexItem indexItem2'><a href='#types'>types</a>
    <li class='indexItem indexItem2'><a href='#fields'>fields</a>
    <li class='indexItem indexItem2'><a href='#meta_info'>meta_info</a>
    <li class='indexItem indexItem2'><a href='#is_quoted'>is_quoted</a>
    <li class='indexItem indexItem2'><a href='#is_binary'>is_binary</a>
    <li class='indexItem indexItem2'><a href='#status'>status</a>
    <li class='indexItem indexItem2'><a href='#error_input'>error_input</a>
    <li class='indexItem indexItem2'><a href='#error_diag'>error_diag</a>
    <li class='indexItem indexItem2'><a href='#SetDiag'>SetDiag</a>
    <li class='indexItem indexItem2'><a href='#Some_methods_are_Text::CSV_only.'>Some methods are Text::CSV only.</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DIAGNOSTICS'>DIAGNOSTICS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#HISTORY_AND_WORKER_MODULES'>HISTORY AND WORKER MODULES</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TODO'>TODO</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_and_MAINTAINERS'>AUTHORS and MAINTAINERS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Text::CSV - comma-separated values manipulator (using XS or PurePerl)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl"> use Text::CSV;

 my @rows;
 my $csv = Text::CSV-&#62;new ( { binary =&#62; 1 } )  # should set binary attribute.
                 or die &#34;Cannot use CSV: &#34;.Text::CSV-&#62;error_diag ();
 
 open my $fh, &#34;&#60;:encoding(utf8)&#34;, &#34;test.csv&#34; or die &#34;test.csv: $!&#34;;
 while ( my $row = $csv-&#62;getline( $fh ) ) {
     $row-&#62;[2] =~ m/pattern/ or next; # 3rd field should match
     push @rows, $row;
 }
 $csv-&#62;eof or $csv-&#62;error_diag();
 close $fh;

 $csv-&#62;eol (&#34;\r\n&#34;);
 
 open $fh, &#34;&#62;:encoding(utf8)&#34;, &#34;new.csv&#34; or die &#34;new.csv: $!&#34;;
 $csv-&#62;print ($fh, $_) for @rows;
 close $fh or die &#34;new.csv: $!&#34;;
 
 #
 # parse and combine style
 #
 
 $status = $csv-&#62;combine(@columns);    # combine columns into a string
 $line   = $csv-&#62;string();             # get the combined string
 
 $status  = $csv-&#62;parse($line);        # parse a CSV string into fields
 @columns = $csv-&#62;fields();            # get the parsed fields
 
 $status       = $csv-&#62;status ();      # get the most recent status
 $bad_argument = $csv-&#62;error_input (); # get the most recent bad argument
 $diag         = $csv-&#62;error_diag ();  # if an error occured, explains WHY
 
 $status = $csv-&#62;print ($io, $colref); # Write an array of fields
                                       # immediately to a file $io
 $colref = $csv-&#62;getline ($io);        # Read a line from file $io,
                                       # parse it and return an array
                                       # ref of fields
 $csv-&#62;column_names (@names);          # Set column names for getline_hr ()
 $ref = $csv-&#62;getline_hr ($io);        # getline (), but returns a hashref
 $eof = $csv-&#62;eof ();                  # Indicate if last parse or
                                       # getline () hit End Of File
 
 $csv-&#62;types(\@t_array);               # Set column types</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Text::CSV provides facilities for the composition and decomposition of comma-separated values using <a href="/perldoc?Text%3A%3ACSV_XS" class="podlinkpod"
>Text::CSV_XS</a> or its pure Perl version.</p>

<p>An instance of the Text::CSV class can combine fields into a CSV string and parse a CSV string into fields.</p>

<p>The module accepts either strings or files as input and can utilize any user-specified characters as delimiters, separators, and escapes so it is perhaps better called ASV (anything separated values) rather than just CSV.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl">    1.21</pre>

<p>This module is compatible with Text::CSV_XS <b>0.80</b> and later.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Embedded_newlines"
>Embedded newlines</a></h2>

<p><b>Important Note</b>: The default behavior is to only accept ASCII characters. This means that fields can not contain newlines. If your data contains newlines embedded in fields, or characters above 0x7e (tilde), or binary data, you *must* set <code>binary =&#62; 1</code> in the call to <code>new ()</code>. To cover the widest range of parsing options, you will always want to set binary.</p>

<p>But you still have the problem that you have to pass a correct line to the <code>parse ()</code> method, which is more complicated from the usual point of usage:</p>

<pre class="sh_perl"> my $csv = Text::CSV-&#62;new ({ binary =&#62; 1, eol =&#62; $/ });
 while (&#60;&#62;) {           #  WRONG!
     $csv-&#62;parse ($_);
     my @fields = $csv-&#62;fields ();</pre>

<p>will break, as the while might read broken lines, as that does not care about the quoting. If you need to support embedded newlines, the way to go is either</p>

<pre class="sh_perl"> my $csv = Text::CSV-&#62;new ({ binary =&#62; 1, eol =&#62; $/ });
 while (my $row = $csv-&#62;getline (*ARGV)) {
     my @fields = @$row;</pre>

<p>or, more safely in perl 5.6 and up</p>

<pre class="sh_perl"> my $csv = Text::CSV-&#62;new ({ binary =&#62; 1, eol =&#62; $/ });
 open my $io, &#34;&#60;&#34;, $file or die &#34;$file: $!&#34;;
 while (my $row = $csv-&#62;getline ($io)) {
     my @fields = @$row;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unicode_(UTF8)"
>Unicode (UTF8)</a></h2>

<p>On parsing (both for <code>getline ()</code> and <code>parse ()</code>), if the source is marked being UTF8, then all fields that are marked binary will also be be marked UTF8.</p>

<p>For complete control over encoding, please use <a href="/perldoc?Text%3A%3ACSV%3A%3AEncoded" class="podlinkpod"
>Text::CSV::Encoded</a>:</p>

<pre class="sh_perl">    use Text::CSV::Encoded;
    my $csv = Text::CSV::Encoded-&#62;new ({
        encoding_in  =&#62; &#34;iso-8859-1&#34;, # the encoding comes into   Perl
        encoding_out =&#62; &#34;cp1252&#34;,     # the encoding comes out of Perl
    });

    $csv = Text::CSV::Encoded-&#62;new ({ encoding  =&#62; &#34;utf8&#34; });
    # combine () and print () accept *literally* utf8 encoded data
    # parse () and getline () return *literally* utf8 encoded data

    $csv = Text::CSV::Encoded-&#62;new ({ encoding  =&#62; undef }); # default
    # combine () and print () accept UTF8 marked data
    # parse () and getline () return UTF8 marked data</pre>

<p>On combining (<code>print ()</code> and <code>combine ()</code>), if any of the combining fields was marked UTF8, the resulting string will be marked UTF8.</p>

<p>Note however if the backend module is Text::CSV_XS, that all fields <code>before</code> the first field that was marked UTF8 and contained 8-bit characters that were not upgraded to UTF8, these will be bytes in the resulting string too, causing errors. If you pass data of different encoding, or you don&#39;t know if there is different encoding, force it to be upgraded before you pass them on:</p>

<pre class="sh_perl">    # backend = Text::CSV_XS
    $csv-&#62;print ($fh, [ map { utf8::upgrade (my $x = $_); $x } @data ]);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SPECIFICATION"
>SPECIFICATION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>See to <a href="/perldoc?Text%3A%3ACSV_XS#SPECIFICATION" class="podlinkpod"
>&#34;SPECIFICATION&#34; in Text::CSV_XS</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>These methods are common between XS and puer Perl version. Most of the document was shamelessly copied and replaced from Text::CSV_XS.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="version_()"
>version ()</a></h2>

<p>(Class method) Returns the current backend module version. If you want the module version, you can use the <code>VERSION</code> method,</p>

<pre class="sh_perl"> print Text::CSV-&#62;VERSION;      # This module version
 print Text::CSV-&#62;version;      # The version of the worker module
                                # same as Text::CSV-&#62;backend-&#62;version</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new_(\%attr)"
>new (\%attr)</a></h2>

<p>(Class method) Returns a new instance of Text::CSV_XS. The objects attributes are described by the (optional) hash ref <code>\%attr</code>. Currently the following attributes are available:</p>

<dl>
<dt><a name="eol"
>eol</a></dt>

<dd>
<p>An end-of-line string to add to rows. <code>undef</code> is replaced with an empty string. The default is <code>$\</code>. Common values for <code>eol</code> are <code>&#34;\012&#34;</code> (Line Feed) or <code>&#34;\015\012&#34;</code> (Carriage Return, Line Feed). Cannot be longer than 7 (ASCII) characters.</p>

<p>If both <code>$/</code> and <code>eol</code> equal <code>&#34;\015&#34;</code>, parsing lines that end on only a Carriage Return without Line Feed, will be <code>parse</code>d correct. Line endings, whether in <code>$/</code> or <code>eol</code>, other than <code>undef</code>, <code>&#34;\n&#34;</code>, <code>&#34;\r\n&#34;</code>, or <code>&#34;\r&#34;</code> are not (yet) supported for parsing.</p>

<dt><a name="sep_char"
>sep_char</a></dt>

<dd>
<p>The char used for separating fields, by default a comma. (<code>,</code>). Limited to a single-byte character, usually in the range from 0x20 (space) to 0x7e (tilde).</p>

<p>The separation character can not be equal to the quote character. The separation character can not be equal to the escape character.</p>

<p>See also <a href="/perldoc?Text%3A%3ACSV_XS#CAVEATS" class="podlinkpod"
>&#34;CAVEATS&#34; in Text::CSV_XS</a></p>

<dt><a name="allow_whitespace"
>allow_whitespace</a></dt>

<dd>
<p>When this option is set to true, whitespace (TAB&#39;s and SPACE&#39;s) surrounding the separation character is removed when parsing. If either TAB or SPACE is one of the three major characters <code>sep_char</code>, <code>quote_char</code>, or <code>escape_char</code> it will not be considered whitespace.</p>

<p>So lines like:</p>

<pre class="sh_perl">  1 , &#34;foo&#34; , bar , 3 , zapp</pre>

<p>are now correctly parsed, even though it violates the CSV specs.</p>

<p>Note that <b>all</b> whitespace is stripped from start and end of each field. That would make it more a <i>feature</i> than a way to be able to parse bad CSV lines, as</p>

<pre class="sh_perl"> 1,   2.0,  3,   ape  , monkey</pre>

<p>will now be parsed as</p>

<pre class="sh_perl"> (&#34;1&#34;, &#34;2.0&#34;, &#34;3&#34;, &#34;ape&#34;, &#34;monkey&#34;)</pre>

<p>even if the original line was perfectly sane CSV.</p>

<dt><a name="blank_is_undef"
>blank_is_undef</a></dt>

<dd>
<p>Under normal circumstances, CSV data makes no distinction between quoted- and unquoted empty fields. They both end up in an empty string field once read, so</p>

<pre class="sh_perl"> 1,&#34;&#34;,,&#34; &#34;,2</pre>

<p>is read as</p>

<pre class="sh_perl"> (&#34;1&#34;, &#34;&#34;, &#34;&#34;, &#34; &#34;, &#34;2&#34;)</pre>

<p>When <i>writing</i> CSV files with <code>always_quote</code> set, the unquoted empty field is the result of an undefined value. To make it possible to also make this distinction when reading CSV data, the <code>blank_is_undef</code> option will cause unquoted empty fields to be set to undef, causing the above to be parsed as</p>

<pre class="sh_perl"> (&#34;1&#34;, &#34;&#34;, undef, &#34; &#34;, &#34;2&#34;)</pre>

<dt><a name="empty_is_undef"
>empty_is_undef</a></dt>

<dd>
<p>Going one step further than <code>blank_is_undef</code>, this attribute converts all empty fields to undef, so</p>

<pre class="sh_perl"> 1,&#34;&#34;,,&#34; &#34;,2</pre>

<p>is read as</p>

<pre class="sh_perl"> (1, undef, undef, &#34; &#34;, 2)</pre>

<p>Note that this only effects fields that are <i>really</i> empty, not fields that are empty after stripping allowed whitespace. YMMV.</p>

<dt><a name="quote_char"
>quote_char</a></dt>

<dd>
<p>The char used for quoting fields containing blanks, by default the double quote character (<code>&#34;</code>). A value of undef suppresses quote chars. (For simple cases only). Limited to a single-byte character, usually in the range from 0x20 (space) to 0x7e (tilde).</p>

<p>The quote character can not be equal to the separation character.</p>

<dt><a name="allow_loose_quotes"
>allow_loose_quotes</a></dt>

<dd>
<p>By default, parsing fields that have <code>quote_char</code> characters inside an unquoted field, like</p>

<pre class="sh_perl"> 1,foo &#34;bar&#34; baz,42</pre>

<p>would result in a parse error. Though it is still bad practice to allow this format, we cannot help there are some vendors that make their applications spit out lines styled like this.</p>

<p>In case there is <b>really</b> bad CSV data, like</p>

<pre class="sh_perl"> 1,&#34;foo &#34;bar&#34; baz&#34;,42</pre>

<p>or</p>

<pre class="sh_perl"> 1,&#34;&#34;foo bar baz&#34;&#34;,42</pre>

<p>there is a way to get that parsed, and leave the quotes inside the quoted field as-is. This can be achieved by setting <code>allow_loose_quotes</code> <b>AND</b> making sure that the <code>escape_char</code> is <i>not</i> equal to <code>quote_char</code>.</p>

<dt><a name="escape_char"
>escape_char</a></dt>

<dd>
<p>The character used for escaping certain characters inside quoted fields. Limited to a single-byte character, usually in the range from 0x20 (space) to 0x7e (tilde).</p>

<p>The <code>escape_char</code> defaults to being the literal double-quote mark (<code>&#34;</code>) in other words, the same as the default <code>quote_char</code>. This means that doubling the quote mark in a field escapes it:</p>

<pre class="sh_perl">  &#34;foo&#34;,&#34;bar&#34;,&#34;Escape &#34;&#34;quote mark&#34;&#34; with two &#34;&#34;quote marks&#34;&#34;&#34;,&#34;baz&#34;</pre>

<p>If you change the default quote_char without changing the default escape_char, the escape_char will still be the quote mark. If instead you want to escape the quote_char by doubling it, you will need to change the escape_char to be the same as what you changed the quote_char to.</p>

<p>The escape character can not be equal to the separation character.</p>

<dt><a name="allow_loose_escapes"
>allow_loose_escapes</a></dt>

<dd>
<p>By default, parsing fields that have <code>escape_char</code> characters that escape characters that do not need to be escaped, like:</p>

<pre class="sh_perl"> my $csv = Text::CSV-&#62;new ({ escape_char =&#62; &#34;\\&#34; });
 $csv-&#62;parse (qq{1,&#34;my bar\&#39;s&#34;,baz,42});</pre>

<p>would result in a parse error. Though it is still bad practice to allow this format, this option enables you to treat all escape character sequences equal.</p>

<dt><a name="binary"
>binary</a></dt>

<dd>
<p>If this attribute is TRUE, you may use binary characters in quoted fields, including line feeds, carriage returns and NULL bytes. (The latter must be escaped as <code>&#34;0</code>.) By default this feature is off.</p>

<p>If a string is marked UTF8, binary will be turned on automatically when binary characters other than CR or NL are encountered. Note that a simple string like <code>&#34;\x{00a0}&#34;</code> might still be binary, but not marked UTF8, so setting <code>{ binary =&#62; 1 }</code> is still a wise option.</p>

<dt><a name="types"
>types</a></dt>

<dd>
<p>A set of column types; this attribute is immediately passed to the <i>types</i> method below. You must not set this attribute otherwise, except for using the <i>types</i> method. For details see the description of the <i>types</i> method below.</p>

<dt><a name="always_quote"
>always_quote</a></dt>

<dd>
<p>By default the generated fields are quoted only, if they need to, for example, if they contain the separator. If you set this attribute to a TRUE value, then all defined fields will be quoted. This is typically easier to handle in external applications.</p>

<dt><a name="quote_space"
>quote_space</a></dt>

<dd>
<p>By default, a space in a field would trigger quotation. As no rule exists this to be forced in CSV, nor any for the opposite, the default is true for safety. You can exclude the space from this trigger by setting this option to 0.</p>

<dt><a name="quote_null"
>quote_null</a></dt>

<dd>
<p>By default, a NULL byte in a field would be escaped. This attribute enables you to treat the NULL byte as a simple binary character in binary mode (the <code>{ binary =&#62; 1 }</code> is set). The default is true. You can prevent NULL escapes by setting this attribute to 0.</p>

<dt><a name="keep_meta_info"
>keep_meta_info</a></dt>

<dd>
<p>By default, the parsing of input lines is as simple and fast as possible. However, some parsing information - like quotation of the original field - is lost in that process. Set this flag to true to be able to retrieve that information after parsing with the methods <code>meta_info ()</code>, <code>is_quoted ()</code>, and <code>is_binary ()</code> described below. Default is false.</p>

<dt><a name="verbatim"
>verbatim</a></dt>

<dd>
<p>This is a quite controversial attribute to set, but it makes hard things possible.</p>

<p>The basic thought behind this is to tell the parser that the normally special characters newline (NL) and Carriage Return (CR) will not be special when this flag is set, and be dealt with as being ordinary binary characters. This will ease working with data with embedded newlines.</p>

<p>When <code>verbatim</code> is used with <code>getline ()</code>, <code>getline ()</code> auto-chomp&#39;s every line.</p>

<p>Imagine a file format like</p>

<pre class="sh_perl">  M^^Hans^Janssen^Klas 2\n2A^Ja^11-06-2007#\r\n</pre>

<p>where, the line ending is a very specific &#34;#\r\n&#34;, and the sep_char is a ^ (caret). None of the fields is quoted, but embedded binary data is likely to be present. With the specific line ending, that shouldn not be too hard to detect.</p>

<p>By default, Text::CSV&#39; parse function however is instructed to only know about &#34;\n&#34; and &#34;\r&#34; to be legal line endings, and so has to deal with the embedded newline as a real end-of-line, so it can scan the next line if binary is true, and the newline is inside a quoted field. With this attribute however, we can tell parse () to parse the line as if \n is just nothing more than a binary character.</p>

<p>For parse () this means that the parser has no idea about line ending anymore, and getline () chomps line endings on reading.</p>

<dt><a name="auto_diag"
>auto_diag</a></dt>

<dd>
<p>Set to true will cause <code>error_diag ()</code> to be automatically be called in void context upon errors.</p>

<p>If set to a value greater than 1, it will die on errors instead of warn.</p>

<p>To check future plans and a difference in XS version, please see to <a href="/perldoc?Text%3A%3ACSV_XS#auto_diag" class="podlinkpod"
>&#34;auto_diag&#34; in Text::CSV_XS</a>.</p>
</dd>
</dl>

<p>To sum it up,</p>

<pre class="sh_perl"> $csv = Text::CSV-&#62;new ();</pre>

<p>is equivalent to</p>

<pre class="sh_perl"> $csv = Text::CSV-&#62;new ({
     quote_char          =&#62; &#39;&#34;&#39;,
     escape_char         =&#62; &#39;&#34;&#39;,
     sep_char            =&#62; &#39;,&#39;,
     eol                 =&#62; $\,
     always_quote        =&#62; 0,
     quote_space         =&#62; 1,
     quote_null          =&#62; 1,
     binary              =&#62; 0,
     keep_meta_info      =&#62; 0,
     allow_loose_quotes  =&#62; 0,
     allow_loose_escapes =&#62; 0,
     allow_whitespace    =&#62; 0,
     blank_is_undef      =&#62; 0,
     empty_is_undef      =&#62; 0,
     verbatim            =&#62; 0,
     auto_diag           =&#62; 0,
     });</pre>

<p>For all of the above mentioned flags, there is an accessor method available where you can inquire for the current value, or change the value</p>

<pre class="sh_perl"> my $quote = $csv-&#62;quote_char;
 $csv-&#62;binary (1);</pre>

<p>It is unwise to change these settings halfway through writing CSV data to a stream. If however, you want to create a new stream using the available CSV object, there is no harm in changing them.</p>

<p>If the <code>new ()</code> constructor call fails, it returns <code>undef</code>, and makes the fail reason available through the <code>error_diag ()</code> method.</p>

<pre class="sh_perl"> $csv = Text::CSV-&#62;new ({ ecs_char =&#62; 1 }) or
     die &#34;&#34; . Text::CSV-&#62;error_diag ();</pre>

<p><code>error_diag ()</code> will return a string like</p>

<pre class="sh_perl"> &#34;INI - Unknown attribute &#39;ecs_char&#39;&#34;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="print"
>print</a></h2>

<pre class="sh_perl"> $status = $csv-&#62;print ($io, $colref);</pre>

<p>Similar to <code>combine () + string () + print</code>, but more efficient. It expects an array ref as input (not an array!) and the resulting string is not really created (XS version), but immediately written to the <i>$io</i> object, typically an IO handle or any other object that offers a <i>print</i> method. Note, this implies that the following is wrong in perl 5.005_xx and older:</p>

<pre class="sh_perl"> open FILE, &#34;&#62;&#34;, &#34;whatever&#34;;
 $status = $csv-&#62;print (\*FILE, $colref);</pre>

<p>as in perl 5.005 and older, the glob <code>\*FILE</code> is not an object, thus it does not have a print method. The solution is to use an IO::File object or to hide the glob behind an IO::Wrap object. See <a href="/perldoc?IO%3A%3AFile" class="podlinkpod"
>IO::File</a> and <a href="/perldoc?IO%3A%3AWrap" class="podlinkpod"
>IO::Wrap</a> for details.</p>

<p>For performance reasons the print method doesn&#39;t create a result string. (If its backend is PP version, result strings are created internally.) In particular the <i>$csv-&#62;string ()</i>, <i>$csv-&#62;status ()</i>, <i>$csv-</i>fields ()&#62; and <i>$csv-&#62;error_input ()</i> methods are meaningless after executing this method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="combine"
>combine</a></h2>

<pre class="sh_perl"> $status = $csv-&#62;combine (@columns);</pre>

<p>This object function constructs a CSV string from the arguments, returning success or failure. Failure can result from lack of arguments or an argument containing an invalid character. Upon success, <code>string ()</code> can be called to retrieve the resultant CSV string. Upon failure, the value returned by <code>string ()</code> is undefined and <code>error_input ()</code> can be called to retrieve an invalid argument.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="string"
>string</a></h2>

<pre class="sh_perl"> $line = $csv-&#62;string ();</pre>

<p>This object function returns the input to <code>parse ()</code> or the resultant CSV string of <code>combine ()</code>, whichever was called more recently.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getline"
>getline</a></h2>

<pre class="sh_perl"> $colref = $csv-&#62;getline ($io);</pre>

<p>This is the counterpart to print, like parse is the counterpart to combine: It reads a row from the IO object $io using $io-&#62;getline () and parses this row into an array ref. This array ref is returned by the function or undef for failure.</p>

<p>When fields are bound with <code>bind_columns ()</code>, the return value is a reference to an empty list.</p>

<p>The <i>$csv-&#62;string ()</i>, <i>$csv-&#62;fields ()</i> and <i>$csv-&#62;status ()</i> methods are meaningless, again.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getline_all"
>getline_all</a></h2>

<pre class="sh_perl"> $arrayref = $csv-&#62;getline_all ($io);
 $arrayref = $csv-&#62;getline_all ($io, $offset);
 $arrayref = $csv-&#62;getline_all ($io, $offset, $length);</pre>

<p>This will return a reference to a list of <code>getline ($io)</code> results. In this call, <code>keep_meta_info</code> is disabled. If <code>$offset</code> is negative, as with <code>splice ()</code>, only the last <code>abs ($offset)</code> records of <code>$io</code> are taken into consideration.</p>

<p>Given a CSV file with 10 lines:</p>

<pre class="sh_perl"> lines call
 ----- ---------------------------------------------------------
 0..9  $csv-&#62;getline_all ($io)         # all
 0..9  $csv-&#62;getline_all ($io,  0)     # all
 8..9  $csv-&#62;getline_all ($io,  8)     # start at 8
 -     $csv-&#62;getline_all ($io,  0,  0) # start at 0 first 0 rows
 0..4  $csv-&#62;getline_all ($io,  0,  5) # start at 0 first 5 rows
 4..5  $csv-&#62;getline_all ($io,  4,  2) # start at 4 first 2 rows
 8..9  $csv-&#62;getline_all ($io, -2)     # last 2 rows
 6..7  $csv-&#62;getline_all ($io, -4,  2) # first 2 of last  4 rows</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="parse"
>parse</a></h2>

<pre class="sh_perl"> $status = $csv-&#62;parse ($line);</pre>

<p>This object function decomposes a CSV string into fields, returning success or failure. Failure can result from a lack of argument or the given CSV string is improperly formatted. Upon success, <code>fields ()</code> can be called to retrieve the decomposed fields . Upon failure, the value returned by <code>fields ()</code> is undefined and <code>error_input ()</code> can be called to retrieve the invalid argument.</p>

<p>You may use the <i>types ()</i> method for setting column types. See the description below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getline_hr"
>getline_hr</a></h2>

<p>The <code>getline_hr ()</code> and <code>column_names ()</code> methods work together to allow you to have rows returned as hashrefs. You must call <code>column_names ()</code> first to declare your column names.</p>

<pre class="sh_perl"> $csv-&#62;column_names (qw( code name price description ));
 $hr = $csv-&#62;getline_hr ($io);
 print &#34;Price for $hr-&#62;{name} is $hr-&#62;{price} EUR\n&#34;;</pre>

<p><code>getline_hr ()</code> will croak if called before <code>column_names ()</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getline_hr_all"
>getline_hr_all</a></h2>

<pre class="sh_perl"> $arrayref = $csv-&#62;getline_hr_all ($io);
 $arrayref = $csv-&#62;getline_hr_all ($io, $offset);
 $arrayref = $csv-&#62;getline_hr_all ($io, $offset, $length);</pre>

<p>This will return a reference to a list of <code>getline_hr ($io)</code> results. In this call, <code>keep_meta_info</code> is disabled.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="column_names"
>column_names</a></h2>

<p>Set the keys that will be used in the <code>getline_hr ()</code> calls. If no keys (column names) are passed, it&#39;ll return the current setting.</p>

<p><code>column_names ()</code> accepts a list of scalars (the column names) or a single array_ref, so you can pass <code>getline ()</code></p>

<pre class="sh_perl">  $csv-&#62;column_names ($csv-&#62;getline ($io));</pre>

<p><code>column_names ()</code> does <b>no</b> checking on duplicates at all, which might lead to unwanted results. Undefined entries will be replaced with the string <code>&#34;\cAUNDEF\cA&#34;</code>, so</p>

<pre class="sh_perl">  $csv-&#62;column_names (undef, &#34;&#34;, &#34;name&#34;, &#34;name&#34;);
  $hr = $csv-&#62;getline_hr ($io);</pre>

<p>Will set <code>$hr-</code>{&#34;\cAUNDEF\cA&#34;}&#62; to the 1st field, <code>$hr-</code>{&#34;&#34;}&#62; to the 2nd field, and <code>$hr-</code>{name}&#62; to the 4th field, discarding the 3rd field.</p>

<p><code>column_names ()</code> croaks on invalid arguments.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="bind_columns"
>bind_columns</a></h2>

<p>Takes a list of references to scalars to store the fields fetched <code>getline ()</code> in. When you don&#39;t pass enough references to store the fetched fields in, <code>getline ()</code> will fail. If you pass more than there are fields to return, the remaining references are left untouched.</p>

<pre class="sh_perl">  $csv-&#62;bind_columns (\$code, \$name, \$price, \$description);
  while ($csv-&#62;getline ($io)) {
      print &#34;The price of a $name is \x{20ac} $price\n&#34;;
      }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="eof"
>eof</a></h2>

<pre class="sh_perl"> $eof = $csv-&#62;eof ();</pre>

<p>If <code>parse ()</code> or <code>getline ()</code> was used with an IO stream, this method will return true (1) if the last call hit end of file, otherwise it will return false (&#39;&#39;). This is useful to see the difference between a failure and end of file.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="types"
>types</a></h2>

<pre class="sh_perl"> $csv-&#62;types (\@tref);</pre>

<p>This method is used to force that columns are of a given type. For example, if you have an integer column, two double columns and a string column, then you might do a</p>

<pre class="sh_perl"> $csv-&#62;types ([Text::CSV::IV (),
               Text::CSV::NV (),
               Text::CSV::NV (),
               Text::CSV::PV ()]);</pre>

<p>Column types are used only for decoding columns, in other words by the <i>parse ()</i> and <i>getline ()</i> methods.</p>

<p>You can unset column types by doing a</p>

<pre class="sh_perl"> $csv-&#62;types (undef);</pre>

<p>or fetch the current type settings with</p>

<pre class="sh_perl"> $types = $csv-&#62;types ();</pre>

<dl>
<dt><a name="IV"
>IV</a></dt>

<dd>
<p>Set field type to integer.</p>

<dt><a name="NV"
>NV</a></dt>

<dd>
<p>Set field type to numeric/float.</p>

<dt><a name="PV"
>PV</a></dt>

<dd>
<p>Set field type to string.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="fields"
>fields</a></h2>

<pre class="sh_perl"> @columns = $csv-&#62;fields ();</pre>

<p>This object function returns the input to <code>combine ()</code> or the resultant decomposed fields of C successful &#60;parse ()&#62;, whichever was called more recently.</p>

<p>Note that the return value is undefined after using <code>getline ()</code>, which does not fill the data structures returned by <code>parse ()</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="meta_info"
>meta_info</a></h2>

<pre class="sh_perl"> @flags = $csv-&#62;meta_info ();</pre>

<p>This object function returns the flags of the input to <code>combine ()</code> or the flags of the resultant decomposed fields of <code>parse ()</code>, whichever was called more recently.</p>

<p>For each field, a meta_info field will hold flags that tell something about the field returned by the <code>fields ()</code> method or passed to the <code>combine ()</code> method. The flags are bit-wise-or&#39;d like:</p>

<dl>
<dt><a name="0x0001"
>0x0001</a></dt>

<dd>
<p>The field was quoted.</p>

<dt><a name="0x0002"
>0x0002</a></dt>

<dd>
<p>The field was binary.</p>
</dd>
</dl>

<p>See the <code>is_*** ()</code> methods below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_quoted"
>is_quoted</a></h2>

<pre class="sh_perl">  my $quoted = $csv-&#62;is_quoted ($column_idx);</pre>

<p>Where <code>$column_idx</code> is the (zero-based) index of the column in the last result of <code>parse ()</code>.</p>

<p>This returns a true value if the data in the indicated column was enclosed in <code>quote_char</code> quotes. This might be important for data where <code>,20070108,</code> is to be treated as a numeric value, and where <code>,&#34;20070108&#34;,</code> is explicitly marked as character string data.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_binary"
>is_binary</a></h2>

<pre class="sh_perl">  my $binary = $csv-&#62;is_binary ($column_idx);</pre>

<p>Where <code>$column_idx</code> is the (zero-based) index of the column in the last result of <code>parse ()</code>.</p>

<p>This returns a true value if the data in the indicated column contained any byte in the range [\x00-\x08,\x10-\x1F,\x7F-\xFF]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="status"
>status</a></h2>

<pre class="sh_perl"> $status = $csv-&#62;status ();</pre>

<p>This object function returns success (or failure) of <code>combine ()</code> or <code>parse ()</code>, whichever was called more recently.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="error_input"
>error_input</a></h2>

<pre class="sh_perl"> $bad_argument = $csv-&#62;error_input ();</pre>

<p>This object function returns the erroneous argument (if it exists) of <code>combine ()</code> or <code>parse ()</code>, whichever was called more recently.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="error_diag"
>error_diag</a></h2>

<pre class="sh_perl"> Text::CSV-&#62;error_diag ();
 $csv-&#62;error_diag ();
 $error_code   = 0  + $csv-&#62;error_diag ();
 $error_str    = &#34;&#34; . $csv-&#62;error_diag ();
 ($cde, $str, $pos) = $csv-&#62;error_diag ();</pre>

<p>If (and only if) an error occured, this function returns the diagnostics of that error.</p>

<p>If called in void context, it will print the internal error code and the associated error message to STDERR.</p>

<p>If called in list context, it will return the error code and the error message in that order. If the last error was from parsing, the third value returned is the best guess at the location within the line that was being parsed. It&#39;s value is 1-based.</p>

<p>Note: <code>$pos</code> returned by the backend Text::CSV_PP does not show the error point in many cases (see to the below line). It is for conscience&#39;s sake in using Text::CSV_PP.</p>

<p>If called in scalar context, it will return the diagnostics in a single scalar, a-la $!. It will contain the error code in numeric context, and the diagnostics message in string context.</p>

<p>Depending on the used worker module, returned diagnostics is diffferent.</p>

<p>Text::CSV_XS parses csv strings by dividing one character while Text::CSV_PP by using the regular expressions. That difference makes the different cause of the failure.</p>

<p>When called as a class method or a direct function call, the error diag is that of the last <code>new ()</code> call.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="SetDiag"
>SetDiag</a></h2>

<pre class="sh_perl"> $csv-&#62;SetDiag (0);</pre>

<p>Use to reset the diagnostics if you are dealing with errors.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Some_methods_are_Text::CSV_only."
>Some methods are Text::CSV only.</a></h2>

<dl>
<dt><a name="backend"
>backend</a></dt>

<dd>
<p>Returns the backend module name called by Text::CSV. <code>module</code> is an alias.</p>

<dt><a name="is_xs"
>is_xs</a></dt>

<dd>
<p>Returns true value if Text::CSV or the object uses XS module as worker.</p>

<dt><a name="is_pp"
>is_pp</a></dt>

<dd>
<p>Returns true value if Text::CSV or the object uses pure-Perl module as worker.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DIAGNOSTICS"
>DIAGNOSTICS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>If an error occured, $csv-&#62;error_diag () can be used to get more information on the cause of the failure. Note that for speed reasons, the internal value is never cleared on success, so using the value returned by error_diag () in normal cases - when no error occured - may cause unexpected results.</p>

<p>This function changes depending on the used module (XS or PurePerl).</p>

<p>See to <a href="/perldoc?Text%3A%3ACSV_XS#DIAGNOSTICS" class="podlinkpod"
>&#34;DIAGNOSTICS&#34; in Text::CSV_XS</a> and <a href="/~makamaka/Text-CSV-1.21/lib/Text/CSV_PP.pm#DIAGNOSTICS" class="podlinkpod"
>&#34;DIAGNOSTICS&#34; in Text::CSV_PP</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HISTORY_AND_WORKER_MODULES"
>HISTORY AND WORKER MODULES</a></h2>

<p>This module, <a href="/~makamaka/Text-CSV-1.21/lib/Text/CSV.pm" class="podlinkpod"
>Text::CSV</a> was firstly written by Alan Citterman which could deal with <b>only ascii characters</b>. Then, Jochen Wiedmann wrote <a href="/perldoc?Text%3A%3ACSV_XS" class="podlinkpod"
>Text::CSV_XS</a> which has the <b>binary mode</b>. This XS version is maintained by H.Merijn Brand and <a href="/~makamaka/Text-CSV-1.21/lib/Text/CSV_PP.pm" class="podlinkpod"
>Text::CSV_PP</a> written by Makamaka was pure-Perl version of Text::CSV_XS.</p>

<p>Now, Text::CSV was rewritten by Makamaka and become a wrapper to Text::CSV_XS or Text::CSV_PP. Text::CSV_PP will be bundled in this distribution.</p>

<p>When you use Text::CSV, it calls a backend worker module - <a href="/perldoc?Text%3A%3ACSV_XS" class="podlinkpod"
>Text::CSV_XS</a> or <a href="/~makamaka/Text-CSV-1.21/lib/Text/CSV_PP.pm" class="podlinkpod"
>Text::CSV_PP</a>. By default, Text::CSV tries to use Text::CSV_XS which must be complied and installed properly. If this call is fail, Text::CSV uses <a href="/~makamaka/Text-CSV-1.21/lib/Text/CSV_PP.pm" class="podlinkpod"
>Text::CSV_PP</a>.</p>

<p>The required Text::CSV_XS version is <i>0.41</i> in Text::CSV version 1.03.</p>

<p>If you set an enviornment variable <code>PERL_TEXT_CSV</code>, The calling action will be changed.</p>

<dl>
<dt><a name='PERL_TEXT_CSV'></a><a name="PERL_TEXT_CSV_=_0"
>PERL_TEXT_CSV = 0</a></dt>

<dd>
<dt><a name='PERL_TEXT_CSV'></a><a name="PERL_TEXT_CSV_=_&#39;Text::CSV_PP&#39;"
>PERL_TEXT_CSV = &#39;Text::CSV_PP&#39;</a></dt>

<dd>
<p>Always use Text::CSV_PP</p>

<dt><a name='PERL_TEXT_CSV'></a><a name="PERL_TEXT_CSV_=_1"
>PERL_TEXT_CSV = 1</a></dt>

<dd>
<dt><a name='PERL_TEXT_CSV'></a><a name="PERL_TEXT_CSV_=_&#39;Text::CSV_XS,Text::CSV_PP&#39;"
>PERL_TEXT_CSV = &#39;Text::CSV_XS,Text::CSV_PP&#39;</a></dt>

<dd>
<p>(The default) Use compiled Text::CSV_XS if it is properly compiled &#38; installed, otherwise use Text::CSV_PP</p>

<dt><a name='PERL_TEXT_CSV'></a><a name="PERL_TEXT_CSV_=_2"
>PERL_TEXT_CSV = 2</a></dt>

<dd>
<dt><a name='PERL_TEXT_CSV'></a><a name="PERL_TEXT_CSV_=_&#39;Text::CSV_XS&#39;"
>PERL_TEXT_CSV = &#39;Text::CSV_XS&#39;</a></dt>

<dd>
<p>Always use compiled Text::CSV_XS, die if it isn&#39;t properly compiled &#38; installed.</p>
</dd>
</dl>

<p>These ideas come from <a href="/perldoc?DBI%3A%3APurePerl" class="podlinkpod"
>DBI::PurePerl</a> mechanism.</p>

<p>example:</p>

<pre class="sh_perl">  BEGIN { $ENV{PERL_TEXT_CSV} = 0 }
  use Text::CSV; # always uses Text::CSV_PP</pre>

<p>In future, it may be able to specify another module.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TODO"
>TODO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<dl>
<dt><a name='Wrapper'></a><a name="Wrapper_mechanism"
>Wrapper mechanism</a></dt>

<dd>
<p>Currently the wrapper mechanism is to change symbolic table for speed.</p>

<pre class="sh_perl"> for my $method (@PublicMethods) {
     *{&#34;Text::CSV::$method&#34;} = \&#38;{&#34;$class\::$method&#34;};
 }</pre>

<p>But how about it - calling worker module object?</p>

<pre class="sh_perl"> sub parse {
     my $self = shift;
     $self-&#62;{_WORKER_OBJECT}-&#62;parse(@_); # XS or PP CSV object
 }</pre>
</dd>
</dl>

<p>See to <a href="/perldoc?Text%3A%3ACSV_XS#TODO" class="podlinkpod"
>&#34;TODO&#34; in Text::CSV_XS</a> and <a href="/~makamaka/Text-CSV-1.21/lib/Text/CSV_PP.pm#TODO" class="podlinkpod"
>&#34;TODO&#34; in Text::CSV_PP</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><a href="/~makamaka/Text-CSV-1.21/lib/Text/CSV_PP.pm" class="podlinkpod"
>Text::CSV_PP</a>, <a href="/perldoc?Text%3A%3ACSV_XS" class="podlinkpod"
>Text::CSV_XS</a> and <a href="/perldoc?Text%3A%3ACSV%3A%3AEncoded" class="podlinkpod"
>Text::CSV::Encoded</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_and_MAINTAINERS"
>AUTHORS and MAINTAINERS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Alan Citterman <em>&#60;alan[at]mfgrtl.com&#62;</em> wrote the original Perl module. Please don&#39;t send mail concerning Text::CSV to Alan, as he&#39;s not a present maintainer.</p>

<p>Jochen Wiedmann <em>&#60;joe[at]ispsoft.de&#62;</em> rewrote the encoding and decoding in C by implementing a simple finite-state machine and added the variable quote, escape and separator characters, the binary mode and the print and getline methods. See ChangeLog releases 0.10 through 0.23.</p>

<p>H.Merijn Brand <em>&#60;h.m.brand[at]xs4all.nl&#62;</em> cleaned up the code, added the field flags methods, wrote the major part of the test suite, completed the documentation, fixed some RT bugs. See ChangeLog releases 0.25 and on.</p>

<p>Makamaka Hannyaharamitu, &#60;makamaka[at]cpan.org&#62; wrote Text::CSV_PP which is the pure-Perl version of Text::CSV_XS.</p>

<p>New Text::CSV (since 0.99) is maintained by Makamaka.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Text::CSV</p>

<p>Copyright (C) 1997 Alan Citterman. All rights reserved. Copyright (C) 2007-2009 Makamaka Hannyaharamitu.</p>

<p>Text::CSV_PP:</p>

<p>Copyright (C) 2005-2010 Makamaka Hannyaharamitu.</p>

<p>Text:CSV_XS:</p>

<p>Copyright (C) 2007-2010 H.Merijn Brand for PROCURA B.V. Copyright (C) 1998-2001 Jochen Wiedmann. All rights reserved. Portions Copyright (C) 1997 Alan Citterman. All rights reserved.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

</div>
<!-- This should probably be put in the <div class="footer"></div> -->
<script type="text/javascript">
    $(document).ready(function(){
        var startingStyle = $.cookie('css') ? $.cookie('css') : 'http://st.pimg.net/tucs/css/sh_none.min.css';
        $.fn.styleSwitch(startingStyle);
        $("#styleswitch").val(startingStyle);
        sh_highlightDocument();
        $("#styleswitch").bind(($.browser.msie ? "click" : "change"), function() {
            $.fn.styleSwitch($(this).val());
        });
    });
</script>
<div class="styleswitch">
    syntax highlighting:
    <select id="styleswitch">
        <option value="http://st.pimg.net/tucs/css/sh_none.min.css">no syntax highlighting</option>
        <option value="http://st.pimg.net/tucs/css/sh_acid.min.css">acid</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-dark.min.css">berries-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-light.min.css">berries-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_bipolar.min.css">bipolar</option>
        <option value="http://st.pimg.net/tucs/css/sh_blacknblue.min.css">blacknblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_bright.min.css">bright</option>
        <option value="http://st.pimg.net/tucs/css/sh_contrast.min.css">contrast</option>
        <option value="http://st.pimg.net/tucs/css/sh_cpan.min.css">cpan</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkblue.min.css">darkblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkness.min.css">darkness</option>
        <option value="http://st.pimg.net/tucs/css/sh_desert.min.css">desert</option>
        <option value="http://st.pimg.net/tucs/css/sh_dull.min.css">dull</option>
        <option value="http://st.pimg.net/tucs/css/sh_easter.min.css">easter</option>
        <option value="http://st.pimg.net/tucs/css/sh_emacs.min.css">emacs</option>
        <option value="http://st.pimg.net/tucs/css/sh_golden.min.css">golden</option>
        <option value="http://st.pimg.net/tucs/css/sh_greenlcd.min.css">greenlcd</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-anjuta.min.css">ide-anjuta</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-codewarrior.min.css">ide-codewarrior</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-devcpp.min.css">ide-devcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-eclipse.min.css">ide-eclipse</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-kdev.min.css">ide-kdev</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-msvcpp.min.css">ide-msvcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_kwrite.min.css">kwrite</option>
        <option value="http://st.pimg.net/tucs/css/sh_matlab.min.css">matlab</option>
        <option value="http://st.pimg.net/tucs/css/sh_navy.min.css">navy</option>
        <option value="http://st.pimg.net/tucs/css/sh_nedit.min.css">nedit</option>
        <option value="http://st.pimg.net/tucs/css/sh_neon.min.css">neon</option>
        <option value="http://st.pimg.net/tucs/css/sh_night.min.css">night</option>
        <option value="http://st.pimg.net/tucs/css/sh_pablo.min.css">pablo</option>
        <option value="http://st.pimg.net/tucs/css/sh_peachpuff.min.css">peachpuff</option>
        <option value="http://st.pimg.net/tucs/css/sh_print.min.css">print</option>
        <option value="http://st.pimg.net/tucs/css/sh_rand01.min.css">rand01</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-dark.min.css">solarized-dark</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-light.min.css">solarized-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_style.min.css">style</option>
        <option value="http://st.pimg.net/tucs/css/sh_the.min.css">the</option>
        <option value="http://st.pimg.net/tucs/css/sh_typical.min.css">typical</option>
        <option value="http://st.pimg.net/tucs/css/sh_vampire.min.css">vampire</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim-dark.min.css">vim-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim.min.css">vim</option>
        <option value="http://st.pimg.net/tucs/css/sh_whatis.min.css">whatis</option>
        <option value="http://st.pimg.net/tucs/css/sh_whitengrey.min.css">whitengrey</option>
        <option value="http://st.pimg.net/tucs/css/sh_zellner.min.css">zellner</option>
    </select>
</div>



<div class="footer"><div class="cpanstats">78269 Uploads, 24722 Distributions
105999 Modules, 9649 Uploaders
</div>
hosted by <a href="http://www.yellowbot.com">YellowBot</a><br/>
<a href="http://www.yellowbot.com"><img alt="do. tag. write. share." src="http://st.pimg.net/tucs/img/yellowbot_logo.gif"></a>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="http://ipv4.v6test.develooper.com/js/v1/v6test.js"></script>

<script type="text/javascript">
   // v6.target = '';
   if (!v6.target) { v6.only_once = true }
   v6.site = '7A0D89A6-2B82-11DF-B9DA-F61CBD13F020';
   v6.api_server = 'http://ipv4.v6test.develooper.com';
   try {
     v6.test();
   } catch(err) {}
</script>
<script type="text/javascript">
  $(document).ready(function(){
    $("a[href^=http:]").click(function(){
      var href = $(this).attr('href');
      var m = href.match('\/\/([^\/:]+)');
      _gaq.push(['_trackEvent','External',m[1],'Module']);
    });
    $("a[href^=/CPAN/]").click(function(){
      var href = $(this).attr('href');
      _gaq.push(['_trackEvent','Download',href,'Module']);
    });
  });
</script>
<!-- Fri Apr 27 18:13:36 2012 GMT (0.119070053100586) @cpansearch1 -->
 </body>
</html>
