<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <link rel="stylesheet" href="http://st.pimg.net/tucs/style.css" type="text/css" />
<style>
.styleswitch {
  text-align: right;
}
</style>


<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.cookie.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_main.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/sh_perl.min.js"></script>
<script type="text/javascript" src="http://st.pimg.net/tucs/js/jquery.styleswitch.js"></script>

<link rel="stylesheet" href="http://st.pimg.net/tucs/print.css" type="text/css" media="print" />
  <link rel="alternate" type="application/rss+xml" title="RSS 1.0" href="http://search.cpan.org/uploads.rdf" />
  <link rel="search" href="http://st.pimg.net/tucs/opensearch.xml" type="application/opensearchdescription+xml" title="SearchCPAN" />
  <title>HTML::Element - search.cpan.org</title>
 <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3528438-1']);
    _gaq.push(["_setCustomVar",2,"Distribution","HTML-Tree",3]);
    _gaq.push(["_setCustomVar",5,"Release","HTML-Tree-4.2",3]);
    _gaq.push(["_setCustomVar",3,"Module","HTML::Element",3]);
    _gaq.push(["_setCustomVar",1,"Author","JFEARN",3]);
    _gaq.push(['_trackPageview']);
  </script>
 </head>
 <body id="cpansearch">
<center><div class="logo"><a href="/"><img src="http://st.pimg.net/tucs/img/cpan_banner.png" alt="CPAN"></a></div></center>
<div class="menubar">
 <a href="/">Home</a>
&middot; <a href="/author/">Authors</a>
&middot; <a href="/recent">Recent</a>
&middot; <a href="http://log.perl.org/cpansearch/">News</a>
&middot; <a href="/mirror">Mirrors</a>
&middot; <a href="/faq.html">FAQ</a>
&middot; <a href="/feedback">Feedback</a>
</div>
<form method="get" action="/search" name="f" class="searchbox">
<input type="text" name="query" value="" size="35">
<br>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</form>


 <a name="_top"></a>
  <div class=path>
<div id=permalink class="noprint"><a href="/perldoc?HTML::Element">permalink</a></div>
  <a href="/~jfearn/">Jeff Fearn</a> &gt;
  <a href="/~jfearn/HTML-Tree-4.2/">HTML-Tree-4.2</a> &gt;
  HTML::Element
 </div>

<div class="noprint" style="float:right;align:left;width:19ex">
<a href="http://hexten.net/cpan-faces/"><img src="http://www.gravatar.com/avatar/aa628f71c8b783d6c4c732f4037cfd44?r=g&s=80&d=http%3A%2F%2Fst.pimg.net%2Ftucs%2Fimg%2Fwho.png" width=80 height=80 
style="float:right"
/></a>
<br style="clear:both"/>
<p style="text-align:right">Download:<br/> <a href="/CPAN/authors/id/J/JF/JFEARN/HTML-Tree-4.2.tar.gz">HTML-Tree-4.2.tar.gz</a></p>
<p style="text-align:right"><a href="http://deps.cpantesters.org/?module=HTML%3A%3AElement;perl=latest">Dependencies</a></p>
<p style="text-align:right"><a href="http://www.annocpan.org/~JFEARN/HTML-Tree-4.2/lib/HTML/Element.pm">Annotate this POD
(1)
</a></p>
<div class=box style='width:150px; float: right'>
<h1 class=t5>Related Modules</h1>
<div style="margin:2px">
<a href="/perldoc?HTML%3A%3AParser">HTML::Parser</a><br>
<a href="/perldoc?HTML%3A%3ATokeParser">HTML::TokeParser</a><br>
<a href="/perldoc?HTML%3A%3AMason">HTML::Mason</a><br>
<a href="/perldoc?Date%3A%3ACalc">Date::Calc</a><br>
<a href="/perldoc?Data%3A%3ADumper">Data::Dumper</a><br>
<a href="/perldoc?HTML%3A%3ATemplate">HTML::Template</a><br>
<a href="/perldoc?XML%3A%3ATwig">XML::Twig</a><br>
<a href="/perldoc?LWP%3A%3ASimple">LWP::Simple</a><br>
<a href="/perldoc?Params%3A%3AValidate">Params::Validate</a><br>
<a href="/perldoc?HTML%3A%3ATable">HTML::Table</a><br>
<small>
<a href="http://perlmonks.org/?node=cpan+module+search&pivot=1&module=HTML%3A%3AElement">more...</a><br>
By <a href="http://perlmonks.org/">perlmonks.org</a></small>
</div>
</div>

<div style="float:right">
<div class=box style='width:150px'>
<h1 class=t5>CPAN RT</h1>
<div style="margin:2px">
<table style="margin-left:auto;margin-right:auto">
<tr><td>New&nbsp;</td><td style="text-align:right"> 8</td></tr>
<tr><td>Open&nbsp;</td><td style="text-align:right"> 14</td></tr>
</table>
<a href="https://rt.cpan.org/Public/Dist/Display.html?Name=HTML-Tree">View/Report Bugs</a><br/>
</div>
</div>

</div>
</div>
  Module Version:  4.2 &nbsp;
<span class="noprint">
  <a href="/src/JFEARN/HTML-Tree-4.2/lib/HTML/Element.pm">Source</a> &nbsp;
</span>
<a name="___top"></a>
<div class=pod>
<div class=toc>
<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#HOW_WE_REPRESENT_TREES'>HOW WE REPRESENT TREES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Version'>Version</a>
    <li class='indexItem indexItem2'><a href='#ABORT_OK_PRUNE_PRUNE_SOFTLY_PRUNE_UP'>ABORT OK PRUNE PRUNE_SOFTLY PRUNE_UP</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#BASIC_METHODS'>BASIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#$h_=_HTML::Element-&#62;new(&#39;tag&#39;,_&#39;attrname&#39;_=&#62;_&#39;value&#39;,_..._)'>$h = HTML::Element-&#62;new(&#39;tag&#39;, &#39;attrname&#39; =&#62; &#39;value&#39;, ... )</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;attr(&#39;attr&#39;)_or_$h-&#62;attr(&#39;attr&#39;,_&#39;value&#39;)'>$h-&#62;attr(&#39;attr&#39;) or $h-&#62;attr(&#39;attr&#39;, &#39;value&#39;)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;tag()_or_$h-&#62;tag(&#39;tagname&#39;)'>$h-&#62;tag() or $h-&#62;tag(&#39;tagname&#39;)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;parent()_or_$h-&#62;parent($new_parent)'>$h-&#62;parent() or $h-&#62;parent($new_parent)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;content_list()'>$h-&#62;content_list()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;content()'>$h-&#62;content()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;content_array_ref()'>$h-&#62;content_array_ref()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;content_refs_list'>$h-&#62;content_refs_list</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;implicit()_or_$h-&#62;implicit($bool)'>$h-&#62;implicit() or $h-&#62;implicit($bool)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;pos()_or_$h-&#62;pos($element)'>$h-&#62;pos() or $h-&#62;pos($element)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;all_attr()'>$h-&#62;all_attr()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;all_attr_names()'>$h-&#62;all_attr_names()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;all_external_attr()'>$h-&#62;all_external_attr()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;all_external_attr_names()'>$h-&#62;all_external_attr_names()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;id()_or_$h-&#62;id($string)'>$h-&#62;id() or $h-&#62;id($string)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;idf()_or_$h-&#62;idf($string)'>$h-&#62;idf() or $h-&#62;idf($string)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#STRUCTURE-MODIFYING_METHODS'>STRUCTURE-MODIFYING METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#$h-&#62;push_content($element_or_text,_...)'>$h-&#62;push_content($element_or_text, ...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;unshift_content($element_or_text,_...)'>$h-&#62;unshift_content($element_or_text, ...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;splice_content($offset,_$length,_$element_or_text,_...)'>$h-&#62;splice_content($offset, $length, $element_or_text, ...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;detach()'>$h-&#62;detach()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;detach_content()'>$h-&#62;detach_content()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;replace_with(_$element_or_text,_..._)'>$h-&#62;replace_with( $element_or_text, ... )</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;preinsert($element_or_text...)'>$h-&#62;preinsert($element_or_text...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;postinsert($element_or_text...)'>$h-&#62;postinsert($element_or_text...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;replace_with_content()'>$h-&#62;replace_with_content()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;delete_content()'>$h-&#62;delete_content()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;delete()_destroy_destroy_content'>$h-&#62;delete() destroy destroy_content</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;clone()'>$h-&#62;clone()</a>
    <li class='indexItem indexItem2'><a href='#HTML::Element-&#62;clone_list(...nodes...)'>HTML::Element-&#62;clone_list(...nodes...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;normalize_content'>$h-&#62;normalize_content</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;delete_ignorable_whitespace()'>$h-&#62;delete_ignorable_whitespace()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;insert_element($element,_$implicit)'>$h-&#62;insert_element($element, $implicit)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DUMPING_METHODS'>DUMPING METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#$h-&#62;dump()'>$h-&#62;dump()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;dump(*FH)_;_#_or_*FH{IO}_or_$fh_obj'>$h-&#62;dump(*FH) ; # or *FH{IO} or $fh_obj</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;as_HTML()_or_$h-&#62;as_HTML($entities)'>$h-&#62;as_HTML() or $h-&#62;as_HTML($entities)</a>
    <li class='indexItem indexItem2'><a href='#or_$h-&#62;as_HTML($entities,_$indent_char)'>or $h-&#62;as_HTML($entities, $indent_char)</a>
    <li class='indexItem indexItem2'><a href='#or_$h-&#62;as_HTML($entities,_$indent_char,_\%optional_end_tags)'>or $h-&#62;as_HTML($entities, $indent_char, \%optional_end_tags)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;as_text()'>$h-&#62;as_text()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;as_text(skip_dels_=&#62;_1,_extra_chars_=&#62;_&#39;\xA0&#39;)'>$h-&#62;as_text(skip_dels =&#62; 1, extra_chars =&#62; &#39;\xA0&#39;)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;as_trimmed_text(...)_as_text_trimmed'>$h-&#62;as_trimmed_text(...) as_text_trimmed</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;as_XML()'>$h-&#62;as_XML()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;as_Lisp_form()'>$h-&#62;as_Lisp_form()</a>
    <li class='indexItem indexItem2'><a href='#format'>format</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;starttag()_or_$h-&#62;starttag($entities)'>$h-&#62;starttag() or $h-&#62;starttag($entities)</a>
    <li class='indexItem indexItem2'><a href='#starttag_XML'>starttag_XML</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;endtag()_||_endtag_XML'>$h-&#62;endtag() || endtag_XML</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SECONDARY_STRUCTURAL_METHODS'>SECONDARY STRUCTURAL METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#$h-&#62;is_inside(&#39;tag&#39;,_...)_or_$h-&#62;is_inside($element,_...)'>$h-&#62;is_inside(&#39;tag&#39;, ...) or $h-&#62;is_inside($element, ...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;is_empty()'>$h-&#62;is_empty()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;pindex()'>$h-&#62;pindex()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;left()'>$h-&#62;left()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;right()'>$h-&#62;right()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;address()'>$h-&#62;address()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;address($address)'>$h-&#62;address($address)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;depth()'>$h-&#62;depth()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;root()'>$h-&#62;root()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;lineage()'>$h-&#62;lineage()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;lineage_tag_names()'>$h-&#62;lineage_tag_names()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;descendants()'>$h-&#62;descendants()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;descendents()'>$h-&#62;descendents()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;find_by_tag_name(&#39;tag&#39;,_...)'>$h-&#62;find_by_tag_name(&#39;tag&#39;, ...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;find(&#39;tag&#39;,_...)'>$h-&#62;find(&#39;tag&#39;, ...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;find_by_attribute(&#39;attribute&#39;,_&#39;value&#39;)'>$h-&#62;find_by_attribute(&#39;attribute&#39;, &#39;value&#39;)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;look_down(_...criteria..._)'>$h-&#62;look_down( ...criteria... )</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;look_up(_...criteria..._)'>$h-&#62;look_up( ...criteria... )</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;traverse(...options...)'>$h-&#62;traverse(...options...)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;attr_get_i(&#39;attribute&#39;)'>$h-&#62;attr_get_i(&#39;attribute&#39;)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;attr_get_i(&#39;a1&#39;,_&#39;a2&#39;,_&#39;a3&#39;)'>$h-&#62;attr_get_i(&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;tagname_map()'>$h-&#62;tagname_map()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;extract_links()_or_$h-&#62;extract_links(@wantedTypes)'>$h-&#62;extract_links() or $h-&#62;extract_links(@wantedTypes)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;simplify_pres'>$h-&#62;simplify_pres</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;same_as($i)'>$h-&#62;same_as($i)</a>
    <li class='indexItem indexItem2'><a href='#$h_=_HTML::Element-&#62;new_from_lol(ARRAYREF)'>$h = HTML::Element-&#62;new_from_lol(ARRAYREF)</a>
    <li class='indexItem indexItem2'><a href='#@elements_=_HTML::Element-&#62;new_from_lol(ARRAYREFS)'>@elements = HTML::Element-&#62;new_from_lol(ARRAYREFS)</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;objectify_text()'>$h-&#62;objectify_text()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;deobjectify_text()'>$h-&#62;deobjectify_text()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;number_lists()'>$h-&#62;number_lists()</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;has_insane_linkage'>$h-&#62;has_insane_linkage</a>
    <li class='indexItem indexItem2'><a href='#$h-&#62;element_class'>$h-&#62;element_class</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#NOTES_ON_SUBCLASSING'>NOTES ON SUBCLASSING</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>HTML::Element - Class for objects that represent HTML elements</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Version 4.2</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl">    use HTML::Element;
    $a = HTML::Element-&#62;new(&#39;a&#39;, href =&#62; &#39;<a href="http://www.perl.com/" class="podlinkurl"
>http://www.perl.com/</a>&#39;);
    $a-&#62;push_content(&#34;The Perl Homepage&#34;);

    $tag = $a-&#62;tag;
    print &#34;$tag starts out as:&#34;,  $a-&#62;starttag, &#34;\n&#34;;
    print &#34;$tag ends as:&#34;,  $a-&#62;endtag, &#34;\n&#34;;
    print &#34;$tag\&#39;s href attribute is: &#34;, $a-&#62;attr(&#39;href&#39;), &#34;\n&#34;;

    $links_r = $a-&#62;extract_links();
    print &#34;Hey, I found &#34;, scalar(@$links_r), &#34; links.\n&#34;;

    print &#34;And that, as HTML, is: &#34;, $a-&#62;as_HTML, &#34;\n&#34;;
    $a = $a-&#62;delete;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>(This class is part of the <a href="/~jfearn/HTML-Tree-4.2/lib/HTML/Tree.pm" class="podlinkpod"
>HTML::Tree</a> dist.)</p>

<p>Objects of the HTML::Element class can be used to represent elements of HTML document trees. These objects have attributes, notably attributes that designates each element&#39;s parent and content. The content is an array of text segments and other HTML::Element objects. A tree with HTML::Element objects as nodes can represent the syntax tree for a HTML document.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOW_WE_REPRESENT_TREES"
>HOW WE REPRESENT TREES <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Consider this HTML document:</p>

<pre class="sh_perl">  &#60;html lang=&#39;en-US&#39;&#62;
    &#60;head&#62;
      &#60;title&#62;Stuff&#60;/title&#62;
      &#60;meta name=&#39;author&#39; content=&#39;Jojo&#39;&#62;
    &#60;/head&#62;
    &#60;body&#62;
     &#60;h1&#62;I like potatoes!&#60;/h1&#62;
    &#60;/body&#62;
  &#60;/html&#62;</pre>

<p>Building a syntax tree out of it makes a tree-structure in memory that could be diagrammed as:</p>

<pre class="sh_perl">                     html (lang=&#39;en-US&#39;)
                      / \
                    /     \
                  /         \
                head        body
               /\               \
             /    \               \
           /        \               \
         title     meta              h1
          |       (name=&#39;author&#39;,     |
       &#34;Stuff&#34;    content=&#39;Jojo&#39;)    &#34;I like potatoes&#34;</pre>

<p>This is the traditional way to diagram a tree, with the &#34;root&#34; at the top, and it&#39;s this kind of diagram that people have in mind when they say, for example, that &#34;the meta element is under the head element instead of under the body element&#34;. (The same is also said with &#34;inside&#34; instead of &#34;under&#34; -- the use of &#34;inside&#34; makes more sense when you&#39;re looking at the HTML source.)</p>

<p>Another way to represent the above tree is with indenting:</p>

<pre class="sh_perl">  html (attributes: lang=&#39;en-US&#39;)
    head
      title
        &#34;Stuff&#34;
      meta (attributes: name=&#39;author&#39; content=&#39;Jojo&#39;)
    body
      h1
        &#34;I like potatoes&#34;</pre>

<p>Incidentally, diagramming with indenting works much better for very large trees, and is easier for a program to generate. The <code>$tree-&#62;dump</code> method uses indentation just that way.</p>

<p>However you diagram the tree, it&#39;s stored the same in memory -- it&#39;s a network of objects, each of which has attributes like so:</p>

<pre class="sh_perl">  element #1:  _tag: &#39;html&#39;
               _parent: none
               _content: [element #2, element #5]
               lang: &#39;en-US&#39;

  element #2:  _tag: &#39;head&#39;
               _parent: element #1
               _content: [element #3, element #4]

  element #3:  _tag: &#39;title&#39;
               _parent: element #2
               _content: [text segment &#34;Stuff&#34;]

  element #4   _tag: &#39;meta&#39;
               _parent: element #2
               _content: none
               name: author
               content: Jojo

  element #5   _tag: &#39;body&#39;
               _parent: element #1
               _content: [element #6]

  element #6   _tag: &#39;h1&#39;
               _parent: element #5
               _content: [text segment &#34;I like potatoes&#34;]</pre>

<p>The &#34;treeness&#34; of the tree-structure that these elements comprise is not an aspect of any particular object, but is emergent from the relatedness attributes (_parent and _content) of these element-objects and from how you use them to get from element to element.</p>

<p>While you could access the content of a tree by writing code that says &#34;access the &#39;src&#39; attribute of the root&#39;s <i>first</i> child&#39;s <i>seventh</i> child&#39;s <i>third</i> child&#34;, you&#39;re more likely to have to scan the contents of a tree, looking for whatever nodes, or kinds of nodes, you want to do something with. The most straightforward way to look over a tree is to &#34;traverse&#34; it; an HTML::Element method (<code>$h-&#62;traverse</code>) is provided for this purpose; and several other HTML::Element methods are based on it.</p>

<p>(For everything you ever wanted to know about trees, and then some, see Niklaus Wirth&#39;s <i>Algorithms + Data Structures = Programs</i> or Donald Knuth&#39;s <i>The Art of Computer Programming, Volume 1</i>.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Version"
>Version</a></h2>

<p>Why is this a sub?</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ABORT_OK_PRUNE_PRUNE_SOFTLY_PRUNE_UP"
>ABORT OK PRUNE PRUNE_SOFTLY PRUNE_UP</a></h2>

<p>Constants for signalling back to the traverser</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BASIC_METHODS"
>BASIC METHODS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h_=_HTML::Element-&#62;new(&#39;tag&#39;,_&#39;attrname&#39;_=&#62;_&#39;value&#39;,_..._)"
>$h = HTML::Element-&#62;new(&#39;tag&#39;, &#39;attrname&#39; =&#62; &#39;value&#39;, ... )</a></h2>

<p>This constructor method returns a new HTML::Element object. The tag name is a required argument; it will be forced to lowercase. Optionally, you can specify other initial attributes at object creation time.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;attr(&#39;attr&#39;)_or_$h-&#62;attr(&#39;attr&#39;,_&#39;value&#39;)"
>$h-&#62;attr(&#39;attr&#39;) or $h-&#62;attr(&#39;attr&#39;, &#39;value&#39;)</a></h2>

<p>Returns (optionally sets) the value of the given attribute of $h. The attribute name (but not the value, if provided) is forced to lowercase. If trying to read the value of an attribute not present for this element, the return value is undef. If setting a new value, the old value of that attribute is returned.</p>

<p>If methods are provided for accessing an attribute (like <code>$h-&#62;tag</code> for &#34;_tag&#34;, <code>$h-&#62;content_list</code>, etc. below), use those instead of calling attr <code>$h-&#62;attr</code>, whether for reading or setting.</p>

<p>Note that setting an attribute to <code>undef</code> (as opposed to &#34;&#34;, the empty string) actually deletes the attribute.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;tag()_or_$h-&#62;tag(&#39;tagname&#39;)"
>$h-&#62;tag() or $h-&#62;tag(&#39;tagname&#39;)</a></h2>

<p>Returns (optionally sets) the tag name (also known as the generic identifier) for the element $h. In setting, the tag name is always converted to lower case.</p>

<p>There are four kinds of &#34;pseudo-elements&#34; that show up as HTML::Element objects:</p>

<dl>
<dt><a name='Comment'></a><a name="Comment_pseudo-elements"
>Comment pseudo-elements</a></dt>

<dd>
<p>These are element objects with a <code>$h-&#62;tag</code> value of &#34;~comment&#34;, and the content of the comment is stored in the &#34;text&#34; attribute (<code>$h-&#62;attr(&#34;text&#34;)</code>). For example, parsing this code with HTML::TreeBuilder...</p>

<pre class="sh_perl">  &#60;!-- I like Pie.
     Pie is good
  --&#62;</pre>

<p>produces an HTML::Element object with these attributes:</p>

<pre class="sh_perl">  &#34;_tag&#34;,
  &#34;~comment&#34;,
  &#34;text&#34;,
  &#34; I like Pie.\n     Pie is good\n  &#34;</pre>

<dt><a name='Declaration'></a><a name="Declaration_pseudo-elements"
>Declaration pseudo-elements</a></dt>

<dd>
<p>Declarations (rarely encountered) are represented as HTML::Element objects with a tag name of &#34;~declaration&#34;, and content in the &#34;text&#34; attribute. For example, this:</p>

<pre class="sh_perl">  &#60;!DOCTYPE foo&#62;</pre>

<p>produces an element whose attributes include:</p>

<pre class="sh_perl">  &#34;_tag&#34;, &#34;~declaration&#34;, &#34;text&#34;, &#34;DOCTYPE foo&#34;</pre>

<dt><a name='Processing'></a><a name="Processing_instruction_pseudo-elements"
>Processing instruction pseudo-elements</a></dt>

<dd>
<p>PIs (rarely encountered) are represented as HTML::Element objects with a tag name of &#34;~pi&#34;, and content in the &#34;text&#34; attribute. For example, this:</p>

<pre class="sh_perl">  &#60;?stuff foo?&#62;</pre>

<p>produces an element whose attributes include:</p>

<pre class="sh_perl">  &#34;_tag&#34;, &#34;~pi&#34;, &#34;text&#34;, &#34;stuff foo?&#34;</pre>

<p>(assuming a recent version of HTML::Parser)</p>

<dt><a name='literal'></a><a name="~literal_pseudo-elements"
>~literal pseudo-elements</a></dt>

<dd>
<p>These objects are not currently produced by HTML::TreeBuilder, but can be used to represent a &#34;super-literal&#34; -- i.e., a literal you want to be immune from escaping. (Yes, I just made that term up.)</p>

<p>That is, this is useful if you want to insert code into a tree that you plan to dump out with <code>as_HTML</code>, where you want, for some reason, to suppress <code>as_HTML</code>&#39;s normal behavior of amp-quoting text segments.</p>

<p>For example, this:</p>

<pre class="sh_perl">  my $literal = HTML::Element-&#62;new(&#39;~literal&#39;,
    &#39;text&#39; =&#62; &#39;x &#60; 4 &#38; y &#62; 7&#39;
  );
  my $span = HTML::Element-&#62;new(&#39;span&#39;);
  $span-&#62;push_content($literal);
  print $span-&#62;as_HTML;</pre>

<p>prints this:</p>

<pre class="sh_perl">  &#60;span&#62;x &#60; 4 &#38; y &#62; 7&#60;/span&#62;</pre>

<p>Whereas this:</p>

<pre class="sh_perl">  my $span = HTML::Element-&#62;new(&#39;span&#39;);
  $span-&#62;push_content(&#39;x &#60; 4 &#38; y &#62; 7&#39;);
    # normal text segment
  print $span-&#62;as_HTML;</pre>

<p>prints this:</p>

<pre class="sh_perl">  &#60;span&#62;x &#38;lt; 4 &#38;amp; y &#38;gt; 7&#60;/span&#62;</pre>

<p>Unless you&#39;re inserting lots of pre-cooked code into existing trees, and dumping them out again, it&#39;s not likely that you&#39;ll find <code>~literal</code> pseudo-elements useful.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;parent()_or_$h-&#62;parent($new_parent)"
>$h-&#62;parent() or $h-&#62;parent($new_parent)</a></h2>

<p>Returns (optionally sets) the parent (aka &#34;container&#34;) for this element. The parent should either be undef, or should be another element.</p>

<p>You <b>should not</b> use this to directly set the parent of an element. Instead use any of the other methods under &#34;Structure-Modifying Methods&#34;, below.</p>

<p>Note that not($h-&#62;parent) is a simple test for whether $h is the root of its subtree.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;content_list()"
>$h-&#62;content_list()</a></h2>

<p>Returns a list of the child nodes of this element -- i.e., what nodes (elements or text segments) are inside/under this element. (Note that this may be an empty list.)</p>

<p>In a scalar context, this returns the count of the items, as you may expect.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;content()"
>$h-&#62;content()</a></h2>

<p>This somewhat deprecated method returns the content of this element; but unlike content_list, this returns either undef (which you should understand to mean no content), or a <i>reference to the array</i> of content items, each of which is either a text segment (a string, i.e., a defined non-reference scalar value), or an HTML::Element object. Note that even if an arrayref is returned, it may be a reference to an empty array.</p>

<p>While older code should feel free to continue to use <code>$h-&#62;content</code>, new code should use <code>$h-&#62;content_list</code> in almost all conceivable cases. It is my experience that in most cases this leads to simpler code anyway, since it means one can say:</p>

<pre class="sh_perl">    @children = $h-&#62;content_list;</pre>

<p>instead of the inelegant:</p>

<pre class="sh_perl">    @children = @{$h-&#62;content || []};</pre>

<p>If you do use <code>$h-&#62;content</code> (or <code>$h-&#62;content_array_ref</code>), you should not use the reference returned by it (assuming it returned a reference, and not undef) to directly set or change the content of an element or text segment! Instead use <a href="/perldoc?content_refs_list" class="podlinkpod"
>content_refs_list</a> or any of the other methods under &#34;Structure-Modifying Methods&#34;, below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;content_array_ref()"
>$h-&#62;content_array_ref()</a></h2>

<p>This is like <code>content</code> (with all its caveats and deprecations) except that it is guaranteed to return an array reference. That is, if the given node has no <code>_content</code> attribute, the <code>content</code> method would return that undef, but <code>content_array_ref</code> would set the given node&#39;s <code>_content</code> value to <code>[]</code> (a reference to a new, empty array), and return that.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;content_refs_list"
>$h-&#62;content_refs_list</a></h2>

<p>This returns a list of scalar references to each element of <code>$h</code>&#39;s content list. This is useful in case you want to in-place edit any large text segments without having to get a copy of the current value of that segment value, modify that copy, then use the <code>splice_content</code> to replace the old with the new. Instead, here you can in-place edit:</p>

<pre class="sh_perl">    foreach my $item_r ($h-&#62;content_refs_list) {
        next if ref $$item_r;
        $$item_r =~ s/honour/honor/g;
    }</pre>

<p>You <i>could</i> currently achieve the same affect with:</p>

<pre class="sh_perl">    foreach my $item (@{ $h-&#62;content_array_ref }) {
        # deprecated!
        next if ref $item;
        $item =~ s/honour/honor/g;
    }</pre>

<p>...except that using the return value of <code>$h-&#62;content</code> or <code>$h-&#62;content_array_ref</code> to do that is deprecated, and just might stop working in the future.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;implicit()_or_$h-&#62;implicit($bool)"
>$h-&#62;implicit() or $h-&#62;implicit($bool)</a></h2>

<p>Returns (optionally sets) the &#34;_implicit&#34; attribute. This attribute is a flag that&#39;s used for indicating that the element was not originally present in the source, but was added to the parse tree (by HTML::TreeBuilder, for example) in order to conform to the rules of HTML structure.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;pos()_or_$h-&#62;pos($element)"
>$h-&#62;pos() or $h-&#62;pos($element)</a></h2>

<p>Returns (and optionally sets) the &#34;_pos&#34; (for &#34;current <i>pos</i>ition&#34;) pointer of <code>$h</code>. This attribute is a pointer used during some parsing operations, whose value is whatever HTML::Element element at or under <code>$h</code> is currently &#34;open&#34;, where <code>$h-&#62;insert_element(NEW)</code> will actually insert a new element.</p>

<p>(This has nothing to do with the Perl function called &#34;pos&#34;, for controlling where regular expression matching starts.)</p>

<p>If you set <code>$h-&#62;pos($element)</code>, be sure that <code>$element</code> is either <code>$h</code>, or an element under <code>$h</code>.</p>

<p>If you&#39;ve been modifying the tree under <code>$h</code> and are no longer sure <code>$h-&#62;pos</code> is valid, you can enforce validity with:</p>

<pre class="sh_perl">    $h-&#62;pos(undef) unless $h-&#62;pos-&#62;is_inside($h);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;all_attr()"
>$h-&#62;all_attr()</a></h2>

<p>Returns all this element&#39;s attributes and values, as key-value pairs. This will include any &#34;internal&#34; attributes (i.e., ones not present in the original element, and which will not be represented if/when you call <code>$h-&#62;as_HTML</code>). Internal attributes are distinguished by the fact that the first character of their key (not value! key!) is an underscore (&#34;_&#34;).</p>

<p>Example output of <code>$h-&#62;all_attr()</code> : <code>&#39;_parent&#39;, </code><i>[object_value]</i><code> , &#39;_tag&#39;, &#39;em&#39;, &#39;lang&#39;, &#39;en-US&#39;, &#39;_content&#39;, </code><i>[array-ref value]</i>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;all_attr_names()"
>$h-&#62;all_attr_names()</a></h2>

<p>Like all_attr, but only returns the names of the attributes.</p>

<p>Example output of <code>$h-&#62;all_attr_names()</code> : <code>&#39;_parent&#39;, &#39;_tag&#39;, &#39;lang&#39;, &#39;_content&#39;, </code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;all_external_attr()"
>$h-&#62;all_external_attr()</a></h2>

<p>Like <code>all_attr</code>, except that internal attributes are not present.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;all_external_attr_names()"
>$h-&#62;all_external_attr_names()</a></h2>

<p>Like <code>all_external_attr_names</code>, except that internal attributes&#39; names are not present.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;id()_or_$h-&#62;id($string)"
>$h-&#62;id() or $h-&#62;id($string)</a></h2>

<p>Returns (optionally sets to <code>$string</code>) the &#34;id&#34; attribute. <code>$h-&#62;id(undef)</code> deletes the &#34;id&#34; attribute.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;idf()_or_$h-&#62;idf($string)"
>$h-&#62;idf() or $h-&#62;idf($string)</a></h2>

<p>Just like the <code>id</code> method, except that if you call <code>$h-&#62;idf()</code> and no &#34;id&#34; attribute is defined for this element, then it&#39;s set to a likely-to-be-unique value, and returned. (The &#34;f&#34; is for &#34;force&#34;.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="STRUCTURE-MODIFYING_METHODS"
>STRUCTURE-MODIFYING METHODS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>These methods are provided for modifying the content of trees by adding or changing nodes as parents or children of other nodes.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;push_content($element_or_text,_...)"
>$h-&#62;push_content($element_or_text, ...)</a></h2>

<p>Adds the specified items to the <i>end</i> of the content list of the element <code>$h</code>. The items of content to be added should each be either a text segment (a string), an HTML::Element object, or an arrayref. Arrayrefs are fed thru <code>$h-&#62;new_from_lol(that_arrayref)</code> to convert them into elements, before being added to the content list of <code>$h</code>. This means you can say things concise things like:</p>

<pre class="sh_perl">  $body-&#62;push_content(
    [&#39;br&#39;],
    [&#39;ul&#39;,
      map [&#39;li&#39;, $_], qw(Peaches Apples Pears Mangos)
    ]
  );</pre>

<p>See <code>new_from_lol</code> method&#39;s documentation, far below, for more explanation.</p>

<p>The push_content method will try to consolidate adjacent text segments while adding to the content list. That&#39;s to say, if $h&#39;s content_list is</p>

<pre class="sh_perl">  (&#39;foo bar &#39;, $some_node, &#39;baz!&#39;)</pre>

<p>and you call</p>

<pre class="sh_perl">   $h-&#62;push_content(&#39;quack?&#39;);</pre>

<p>then the resulting content list will be this:</p>

<pre class="sh_perl">  (&#39;foo bar &#39;, $some_node, &#39;baz!quack?&#39;)</pre>

<p>and not this:</p>

<pre class="sh_perl">  (&#39;foo bar &#39;, $some_node, &#39;baz!&#39;, &#39;quack?&#39;)</pre>

<p>If that latter is what you want, you&#39;ll have to override the feature of consolidating text by using splice_content, as in:</p>

<pre class="sh_perl">  $h-&#62;splice_content(scalar($h-&#62;content_list),0,&#39;quack?&#39;);</pre>

<p>Similarly, if you wanted to add &#39;Skronk&#39; to the beginning of the content list, calling this:</p>

<pre class="sh_perl">   $h-&#62;unshift_content(&#39;Skronk&#39;);</pre>

<p>then the resulting content list will be this:</p>

<pre class="sh_perl">  (&#39;Skronkfoo bar &#39;, $some_node, &#39;baz!&#39;)</pre>

<p>and not this:</p>

<pre class="sh_perl">  (&#39;Skronk&#39;, &#39;foo bar &#39;, $some_node, &#39;baz!&#39;)</pre>

<p>What you&#39;d to do get the latter is:</p>

<pre class="sh_perl">  $h-&#62;splice_content(0,0,&#39;Skronk&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;unshift_content($element_or_text,_...)"
>$h-&#62;unshift_content($element_or_text, ...)</a></h2>

<p>Just like <code>push_content</code>, but adds to the <i>beginning</i> of the $h element&#39;s content list.</p>

<p>The items of content to be added should each be either a text segment (a string), an HTML::Element object, or an arrayref (which is fed thru <code>new_from_lol</code>).</p>

<p>The unshift_content method will try to consolidate adjacent text segments while adding to the content list. See above for a discussion of this.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;splice_content($offset,_$length,_$element_or_text,_...)"
>$h-&#62;splice_content($offset, $length, $element_or_text, ...)</a></h2>

<p>Detaches the elements from $h&#39;s list of content-nodes, starting at $offset and continuing for $length items, replacing them with the elements of the following list, if any. Returns the elements (if any) removed from the content-list. If $offset is negative, then it starts that far from the end of the array, just like Perl&#39;s normal <code>splice</code> function. If $length and the following list is omitted, removes everything from $offset onward.</p>

<p>The items of content to be added (if any) should each be either a text segment (a string), an arrayref (which is fed thru <code>new_from_lol</code>), or an HTML::Element object that&#39;s not already a child of $h.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;detach()"
>$h-&#62;detach()</a></h2>

<p>This unlinks $h from its parent, by setting its &#39;parent&#39; attribute to undef, and by removing it from the content list of its parent (if it had one). The return value is the parent that was detached from (or undef, if $h had no parent to start with). Note that neither $h nor its parent are explicitly destroyed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;detach_content()"
>$h-&#62;detach_content()</a></h2>

<p>This unlinks all of $h&#39;s children from $h, and returns them. Note that these are not explicitly destroyed; for that, you can just use $h-&#62;delete_content.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;replace_with(_$element_or_text,_..._)"
>$h-&#62;replace_with( $element_or_text, ... )</a></h2>

<p>This replaces <code>$h</code> in its parent&#39;s content list with the nodes specified. The element <code>$h</code> (which by then may have no parent) is returned. This causes a fatal error if <code>$h</code> has no parent. The list of nodes to insert may contain <code>$h</code>, but at most once. Aside from that possible exception, the nodes to insert should not already be children of <code>$h</code>&#39;s parent.</p>

<p>Also, note that this method does not destroy <code>$h</code> -- use <code>$h-&#62;replace_with(...)-&#62;delete</code> if you need that.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;preinsert($element_or_text...)"
>$h-&#62;preinsert($element_or_text...)</a></h2>

<p>Inserts the given nodes right BEFORE <code>$h</code> in <code>$h</code>&#39;s parent&#39;s content list. This causes a fatal error if <code>$h</code> has no parent. None of the given nodes should be <code>$h</code> or other children of <code>$h</code>. Returns <code>$h</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;postinsert($element_or_text...)"
>$h-&#62;postinsert($element_or_text...)</a></h2>

<p>Inserts the given nodes right AFTER <code>$h</code> in <code>$h</code>&#39;s parent&#39;s content list. This causes a fatal error if <code>$h</code> has no parent. None of the given nodes should be <code>$h</code> or other children of <code>$h</code>. Returns <code>$h</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;replace_with_content()"
>$h-&#62;replace_with_content()</a></h2>

<p>This replaces <code>$h</code> in its parent&#39;s content list with its own content. The element <code>$h</code> (which by then has no parent or content of its own) is returned. This causes a fatal error if <code>$h</code> has no parent. Also, note that this does not destroy <code>$h</code> -- use <code>$h-&#62;replace_with_content-&#62;delete</code> if you need that.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;delete_content()"
>$h-&#62;delete_content()</a></h2>

<p>Clears the content of <code>$h</code>, calling <code>$h-&#62;delete</code> for each content element. Compare with <code>$h-&#62;detach_content</code>.</p>

<p>Returns <code>$h</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;delete()_destroy_destroy_content"
>$h-&#62;delete() destroy destroy_content</a></h2>

<p>Detaches this element from its parent (if it has one) and explicitly destroys the element and all its descendants. The return value is undef.</p>

<p>Perl uses garbage collection based on reference counting; when no references to a data structure exist, it&#39;s implicitly destroyed -- i.e., when no value anywhere points to a given object anymore, Perl knows it can free up the memory that the now-unused object occupies.</p>

<p>But this fails with HTML::Element trees, because a parent element always holds references to its children, and its children elements hold references to the parent, so no element ever looks like it&#39;s <i>not</i> in use. So, to destroy those elements, you need to call <code>$h-&#62;delete</code> on the parent.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;clone()"
>$h-&#62;clone()</a></h2>

<p>Returns a copy of the element (whose children are clones (recursively) of the original&#39;s children, if any).</p>

<p>The returned element is parentless. Any &#39;_pos&#39; attributes present in the source element/tree will be absent in the copy. For that and other reasons, the clone of an HTML::TreeBuilder object that&#39;s in mid-parse (i.e, the head of a tree that HTML::TreeBuilder is elaborating) cannot (currently) be used to continue the parse.</p>

<p>You are free to clone HTML::TreeBuilder trees, just as long as: 1) they&#39;re done being parsed, or 2) you don&#39;t expect to resume parsing into the clone. (You can continue parsing into the original; it is never affected.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HTML::Element-&#62;clone_list(...nodes...)"
>HTML::Element-&#62;clone_list(...nodes...)</a></h2>

<p>Returns a list consisting of a copy of each node given. Text segments are simply copied; elements are cloned by calling $it-&#62;clone on each of them.</p>

<p>Note that this must be called as a class method, not as an instance method. <code>clone_list</code> will croak if called as an instance method. You can also call it like so:</p>

<pre class="sh_perl">    ref($h)-&#62;clone_list(...nodes...)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;normalize_content"
>$h-&#62;normalize_content</a></h2>

<p>Normalizes the content of <code>$h</code> -- i.e., concatenates any adjacent text nodes. (Any undefined text segments are turned into empty-strings.) Note that this does not recurse into <code>$h</code>&#39;s descendants.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;delete_ignorable_whitespace()"
>$h-&#62;delete_ignorable_whitespace()</a></h2>

<p>This traverses under <code>$h</code> and deletes any text segments that are ignorable whitespace. You should not use this if <code>$h</code> under a &#39;pre&#39; element.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;insert_element($element,_$implicit)"
>$h-&#62;insert_element($element, $implicit)</a></h2>

<p>Inserts (via push_content) a new element under the element at <code>$h-&#62;pos()</code>. Then updates <code>$h-&#62;pos()</code> to point to the inserted element, unless $element is a prototypically empty element like &#34;br&#34;, &#34;hr&#34;, &#34;img&#34;, etc. The new <code>$h-&#62;pos()</code> is returned. This method is useful only if your particular tree task involves setting <code>$h-&#62;pos()</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DUMPING_METHODS"
>DUMPING METHODS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;dump()"
>$h-&#62;dump()</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;dump(*FH)_;_#_or_*FH{IO}_or_$fh_obj"
>$h-&#62;dump(*FH) ; # or *FH{IO} or $fh_obj</a></h2>

<p>Prints the element and all its children to STDOUT (or to a specified filehandle), in a format useful only for debugging. The structure of the document is shown by indentation (no end tags).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;as_HTML()_or_$h-&#62;as_HTML($entities)"
>$h-&#62;as_HTML() or $h-&#62;as_HTML($entities)</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="or_$h-&#62;as_HTML($entities,_$indent_char)"
>or $h-&#62;as_HTML($entities, $indent_char)</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="or_$h-&#62;as_HTML($entities,_$indent_char,_\%optional_end_tags)"
>or $h-&#62;as_HTML($entities, $indent_char, \%optional_end_tags)</a></h2>

<p>Returns a string representing in HTML the element and its descendants. The optional argument <code>$entities</code> specifies a string of the entities to encode. For compatibility with previous versions, specify <code>&#39;&#60;&#62;&#38;&#39;</code> here. If omitted or undef, <i>all</i> unsafe characters are encoded as HTML entities. See <a href="/perldoc?HTML%3A%3AEntities" class="podlinkpod"
>HTML::Entities</a> for details. If passed an empty string, no entities are encoded.</p>

<p>If $indent_char is specified and defined, the HTML to be output is intented, using the string you specify (which you probably should set to &#34;\t&#34;, or some number of spaces, if you specify it).</p>

<p>If <code>\%optional_end_tags</code> is specified and defined, it should be a reference to a hash that holds a true value for every tag name whose end tag is optional. Defaults to <code>\%HTML::Element::optionalEndTag</code>, which is an alias to <code>%HTML::Tagset::optionalEndTag</code>, which, at time of writing, contains true values for <code>p, li, dt, dd</code>. A useful value to pass is an empty hashref, <code>{}</code>, which means that no end-tags are optional for this dump. Otherwise, possibly consider copying <code>%HTML::Tagset::optionalEndTag</code> to a hash of your own, adding or deleting values as you like, and passing a reference to that hash.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;as_text()"
>$h-&#62;as_text()</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;as_text(skip_dels_=&#62;_1,_extra_chars_=&#62;_&#39;\xA0&#39;)"
>$h-&#62;as_text(skip_dels =&#62; 1, extra_chars =&#62; &#39;\xA0&#39;)</a></h2>

<p>Returns a string consisting of only the text parts of the element&#39;s descendants.</p>

<p>Text under &#39;script&#39; or &#39;style&#39; elements is never included in what&#39;s returned. If <code>skip_dels</code> is true, then text content under &#34;del&#34; nodes is not included in what&#39;s returned.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;as_trimmed_text(...)_as_text_trimmed"
>$h-&#62;as_trimmed_text(...) as_text_trimmed</a></h2>

<p>This is just like as_text(...) except that leading and trailing whitespace is deleted, and any internal whitespace is collapsed.</p>

<p>This will not remove hard spaces, unicode spaces, or any other non ASCII white space unless you supplye the extra characters as a string argument. e.g. $h-&#62;as_trimmed_text(extra_chars =&#62; &#39;\xA0&#39;)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;as_XML()"
>$h-&#62;as_XML()</a></h2>

<p>Returns a string representing in XML the element and its descendants.</p>

<p>The XML is not indented.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;as_Lisp_form()"
>$h-&#62;as_Lisp_form()</a></h2>

<p>Returns a string representing the element and its descendants as a Lisp form. Unsafe characters are encoded as octal escapes.</p>

<p>The Lisp form is indented, and contains external (&#34;href&#34;, etc.) as well as internal attributes (&#34;_tag&#34;, &#34;_content&#34;, &#34;_implicit&#34;, etc.), except for &#34;_parent&#34;, which is omitted.</p>

<p>Current example output for a given element:</p>

<pre class="sh_perl">  (&#34;_tag&#34; &#34;img&#34; &#34;border&#34; &#34;0&#34; &#34;src&#34; &#34;pie.png&#34; &#34;usemap&#34; &#34;#main.map&#34;)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="format"
>format</a></h2>

<p>Formats text output. Defaults to HTML::FormatText.</p>

<p>Takes a second argument that is a reference to a formatter.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;starttag()_or_$h-&#62;starttag($entities)"
>$h-&#62;starttag() or $h-&#62;starttag($entities)</a></h2>

<p>Returns a string representing the complete start tag for the element. I.e., leading &#34;&#60;&#34;, tag name, attributes, and trailing &#34;&#62;&#34;. All values are surrounded with double-quotes, and appropriate characters are encoded. If <code>$entities</code> is omitted or undef, <i>all</i> unsafe characters are encoded as HTML entities. See <a href="/perldoc?HTML%3A%3AEntities" class="podlinkpod"
>HTML::Entities</a> for details. If you specify some value for <code>$entities</code>, remember to include the double-quote character in it. (Previous versions of this module would basically behave as if <code>&#39;&#38;&#34;&#62;&#39;</code> were specified for <code>$entities</code>.) If <code>$entities</code> is an empty string, no entity is escaped.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="starttag_XML"
>starttag_XML</a></h2>

<p>Returns a string representing the complete start tag for the element.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;endtag()_||_endtag_XML"
>$h-&#62;endtag() || endtag_XML</a></h2>

<p>Returns a string representing the complete end tag for this element. I.e., &#34;&#60;/&#34;, tag name, and &#34;&#62;&#34;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SECONDARY_STRUCTURAL_METHODS"
>SECONDARY STRUCTURAL METHODS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>These methods all involve some structural aspect of the tree; either they report some aspect of the tree&#39;s structure, or they involve traversal down the tree, or walking up the tree.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;is_inside(&#39;tag&#39;,_...)_or_$h-&#62;is_inside($element,_...)"
>$h-&#62;is_inside(&#39;tag&#39;, ...) or $h-&#62;is_inside($element, ...)</a></h2>

<p>Returns true if the $h element is, or is contained anywhere inside an element that is any of the ones listed, or whose tag name is any of the tag names listed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;is_empty()"
>$h-&#62;is_empty()</a></h2>

<p>Returns true if $h has no content, i.e., has no elements or text segments under it. In other words, this returns true if $h is a leaf node, AKA a terminal node. Do not confuse this sense of &#34;empty&#34; with another sense that it can have in SGML/HTML/XML terminology, which means that the element in question is of the type (like HTML&#39;s &#34;hr&#34;, &#34;br&#34;, &#34;img&#34;, etc.) that <i>can&#39;t</i> have any content.</p>

<p>That is, a particular &#34;p&#34; element may happen to have no content, so $that_p_element-&#62;is_empty will be true -- even though the prototypical &#34;p&#34; element isn&#39;t &#34;empty&#34; (not in the way that the prototypical &#34;hr&#34; element is).</p>

<p>If you think this might make for potentially confusing code, consider simply using the clearer exact equivalent: not($h-&#62;content_list)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;pindex()"
>$h-&#62;pindex()</a></h2>

<p>Return the index of the element in its parent&#39;s contents array, such that $h would equal</p>

<pre class="sh_perl">  $h-&#62;parent-&#62;content-&#62;[$h-&#62;pindex]
  or
  ($h-&#62;parent-&#62;content_list)[$h-&#62;pindex]</pre>

<p>assuming $h isn&#39;t root. If the element $h is root, then $h-&#62;pindex returns undef.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;left()"
>$h-&#62;left()</a></h2>

<p>In scalar context: returns the node that&#39;s the immediate left sibling of $h. If $h is the leftmost (or only) child of its parent (or has no parent), then this returns undef.</p>

<p>In list context: returns all the nodes that&#39;re the left siblings of $h (starting with the leftmost). If $h is the leftmost (or only) child of its parent (or has no parent), then this returns empty-list.</p>

<p>(See also $h-&#62;preinsert(LIST).)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;right()"
>$h-&#62;right()</a></h2>

<p>In scalar context: returns the node that&#39;s the immediate right sibling of $h. If $h is the rightmost (or only) child of its parent (or has no parent), then this returns undef.</p>

<p>In list context: returns all the nodes that&#39;re the right siblings of $h, starting with the leftmost. If $h is the rightmost (or only) child of its parent (or has no parent), then this returns empty-list.</p>

<p>(See also $h-&#62;postinsert(LIST).)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;address()"
>$h-&#62;address()</a></h2>

<p>Returns a string representing the location of this node in the tree. The address consists of numbers joined by a &#39;.&#39;, starting with &#39;0&#39;, and followed by the pindexes of the nodes in the tree that are ancestors of $h, starting from the top.</p>

<p>So if the way to get to a node starting at the root is to go to child 2 of the root, then child 10 of that, and then child 0 of that, and then you&#39;re there -- then that node&#39;s address is &#34;0.2.10.0&#34;.</p>

<p>As a bit of a special case, the address of the root is simply &#34;0&#34;.</p>

<p>I forsee this being used mainly for debugging, but you may find your own uses for it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;address($address)"
>$h-&#62;address($address)</a></h2>

<p>This returns the node (whether element or text-segment) at the given address in the tree that $h is a part of. (That is, the address is resolved starting from $h-&#62;root.)</p>

<p>If there is no node at the given address, this returns undef.</p>

<p>You can specify &#34;relative addressing&#34; (i.e., that indexing is supposed to start from $h and not from $h-&#62;root) by having the address start with a period -- e.g., $h-&#62;address(&#34;.3.2&#34;) will look at child 3 of $h, and child 2 of that.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;depth()"
>$h-&#62;depth()</a></h2>

<p>Returns a number expressing <code>$h</code>&#39;s depth within its tree, i.e., how many steps away it is from the root. If <code>$h</code> has no parent (i.e., is root), its depth is 0.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;root()"
>$h-&#62;root()</a></h2>

<p>Returns the element that&#39;s the top of <code>$h</code>&#39;s tree. If <code>$h</code> is root, this just returns <code>$h</code>. (If you want to test whether <code>$h</code> <i>is</i> the root, instead of asking what its root is, just test <code>not($h-&#62;parent)</code>.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;lineage()"
>$h-&#62;lineage()</a></h2>

<p>Returns the list of <code>$h</code>&#39;s ancestors, starting with its parent, and then that parent&#39;s parent, and so on, up to the root. If <code>$h</code> is root, this returns an empty list.</p>

<p>If you simply want a count of the number of elements in <code>$h</code>&#39;s lineage, use $h-&#62;depth.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;lineage_tag_names()"
>$h-&#62;lineage_tag_names()</a></h2>

<p>Returns the list of the tag names of $h&#39;s ancestors, starting with its parent, and that parent&#39;s parent, and so on, up to the root. If $h is root, this returns an empty list. Example output: <code>(&#39;em&#39;, &#39;td&#39;, &#39;tr&#39;, &#39;table&#39;, &#39;body&#39;, &#39;html&#39;)</code></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;descendants()"
>$h-&#62;descendants()</a></h2>

<p>In list context, returns the list of all $h&#39;s descendant elements, listed in pre-order (i.e., an element appears before its content-elements). Text segments DO NOT appear in the list. In scalar context, returns a count of all such elements.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;descendents()"
>$h-&#62;descendents()</a></h2>

<p>This is just an alias to the <code>descendants</code> method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;find_by_tag_name(&#39;tag&#39;,_...)"
>$h-&#62;find_by_tag_name(&#39;tag&#39;, ...)</a></h2>

<p>In list context, returns a list of elements at or under $h that have any of the specified tag names. In scalar context, returns the first (in pre-order traversal of the tree) such element found, or undef if none.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;find(&#39;tag&#39;,_...)"
>$h-&#62;find(&#39;tag&#39;, ...)</a></h2>

<p>This is just an alias to <code>find_by_tag_name</code>. (There was once going to be a whole find_* family of methods, but then look_down filled that niche, so there turned out not to be much reason for the verboseness of the name &#34;find_by_tag_name&#34;.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;find_by_attribute(&#39;attribute&#39;,_&#39;value&#39;)"
>$h-&#62;find_by_attribute(&#39;attribute&#39;, &#39;value&#39;)</a></h2>

<p>In a list context, returns a list of elements at or under $h that have the specified attribute, and have the given value for that attribute. In a scalar context, returns the first (in pre-order traversal of the tree) such element found, or undef if none.</p>

<p>This method is <b>deprecated</b> in favor of the more expressive <code>look_down</code> method, which new code should use instead.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;look_down(_...criteria..._)"
>$h-&#62;look_down( ...criteria... )</a></h2>

<p>This starts at $h and looks thru its element descendants (in pre-order), looking for elements matching the criteria you specify. In list context, returns all elements that match all the given criteria; in scalar context, returns the first such element (or undef, if nothing matched).</p>

<p>There are three kinds of criteria you can specify:</p>

<dl>
<dt><a name='attr_name'></a><a name="(attr_name,_attr_value)"
>(attr_name, attr_value)</a></dt>

<dd>
<p>This means you&#39;re looking for an element with that value for that attribute. Example: <code>&#34;alt&#34;, &#34;pix!&#34;</code>. Consider that you can search on internal attribute values too: <code>&#34;_tag&#34;, &#34;p&#34;</code>.</p>

<dt><a name='attr_name'></a><a name="(attr_name,_qr/.../)"
>(attr_name, qr/.../)</a></dt>

<dd>
<p>This means you&#39;re looking for an element whose value for that attribute matches the specified Regexp object.</p>

<dt><a name='a'></a><a name="a_coderef"
>a coderef</a></dt>

<dd>
<p>This means you&#39;re looking for elements where coderef-&#62;(each_element) returns true. Example:</p>

<pre class="sh_perl">  my @wide_pix_images
    = $h-&#62;look_down(
                    &#34;_tag&#34;, &#34;img&#34;,
                    &#34;alt&#34;, &#34;pix!&#34;,
                    sub { $_[0]-&#62;attr(&#39;width&#39;) &#62; 350 }
                   );</pre>
</dd>
</dl>

<p>Note that <code>(attr_name, attr_value)</code> and <code>(attr_name, qr/.../)</code> criteria are almost always faster than coderef criteria, so should presumably be put before them in your list of criteria. That is, in the example above, the sub ref is called only for elements that have already passed the criteria of having a &#34;_tag&#34; attribute with value &#34;img&#34;, and an &#34;alt&#34; attribute with value &#34;pix!&#34;. If the coderef were first, it would be called on every element, and <i>then</i> what elements pass that criterion (i.e., elements for which the coderef returned true) would be checked for their &#34;_tag&#34; and &#34;alt&#34; attributes.</p>

<p>Note that comparison of string attribute-values against the string value in <code>(attr_name, attr_value)</code> is case-INsensitive! A criterion of <code>(&#39;align&#39;, &#39;right&#39;)</code> <i>will</i> match an element whose &#34;align&#34; value is &#34;RIGHT&#34;, or &#34;right&#34; or &#34;rIGhT&#34;, etc.</p>

<p>Note also that <code>look_down</code> considers &#34;&#34; (empty-string) and undef to be different things, in attribute values. So this:</p>

<pre class="sh_perl">  $h-&#62;look_down(&#34;alt&#34;, &#34;&#34;)</pre>

<p>will find elements <i>with</i> an &#34;alt&#34; attribute, but where the value for the &#34;alt&#34; attribute is &#34;&#34;. But this:</p>

<pre class="sh_perl">  $h-&#62;look_down(&#34;alt&#34;, undef)</pre>

<p>is the same as:</p>

<pre class="sh_perl">  $h-&#62;look_down(sub { !defined($_[0]-&#62;attr(&#39;alt&#39;)) } )</pre>

<p>That is, it finds elements that do not have an &#34;alt&#34; attribute at all (or that do have an &#34;alt&#34; attribute, but with a value of undef -- which is not normally possible).</p>

<p>Note that when you give several criteria, this is taken to mean you&#39;re looking for elements that match <i>all</i> your criterion, not just <i>any</i> of them. In other words, there is an implicit &#34;and&#34;, not an &#34;or&#34;. So if you wanted to express that you wanted to find elements with a &#34;name&#34; attribute with the value &#34;foo&#34; <i>or</i> with an &#34;id&#34; attribute with the value &#34;baz&#34;, you&#39;d have to do it like:</p>

<pre class="sh_perl">  @them = $h-&#62;look_down(
    sub {
      # the lcs are to fold case
      lc($_[0]-&#62;attr(&#39;name&#39;)) eq &#39;foo&#39;
      or lc($_[0]-&#62;attr(&#39;id&#39;)) eq &#39;baz&#39;
    }
  );</pre>

<p>Coderef criteria are more expressive than <code>(attr_name, attr_value)</code> and <code>(attr_name, qr/.../)</code> criteria, and all <code>(attr_name, attr_value)</code> and <code>(attr_name, qr/.../)</code> criteria could be expressed in terms of coderefs. However, <code>(attr_name, attr_value)</code> and <code>(attr_name, qr/.../)</code> criteria are a convenient shorthand. (In fact, <code>look_down</code> itself is basically &#34;shorthand&#34; too, since anything you can do with <code>look_down</code> you could do by traversing the tree, either with the <code>traverse</code> method or with a routine of your own. However, <code>look_down</code> often makes for very concise and clear code.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;look_up(_...criteria..._)"
>$h-&#62;look_up( ...criteria... )</a></h2>

<p>This is identical to $h-&#62;look_down, except that whereas $h-&#62;look_down basically scans over the list:</p>

<pre class="sh_perl">   ($h, $h-&#62;descendants)</pre>

<p>$h-&#62;look_up instead scans over the list</p>

<pre class="sh_perl">   ($h, $h-&#62;lineage)</pre>

<p>So, for example, this returns all ancestors of $h (possibly including $h itself) that are &#34;td&#34; elements with an &#34;align&#34; attribute with a value of &#34;right&#34; (or &#34;RIGHT&#34;, etc.):</p>

<pre class="sh_perl">   $h-&#62;look_up(&#34;_tag&#34;, &#34;td&#34;, &#34;align&#34;, &#34;right&#34;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;traverse(...options...)"
>$h-&#62;traverse(...options...)</a></h2>

<p>Lengthy discussion of HTML::Element&#39;s unnecessary and confusing <code>traverse</code> method has been moved to a separate file: <a href="/~jfearn/HTML-Tree-4.2/lib/HTML/Element/traverse.pm" class="podlinkpod"
>HTML::Element::traverse</a></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;attr_get_i(&#39;attribute&#39;)"
>$h-&#62;attr_get_i(&#39;attribute&#39;)</a></h2>

<p>In list context, returns a list consisting of the values of the given attribute for $self and for all its ancestors starting from $self and working its way up. Nodes with no such attribute are skipped. (&#34;attr_get_i&#34; stands for &#34;attribute get, with inheritance&#34;.) In scalar context, returns the first such value, or undef if none.</p>

<p>Consider a document consisting of:</p>

<pre class="sh_perl">   &#60;html lang=&#39;i-klingon&#39;&#62;
     &#60;head&#62;&#60;title&#62;Pati Pata&#60;/title&#62;&#60;/head&#62;
     &#60;body&#62;
       &#60;h1 lang=&#39;la&#39;&#62;Stuff&#60;/h1&#62;
       &#60;p lang=&#39;es-MX&#39; align=&#39;center&#39;&#62;
         Foo bar baz &#60;cite&#62;Quux&#60;/cite&#62;.
       &#60;/p&#62;
       &#60;p&#62;Hooboy.&#60;/p&#62;
     &#60;/body&#62;
   &#60;/html&#62;</pre>

<p>If $h is the &#34;cite&#34; element, $h-&#62;attr_get_i(&#34;lang&#34;) in list context will return the list (&#39;es-MX&#39;, &#39;i-klingon&#39;). In scalar context, it will return the value &#39;es-MX&#39;.</p>

<p>If you call with multiple attribute names...</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;attr_get_i(&#39;a1&#39;,_&#39;a2&#39;,_&#39;a3&#39;)"
>$h-&#62;attr_get_i(&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;)</a></h2>

<p>...in list context, this will return a list consisting of the values of these attributes which exist in $self and its ancestors. In scalar context, this returns the first value (i.e., the value of the first existing attribute from the first element that has any of the attributes listed). So, in the above example,</p>

<pre class="sh_perl">  $h-&#62;attr_get_i(&#39;lang&#39;, &#39;align&#39;);</pre>

<p>will return:</p>

<pre class="sh_perl">   (&#39;es-MX&#39;, &#39;center&#39;, &#39;i-klingon&#39;) # in list context
  or
   &#39;es-MX&#39; # in scalar context.</pre>

<p>But note that this:</p>

<pre class="sh_perl"> $h-&#62;attr_get_i(&#39;align&#39;, &#39;lang&#39;);</pre>

<p>will return:</p>

<pre class="sh_perl">   (&#39;center&#39;, &#39;es-MX&#39;, &#39;i-klingon&#39;) # in list context
  or
   &#39;center&#39; # in scalar context.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;tagname_map()"
>$h-&#62;tagname_map()</a></h2>

<p>Scans across <code>$h</code> and all its descendants, and makes a hash (a reference to which is returned) where each entry consists of a key that&#39;s a tag name, and a value that&#39;s a reference to a list to all elements that have that tag name. I.e., this method returns:</p>

<pre class="sh_perl">   {
     # Across $h and all descendants...
     &#39;a&#39;   =&#62; [ ...list of all &#39;a&#39;   elements... ],
     &#39;em&#39;  =&#62; [ ...list of all &#39;em&#39;  elements... ],
     &#39;img&#39; =&#62; [ ...list of all &#39;img&#39; elements... ],
   }</pre>

<p>(There are entries in the hash for only those tagnames that occur at/under <code>$h</code> -- so if there&#39;s no &#34;img&#34; elements, there&#39;ll be no &#34;img&#34; entry in the hashr(ref) returned.)</p>

<p>Example usage:</p>

<pre class="sh_perl">    my $map_r = $h-&#62;tagname_map();
    my @heading_tags = sort grep m/^h\d$/s, keys %$map_r;
    if(@heading_tags) {
      print &#34;Heading levels used: @heading_tags\n&#34;;
    } else {
      print &#34;No headings.\n&#34;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;extract_links()_or_$h-&#62;extract_links(@wantedTypes)"
>$h-&#62;extract_links() or $h-&#62;extract_links(@wantedTypes)</a></h2>

<p>Returns links found by traversing the element and all of its children and looking for attributes (like &#34;href&#34; in an &#34;a&#34; element, or &#34;src&#34; in an &#34;img&#34; element) whose values represent links. The return value is a <i>reference</i> to an array. Each element of the array is reference to an array with <i>four</i> items: the link-value, the element that has the attribute with that link-value, and the name of that attribute, and the tagname of that element. (Example: <code>[&#39;<a href="http://www.suck.com/" class="podlinkurl"
>http://www.suck.com/</a>&#39;,</code> <i>$elem_obj</i> <code>, &#39;href&#39;, &#39;a&#39;]</code>.) You may or may not end up using the element itself -- for some purposes, you may use only the link value.</p>

<p>You might specify that you want to extract links from just some kinds of elements (instead of the default, which is to extract links from <i>all</i> the kinds of elements known to have attributes whose values represent links). For instance, if you want to extract links from only &#34;a&#34; and &#34;img&#34; elements, you could code it like this:</p>

<pre class="sh_perl">  for (@{  $e-&#62;extract_links(&#39;a&#39;, &#39;img&#39;)  }) {
      my($link, $element, $attr, $tag) = @$_;
      print
        &#34;Hey, there&#39;s a $tag that links to &#34;,
        $link, &#34;, in its $attr attribute, at &#34;,
        $element-&#62;address(), &#34;.\n&#34;;
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;simplify_pres"
>$h-&#62;simplify_pres</a></h2>

<p>In text bits under PRE elements that are at/under $h, this routine nativizes all newlines, and expands all tabs.</p>

<p>That is, if you read a file with lines delimited by <code>\cm\cj</code>&#39;s, the text under PRE areas will have <code>\cm\cj</code>&#39;s instead of <code>\n</code>&#39;s. Calling $h-&#62;nativize_pre_newlines on such a tree will turn <code>\cm\cj</code>&#39;s into <code>\n</code>&#39;s.</p>

<p>Tabs are expanded to however many spaces it takes to get to the next 8th column -- the usual way of expanding them.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;same_as($i)"
>$h-&#62;same_as($i)</a></h2>

<p>Returns true if $h and $i are both elements representing the same tree of elements, each with the same tag name, with the same explicit attributes (i.e., not counting attributes whose names start with &#34;_&#34;), and with the same content (textual, comments, etc.).</p>

<p>Sameness of descendant elements is tested, recursively, with <code>$child1-&#62;same_as($child_2)</code>, and sameness of text segments is tested with <code>$segment1 eq $segment2</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h_=_HTML::Element-&#62;new_from_lol(ARRAYREF)"
>$h = HTML::Element-&#62;new_from_lol(ARRAYREF)</a></h2>

<p>Resursively constructs a tree of nodes, based on the (non-cyclic) data structure represented by ARRAYREF, where that is a reference to an array of arrays (of arrays (of arrays (etc.))).</p>

<p>In each arrayref in that structure, different kinds of values are treated as follows:</p>

<ul>
<li>Arrayrefs
<p>Arrayrefs are considered to designate a sub-tree representing children for the node constructed from the current arrayref.</p>
</li>

<li>Hashrefs
<p>Hashrefs are considered to contain attribute-value pairs to add to the element to be constructed from the current arrayref</p>
</li>

<li>Text segments
<p>Text segments at the start of any arrayref will be considered to specify the name of the element to be constructed from the current araryref; all other text segments will be considered to specify text segments as children for the current arrayref.</p>
</li>

<li>Elements
<p>Existing element objects are either inserted into the treelet constructed, or clones of them are. That is, when the lol-tree is being traversed and elements constructed based what&#39;s in it, if an existing element object is found, if it has no parent, then it is added directly to the treelet constructed; but if it has a parent, then <code>$that_node-&#62;clone</code> is added to the treelet at the appropriate place.</p>
</li>
</ul>

<p>An example will hopefully make this more obvious:</p>

<pre class="sh_perl">  my $h = HTML::Element-&#62;new_from_lol(
    [&#39;html&#39;,
      [&#39;head&#39;,
        [ &#39;title&#39;, &#39;I like stuff!&#39; ],
      ],
      [&#39;body&#39;,
        {&#39;lang&#39;, &#39;en-JP&#39;, _implicit =&#62; 1},
        &#39;stuff&#39;,
        [&#39;p&#39;, &#39;um, p &#60; 4!&#39;, {&#39;class&#39; =&#62; &#39;par123&#39;}],
        [&#39;div&#39;, {foo =&#62; &#39;bar&#39;}, &#39;123&#39;],
      ]
    ]
  );
  $h-&#62;dump;</pre>

<p>Will print this:</p>

<pre class="sh_perl">  &#60;html&#62; @0
    &#60;head&#62; @0.0
      &#60;title&#62; @0.0.0
        &#34;I like stuff!&#34;
    &#60;body lang=&#34;en-JP&#34;&#62; @0.1 (IMPLICIT)
      &#34;stuff&#34;
      &#60;p class=&#34;par123&#34;&#62; @0.1.1
        &#34;um, p &#60; 4!&#34;
      &#60;div foo=&#34;bar&#34;&#62; @0.1.2
        &#34;123&#34;</pre>

<p>And printing $h-&#62;as_HTML will give something like:</p>

<pre class="sh_perl">  &#60;html&#62;&#60;head&#62;&#60;title&#62;I like stuff!&#60;/title&#62;&#60;/head&#62;
  &#60;body lang=&#34;en-JP&#34;&#62;stuff&#60;p class=&#34;par123&#34;&#62;um, p &#38;lt; 4!
  &#60;div foo=&#34;bar&#34;&#62;123&#60;/div&#62;&#60;/body&#62;&#60;/html&#62;</pre>

<p>You can even do fancy things with <code>map</code>:</p>

<pre class="sh_perl">  $body-&#62;push_content(
    # push_content implicitly calls new_from_lol on arrayrefs...
    [&#39;br&#39;],
    [&#39;blockquote&#39;,
      [&#39;h2&#39;, &#39;Pictures!&#39;],
      map [&#39;p&#39;, $_],
      $body2-&#62;look_down(&#34;_tag&#34;, &#34;img&#34;),
        # images, to be copied from that other tree.
    ],
    # and more stuff:
    [&#39;ul&#39;,
      map [&#39;li&#39;, [&#39;a&#39;, {&#39;href&#39;=&#62;&#34;$_.png&#34;}, $_ ] ],
      qw(Peaches Apples Pears Mangos)
    ],
  );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="@elements_=_HTML::Element-&#62;new_from_lol(ARRAYREFS)"
>@elements = HTML::Element-&#62;new_from_lol(ARRAYREFS)</a></h2>

<p>Constructs <i>several</i> elements, by calling new_from_lol for every arrayref in the ARRAYREFS list.</p>

<pre class="sh_perl">  @elements = HTML::Element-&#62;new_from_lol(
    [&#39;hr&#39;],
    [&#39;p&#39;, &#39;And there, on the door, was a hook!&#39;],
  );
   # constructs two elements.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;objectify_text()"
>$h-&#62;objectify_text()</a></h2>

<p>This turns any text nodes under $h from mere text segments (strings) into real objects, pseudo-elements with a tag-name of &#34;~text&#34;, and the actual text content in an attribute called &#34;text&#34;. (For a discussion of pseudo-elements, see the &#34;tag&#34; method, far above.) This method is provided because, for some purposes, it is convenient or necessary to be able, for a given text node, to ask what element is its parent; and clearly this is not possible if a node is just a text string.</p>

<p>Note that these &#34;~text&#34; objects are not recognized as text nodes by methods like as_text. Presumably you will want to call $h-&#62;objectify_text, perform whatever task that you needed that for, and then call $h-&#62;deobjectify_text before calling anything like $h-&#62;as_text.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;deobjectify_text()"
>$h-&#62;deobjectify_text()</a></h2>

<p>This undoes the effect of $h-&#62;objectify_text. That is, it takes any &#34;~text&#34; pseudo-elements in the tree at/under $h, and deletes each one, replacing each with the content of its &#34;text&#34; attribute.</p>

<p>Note that if $h itself is a &#34;~text&#34; pseudo-element, it will be destroyed -- a condition you may need to treat specially in your calling code (since it means you can&#39;t very well do anything with $h after that). So that you can detect that condition, if $h is itself a &#34;~text&#34; pseudo-element, then this method returns the value of the &#34;text&#34; attribute, which should be a defined value; in all other cases, it returns undef.</p>

<p>(This method assumes that no &#34;~text&#34; pseudo-element has any children.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;number_lists()"
>$h-&#62;number_lists()</a></h2>

<p>For every UL, OL, DIR, and MENU element at/under $h, this sets a &#34;_bullet&#34; attribute for every child LI element. For LI children of an OL, the &#34;_bullet&#34; attribute&#39;s value will be something like &#34;4.&#34;, &#34;d.&#34;, &#34;D.&#34;, &#34;IV.&#34;, or &#34;iv.&#34;, depending on the OL element&#39;s &#34;type&#34; attribute. LI children of a UL, DIR, or MENU get their &#34;_bullet&#34; attribute set to &#34;*&#34;. There should be no other LIs (i.e., except as children of OL, UL, DIR, or MENU elements), and if there are, they are unaffected.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;has_insane_linkage"
>$h-&#62;has_insane_linkage</a></h2>

<p>This method is for testing whether this element or the elements under it have linkage attributes (_parent and _content) whose values are deeply aberrant: if there are undefs in a content list; if an element appears in the content lists of more than one element; if the _parent attribute of an element doesn&#39;t match its actual parent; or if an element appears as its own descendant (i.e., if there is a cyclicity in the tree).</p>

<p>This returns empty list (or false, in scalar context) if the subtree&#39;s linkage methods are sane; otherwise it returns two items (or true, in scalar context): the element where the error occurred, and a string describing the error.</p>

<p>This method is provided is mainly for debugging and troubleshooting -- it should be <i>quite impossible</i> for any document constructed via HTML::TreeBuilder to parse into a non-sane tree (since it&#39;s not the content of the tree per se that&#39;s in question, but whether the tree in memory was properly constructed); and it <i>should</i> be impossible for you to produce an insane tree just thru reasonable use of normal documented structure-modifying methods. But if you&#39;re constructing your own trees, and your program is going into infinite loops as during calls to traverse() or any of the secondary structural methods, as part of debugging, consider calling is_insane on the tree.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$h-&#62;element_class"
>$h-&#62;element_class</a></h2>

<p>This method returns the class which will be used for new elements. It defaults to HTML::Element, but can be overridden by subclassing or esoteric means best left to those will will read the source and then not complain when those esoteric means change. (Just subclass.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>* If you want to free the memory associated with a tree built of HTML::Element nodes, then you will have to delete it explicitly. See the $h-&#62;delete method, above.</p>

<p>* There&#39;s almost nothing to stop you from making a &#34;tree&#34; with cyclicities (loops) in it, which could, for example, make the traverse method go into an infinite loop. So don&#39;t make cyclicities! (If all you&#39;re doing is parsing HTML files, and looking at the resulting trees, this will never be a problem for you.)</p>

<p>* There&#39;s no way to represent comments or processing directives in a tree with HTML::Elements. Not yet, at least.</p>

<p>* There&#39;s (currently) nothing to stop you from using an undefined value as a text segment. If you&#39;re running under <code>perl -w</code>, however, this may make HTML::Element&#39;s code produce a slew of warnings.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES_ON_SUBCLASSING"
>NOTES ON SUBCLASSING <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>You are welcome to derive subclasses from HTML::Element, but you should be aware that the code in HTML::Element makes certain assumptions about elements (and I&#39;m using &#34;element&#34; to mean ONLY an object of class HTML::Element, or of a subclass of HTML::Element):</p>

<p>* The value of an element&#39;s _parent attribute must either be undef or otherwise false, or must be an element.</p>

<p>* The value of an element&#39;s _content attribute must either be undef or otherwise false, or a reference to an (unblessed) array. The array may be empty; but if it has items, they must ALL be either mere strings (text segments), or elements.</p>

<p>* The value of an element&#39;s _tag attribute should, at least, be a string of printable characters.</p>

<p>Moreover, bear these rules in mind:</p>

<p>* Do not break encapsulation on objects. That is, access their contents only thru $obj-&#62;attr or more specific methods.</p>

<p>* You should think twice before completely overriding any of the methods that HTML::Element provides. (Overriding with a method that calls the superclass method is not so bad, though.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p><a href="/~jfearn/HTML-Tree-4.2/lib/HTML/Tree.pm" class="podlinkpod"
>HTML::Tree</a>; <a href="/~jfearn/HTML-Tree-4.2/lib/HTML/TreeBuilder.pm" class="podlinkpod"
>HTML::TreeBuilder</a>; <a href="/~jfearn/HTML-Tree-4.2/lib/HTML/AsSubs.pm" class="podlinkpod"
>HTML::AsSubs</a>; <a href="/perldoc?HTML%3A%3ATagset" class="podlinkpod"
>HTML::Tagset</a>; and, for the morbidly curious, <a href="/~jfearn/HTML-Tree-4.2/lib/HTML/Element/traverse.pm" class="podlinkpod"
>HTML::Element::traverse</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Copyright 1995-1998 Gisle Aas, 1999-2004 Sean M. Burke, 2005 Andy Lester, 2006 Pete Krawczyk, 2010 Jeff Fearn.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Current Author: Jeff Fearn <code>&#60;jfearn@cpan.org&#62;</code>.</p>

<p>Original HTML-Tree author: Gisle Aas.</p>

<p>Former Authors: Sean M. Burke. Andy Lester. Pete Krawczyk <code>&#60;petek@cpan.org&#62;</code>.</p>

<p>Thanks to Mark-Jason Dominus for a POD suggestion.</p>

</div>
<!-- This should probably be put in the <div class="footer"></div> -->
<script type="text/javascript">
    $(document).ready(function(){
        var startingStyle = $.cookie('css') ? $.cookie('css') : 'http://st.pimg.net/tucs/css/sh_none.min.css';
        $.fn.styleSwitch(startingStyle);
        $("#styleswitch").val(startingStyle);
        sh_highlightDocument();
        $("#styleswitch").bind(($.browser.msie ? "click" : "change"), function() {
            $.fn.styleSwitch($(this).val());
        });
    });
</script>
<div class="styleswitch">
    syntax highlighting:
    <select id="styleswitch">
        <option value="http://st.pimg.net/tucs/css/sh_none.min.css">no syntax highlighting</option>
        <option value="http://st.pimg.net/tucs/css/sh_acid.min.css">acid</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-dark.min.css">berries-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_berries-light.min.css">berries-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_bipolar.min.css">bipolar</option>
        <option value="http://st.pimg.net/tucs/css/sh_blacknblue.min.css">blacknblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_bright.min.css">bright</option>
        <option value="http://st.pimg.net/tucs/css/sh_contrast.min.css">contrast</option>
        <option value="http://st.pimg.net/tucs/css/sh_cpan.min.css">cpan</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkblue.min.css">darkblue</option>
        <option value="http://st.pimg.net/tucs/css/sh_darkness.min.css">darkness</option>
        <option value="http://st.pimg.net/tucs/css/sh_desert.min.css">desert</option>
        <option value="http://st.pimg.net/tucs/css/sh_dull.min.css">dull</option>
        <option value="http://st.pimg.net/tucs/css/sh_easter.min.css">easter</option>
        <option value="http://st.pimg.net/tucs/css/sh_emacs.min.css">emacs</option>
        <option value="http://st.pimg.net/tucs/css/sh_golden.min.css">golden</option>
        <option value="http://st.pimg.net/tucs/css/sh_greenlcd.min.css">greenlcd</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-anjuta.min.css">ide-anjuta</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-codewarrior.min.css">ide-codewarrior</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-devcpp.min.css">ide-devcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-eclipse.min.css">ide-eclipse</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-kdev.min.css">ide-kdev</option>
        <option value="http://st.pimg.net/tucs/css/sh_ide-msvcpp.min.css">ide-msvcpp</option>
        <option value="http://st.pimg.net/tucs/css/sh_kwrite.min.css">kwrite</option>
        <option value="http://st.pimg.net/tucs/css/sh_matlab.min.css">matlab</option>
        <option value="http://st.pimg.net/tucs/css/sh_navy.min.css">navy</option>
        <option value="http://st.pimg.net/tucs/css/sh_nedit.min.css">nedit</option>
        <option value="http://st.pimg.net/tucs/css/sh_neon.min.css">neon</option>
        <option value="http://st.pimg.net/tucs/css/sh_night.min.css">night</option>
        <option value="http://st.pimg.net/tucs/css/sh_pablo.min.css">pablo</option>
        <option value="http://st.pimg.net/tucs/css/sh_peachpuff.min.css">peachpuff</option>
        <option value="http://st.pimg.net/tucs/css/sh_print.min.css">print</option>
        <option value="http://st.pimg.net/tucs/css/sh_rand01.min.css">rand01</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-dark.min.css">solarized-dark</option>
	<option value="http://st.pimg.net/tucs/css/sh_solarized-light.min.css">solarized-light</option>
        <option value="http://st.pimg.net/tucs/css/sh_style.min.css">style</option>
        <option value="http://st.pimg.net/tucs/css/sh_the.min.css">the</option>
        <option value="http://st.pimg.net/tucs/css/sh_typical.min.css">typical</option>
        <option value="http://st.pimg.net/tucs/css/sh_vampire.min.css">vampire</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim-dark.min.css">vim-dark</option>
        <option value="http://st.pimg.net/tucs/css/sh_vim.min.css">vim</option>
        <option value="http://st.pimg.net/tucs/css/sh_whatis.min.css">whatis</option>
        <option value="http://st.pimg.net/tucs/css/sh_whitengrey.min.css">whitengrey</option>
        <option value="http://st.pimg.net/tucs/css/sh_zellner.min.css">zellner</option>
    </select>
</div>



<div class="footer"><div class="cpanstats">78156 Uploads, 24704 Distributions
105967 Modules, 9645 Uploaders
</div>
hosted by <a href="http://www.yellowbot.com">YellowBot</a><br/>
<a href="http://www.yellowbot.com"><img alt="do. tag. write. share." src="http://st.pimg.net/tucs/img/yellowbot_logo.gif"></a>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="http://ipv4.v6test.develooper.com/js/v1/v6test.js"></script>

<script type="text/javascript">
   // v6.target = '';
   if (!v6.target) { v6.only_once = true }
   v6.site = '7A0D89A6-2B82-11DF-B9DA-F61CBD13F020';
   v6.api_server = 'http://ipv4.v6test.develooper.com';
   try {
     v6.test();
   } catch(err) {}
</script>
<script type="text/javascript">
  $(document).ready(function(){
    $("a[href^=http:]").click(function(){
      var href = $(this).attr('href');
      var m = href.match('\/\/([^\/:]+)');
      _gaq.push(['_trackEvent','External',m[1],'Module']);
    });
    $("a[href^=/CPAN/]").click(function(){
      var href = $(this).attr('href');
      _gaq.push(['_trackEvent','Download',href,'Module']);
    });
  });
</script>
<!-- Tue Apr 24 19:41:22 2012 GMT (0.160855054855347) @cpansearch1 -->
 </body>
</html>
